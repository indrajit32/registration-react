{"ast":null,"code":"/** @license React v16.1.1\n * react-dom.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    var React = require('react');\n\n    var invariant = require('fbjs/lib/invariant');\n\n    var warning = require('fbjs/lib/warning');\n\n    var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\n\n    var _assign = require('object-assign');\n\n    var emptyFunction$1 = require('fbjs/lib/emptyFunction');\n\n    var EventListener = require('fbjs/lib/EventListener');\n\n    var getActiveElement = require('fbjs/lib/getActiveElement');\n\n    var shallowEqual = require('fbjs/lib/shallowEqual');\n\n    var containsNode = require('fbjs/lib/containsNode');\n\n    var focusNode = require('fbjs/lib/focusNode');\n\n    var emptyObject = require('fbjs/lib/emptyObject');\n\n    var checkPropTypes = require('prop-types/checkPropTypes');\n\n    var hyphenateStyleName = require('fbjs/lib/hyphenateStyleName');\n\n    var camelizeStyleName = require('fbjs/lib/camelizeStyleName');\n    /**\n     * WARNING: DO NOT manually require this module.\n     * This is a replacement for `invariant(...)` used by the error code system\n     * and will _only_ be required by the corresponding babel pass.\n     * It always throws.\n     */\n\n\n    !React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0; // These attributes should be all lowercase to allow for\n    // case insensitive checks\n\n    var RESERVED_PROPS = {\n      children: true,\n      dangerouslySetInnerHTML: true,\n      defaultValue: true,\n      defaultChecked: true,\n      innerHTML: true,\n      suppressContentEditableWarning: true,\n      suppressHydrationWarning: true,\n      style: true\n    };\n\n    function checkMask(value, bitmask) {\n      return (value & bitmask) === bitmask;\n    }\n\n    var DOMPropertyInjection = {\n      /**\n       * Mapping from normalized, camelcased property names to a configuration that\n       * specifies how the associated DOM property should be accessed or rendered.\n       */\n      MUST_USE_PROPERTY: 0x1,\n      HAS_BOOLEAN_VALUE: 0x4,\n      HAS_NUMERIC_VALUE: 0x8,\n      HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,\n      HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,\n      HAS_STRING_BOOLEAN_VALUE: 0x40,\n\n      /**\n       * Inject some specialized knowledge about the DOM. This takes a config object\n       * with the following properties:\n       *\n       * Properties: object mapping DOM property name to one of the\n       * DOMPropertyInjection constants or null. If your attribute isn't in here,\n       * it won't get written to the DOM.\n       *\n       * DOMAttributeNames: object mapping React attribute name to the DOM\n       * attribute name. Attribute names not specified use the **lowercase**\n       * normalized name.\n       *\n       * DOMAttributeNamespaces: object mapping React attribute name to the DOM\n       * attribute namespace URL. (Attribute names not specified use no namespace.)\n       *\n       * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.\n       * Property names not specified use the normalized name.\n       *\n       * DOMMutationMethods: Properties that require special mutation methods. If\n       * `value` is undefined, the mutation method should unset the property.\n       *\n       * @param {object} domPropertyConfig the config as described above.\n       */\n      injectDOMPropertyConfig: function (domPropertyConfig) {\n        var Injection = DOMPropertyInjection;\n        var Properties = domPropertyConfig.Properties || {};\n        var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};\n        var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};\n        var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};\n\n        for (var propName in Properties) {\n          !!properties.hasOwnProperty(propName) ? invariant(false, \"injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.\", propName) : void 0;\n          var lowerCased = propName.toLowerCase();\n          var propConfig = Properties[propName];\n          var propertyInfo = {\n            attributeName: lowerCased,\n            attributeNamespace: null,\n            propertyName: propName,\n            mutationMethod: null,\n            mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),\n            hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),\n            hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),\n            hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),\n            hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE),\n            hasStringBooleanValue: checkMask(propConfig, Injection.HAS_STRING_BOOLEAN_VALUE)\n          };\n          !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? invariant(false, \"DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s\", propName) : void 0;\n\n          if (DOMAttributeNames.hasOwnProperty(propName)) {\n            var attributeName = DOMAttributeNames[propName];\n            propertyInfo.attributeName = attributeName;\n          }\n\n          if (DOMAttributeNamespaces.hasOwnProperty(propName)) {\n            propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];\n          }\n\n          if (DOMMutationMethods.hasOwnProperty(propName)) {\n            propertyInfo.mutationMethod = DOMMutationMethods[propName];\n          } // Downcase references to whitelist properties to check for membership\n          // without case-sensitivity. This allows the whitelist to pick up\n          // `allowfullscreen`, which should be written using the property configuration\n          // for `allowFullscreen`\n\n\n          properties[propName] = propertyInfo;\n        }\n      }\n    };\n    /* eslint-disable max-len */\n\n    var ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n    /* eslint-enable max-len */\n\n    var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n    var ROOT_ATTRIBUTE_NAME = 'data-reactroot';\n    /**\n     * Map from property \"standard name\" to an object with info about how to set\n     * the property in the DOM. Each object contains:\n     *\n     * attributeName:\n     *   Used when rendering markup or with `*Attribute()`.\n     * attributeNamespace\n     * propertyName:\n     *   Used on DOM node instances. (This includes properties that mutate due to\n     *   external factors.)\n     * mutationMethod:\n     *   If non-null, used instead of the property or `setAttribute()` after\n     *   initial render.\n     * mustUseProperty:\n     *   Whether the property must be accessed and mutated as an object property.\n     * hasBooleanValue:\n     *   Whether the property should be removed when set to a falsey value.\n     * hasNumericValue:\n     *   Whether the property must be numeric or parse as a numeric and should be\n     *   removed when set to a falsey value.\n     * hasPositiveNumericValue:\n     *   Whether the property must be positive numeric or parse as a positive\n     *   numeric and should be removed when set to a falsey value.\n     * hasOverloadedBooleanValue:\n     *   Whether the property can be used as a flag as well as with a value.\n     *   Removed when strictly equal to false; present without a value when\n     *   strictly equal to true; present with a value otherwise.\n     */\n\n    var properties = {};\n    /**\n     * Checks whether a property name is a writeable attribute.\n     * @method\n     */\n\n    function shouldSetAttribute(name, value) {\n      if (isReservedProp(name)) {\n        return false;\n      }\n\n      if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {\n        return false;\n      }\n\n      if (value === null) {\n        return true;\n      }\n\n      switch (typeof value) {\n        case 'boolean':\n          return shouldAttributeAcceptBooleanValue(name);\n\n        case 'undefined':\n        case 'number':\n        case 'string':\n        case 'object':\n          return true;\n\n        default:\n          // function, symbol\n          return false;\n      }\n    }\n\n    function getPropertyInfo(name) {\n      return properties.hasOwnProperty(name) ? properties[name] : null;\n    }\n\n    function shouldAttributeAcceptBooleanValue(name) {\n      if (isReservedProp(name)) {\n        return true;\n      }\n\n      var propertyInfo = getPropertyInfo(name);\n\n      if (propertyInfo) {\n        return propertyInfo.hasBooleanValue || propertyInfo.hasStringBooleanValue || propertyInfo.hasOverloadedBooleanValue;\n      }\n\n      var prefix = name.toLowerCase().slice(0, 5);\n      return prefix === 'data-' || prefix === 'aria-';\n    }\n    /**\n     * Checks to see if a property name is within the list of properties\n     * reserved for internal React operations. These properties should\n     * not be set on an HTML element.\n     *\n     * @private\n     * @param {string} name\n     * @return {boolean} If the name is within reserved props\n     */\n\n\n    function isReservedProp(name) {\n      return RESERVED_PROPS.hasOwnProperty(name);\n    }\n\n    var injection = DOMPropertyInjection;\n    var MUST_USE_PROPERTY = injection.MUST_USE_PROPERTY;\n    var HAS_BOOLEAN_VALUE = injection.HAS_BOOLEAN_VALUE;\n    var HAS_NUMERIC_VALUE = injection.HAS_NUMERIC_VALUE;\n    var HAS_POSITIVE_NUMERIC_VALUE = injection.HAS_POSITIVE_NUMERIC_VALUE;\n    var HAS_OVERLOADED_BOOLEAN_VALUE = injection.HAS_OVERLOADED_BOOLEAN_VALUE;\n    var HAS_STRING_BOOLEAN_VALUE = injection.HAS_STRING_BOOLEAN_VALUE;\n    var HTMLDOMPropertyConfig = {\n      // When adding attributes to this list, be sure to also add them to\n      // the `possibleStandardNames` module to ensure casing and incorrect\n      // name warnings.\n      Properties: {\n        allowFullScreen: HAS_BOOLEAN_VALUE,\n        // specifies target context for links with `preload` type\n        async: HAS_BOOLEAN_VALUE,\n        // Note: there is a special case that prevents it from being written to the DOM\n        // on the client side because the browsers are inconsistent. Instead we call focus().\n        autoFocus: HAS_BOOLEAN_VALUE,\n        autoPlay: HAS_BOOLEAN_VALUE,\n        capture: HAS_OVERLOADED_BOOLEAN_VALUE,\n        checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n        cols: HAS_POSITIVE_NUMERIC_VALUE,\n        contentEditable: HAS_STRING_BOOLEAN_VALUE,\n        controls: HAS_BOOLEAN_VALUE,\n        'default': HAS_BOOLEAN_VALUE,\n        defer: HAS_BOOLEAN_VALUE,\n        disabled: HAS_BOOLEAN_VALUE,\n        download: HAS_OVERLOADED_BOOLEAN_VALUE,\n        draggable: HAS_STRING_BOOLEAN_VALUE,\n        formNoValidate: HAS_BOOLEAN_VALUE,\n        hidden: HAS_BOOLEAN_VALUE,\n        loop: HAS_BOOLEAN_VALUE,\n        // Caution; `option.selected` is not updated if `select.multiple` is\n        // disabled with `removeAttribute`.\n        multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n        muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n        noValidate: HAS_BOOLEAN_VALUE,\n        open: HAS_BOOLEAN_VALUE,\n        playsInline: HAS_BOOLEAN_VALUE,\n        readOnly: HAS_BOOLEAN_VALUE,\n        required: HAS_BOOLEAN_VALUE,\n        reversed: HAS_BOOLEAN_VALUE,\n        rows: HAS_POSITIVE_NUMERIC_VALUE,\n        rowSpan: HAS_NUMERIC_VALUE,\n        scoped: HAS_BOOLEAN_VALUE,\n        seamless: HAS_BOOLEAN_VALUE,\n        selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n        size: HAS_POSITIVE_NUMERIC_VALUE,\n        start: HAS_NUMERIC_VALUE,\n        // support for projecting regular DOM Elements via V1 named slots ( shadow dom )\n        span: HAS_POSITIVE_NUMERIC_VALUE,\n        spellCheck: HAS_STRING_BOOLEAN_VALUE,\n        // Style must be explicitly set in the attribute list. React components\n        // expect a style object\n        style: 0,\n        // Keep it in the whitelist because it is case-sensitive for SVG.\n        tabIndex: 0,\n        // itemScope is for for Microdata support.\n        // See http://schema.org/docs/gs.html\n        itemScope: HAS_BOOLEAN_VALUE,\n        // These attributes must stay in the white-list because they have\n        // different attribute names (see DOMAttributeNames below)\n        acceptCharset: 0,\n        className: 0,\n        htmlFor: 0,\n        httpEquiv: 0,\n        // Attributes with mutation methods must be specified in the whitelist\n        // Set the string boolean flag to allow the behavior\n        value: HAS_STRING_BOOLEAN_VALUE\n      },\n      DOMAttributeNames: {\n        acceptCharset: 'accept-charset',\n        className: 'class',\n        htmlFor: 'for',\n        httpEquiv: 'http-equiv'\n      },\n      DOMMutationMethods: {\n        value: function (node, value) {\n          if (value == null) {\n            return node.removeAttribute('value');\n          } // Number inputs get special treatment due to some edge cases in\n          // Chrome. Let everything else assign the value attribute as normal.\n          // https://github.com/facebook/react/issues/7253#issuecomment-236074326\n\n\n          if (node.type !== 'number' || node.hasAttribute('value') === false) {\n            node.setAttribute('value', '' + value);\n          } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {\n            // Don't assign an attribute if validation reports bad\n            // input. Chrome will clear the value. Additionally, don't\n            // operate on inputs that have focus, otherwise Chrome might\n            // strip off trailing decimal places and cause the user's\n            // cursor position to jump to the beginning of the input.\n            //\n            // In ReactDOMInput, we have an onBlur event that will trigger\n            // this function again when focus is lost.\n            node.setAttribute('value', '' + value);\n          }\n        }\n      }\n    };\n    var HAS_STRING_BOOLEAN_VALUE$1 = injection.HAS_STRING_BOOLEAN_VALUE;\n    var NS = {\n      xlink: 'http://www.w3.org/1999/xlink',\n      xml: 'http://www.w3.org/XML/1998/namespace'\n    };\n    /**\n     * This is a list of all SVG attributes that need special casing,\n     * namespacing, or boolean value assignment.\n     *\n     * When adding attributes to this list, be sure to also add them to\n     * the `possibleStandardNames` module to ensure casing and incorrect\n     * name warnings.\n     *\n     * SVG Attributes List:\n     * https://www.w3.org/TR/SVG/attindex.html\n     * SMIL Spec:\n     * https://www.w3.org/TR/smil\n     */\n\n    var ATTRS = ['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'x-height', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xmlns:xlink', 'xml:lang', 'xml:space'];\n    var SVGDOMPropertyConfig = {\n      Properties: {\n        autoReverse: HAS_STRING_BOOLEAN_VALUE$1,\n        externalResourcesRequired: HAS_STRING_BOOLEAN_VALUE$1,\n        preserveAlpha: HAS_STRING_BOOLEAN_VALUE$1\n      },\n      DOMAttributeNames: {\n        autoReverse: 'autoReverse',\n        externalResourcesRequired: 'externalResourcesRequired',\n        preserveAlpha: 'preserveAlpha'\n      },\n      DOMAttributeNamespaces: {\n        xlinkActuate: NS.xlink,\n        xlinkArcrole: NS.xlink,\n        xlinkHref: NS.xlink,\n        xlinkRole: NS.xlink,\n        xlinkShow: NS.xlink,\n        xlinkTitle: NS.xlink,\n        xlinkType: NS.xlink,\n        xmlBase: NS.xml,\n        xmlLang: NS.xml,\n        xmlSpace: NS.xml\n      }\n    };\n    var CAMELIZE = /[\\-\\:]([a-z])/g;\n\n    var capitalize = function (token) {\n      return token[1].toUpperCase();\n    };\n\n    ATTRS.forEach(function (original) {\n      var reactName = original.replace(CAMELIZE, capitalize);\n      SVGDOMPropertyConfig.Properties[reactName] = 0;\n      SVGDOMPropertyConfig.DOMAttributeNames[reactName] = original;\n    });\n    injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);\n    injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);\n    var ReactErrorUtils = {\n      // Used by Fiber to simulate a try-catch.\n      _caughtError: null,\n      _hasCaughtError: false,\n      // Used by event system to capture/rethrow the first error.\n      _rethrowError: null,\n      _hasRethrowError: false,\n      injection: {\n        injectErrorUtils: function (injectedErrorUtils) {\n          !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;\n          invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;\n        }\n      },\n\n      /**\n       * Call a function while guarding against errors that happens within it.\n       * Returns an error if it throws, otherwise null.\n       *\n       * In production, this is implemented using a try-catch. The reason we don't\n       * use a try-catch directly is so that we can swap out a different\n       * implementation in DEV mode.\n       *\n       * @param {String} name of the guard to use for logging or debugging\n       * @param {Function} func The function to invoke\n       * @param {*} context The context to use when calling the function\n       * @param {...*} args Arguments for function\n       */\n      invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {\n        invokeGuardedCallback.apply(ReactErrorUtils, arguments);\n      },\n\n      /**\n       * Same as invokeGuardedCallback, but instead of returning an error, it stores\n       * it in a global so it can be rethrown by `rethrowCaughtError` later.\n       * TODO: See if _caughtError and _rethrowError can be unified.\n       *\n       * @param {String} name of the guard to use for logging or debugging\n       * @param {Function} func The function to invoke\n       * @param {*} context The context to use when calling the function\n       * @param {...*} args Arguments for function\n       */\n      invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {\n        ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n\n        if (ReactErrorUtils.hasCaughtError()) {\n          var error = ReactErrorUtils.clearCaughtError();\n\n          if (!ReactErrorUtils._hasRethrowError) {\n            ReactErrorUtils._hasRethrowError = true;\n            ReactErrorUtils._rethrowError = error;\n          }\n        }\n      },\n\n      /**\n       * During execution of guarded functions we will capture the first error which\n       * we will rethrow to be handled by the top level error handler.\n       */\n      rethrowCaughtError: function () {\n        return rethrowCaughtError.apply(ReactErrorUtils, arguments);\n      },\n      hasCaughtError: function () {\n        return ReactErrorUtils._hasCaughtError;\n      },\n      clearCaughtError: function () {\n        if (ReactErrorUtils._hasCaughtError) {\n          var error = ReactErrorUtils._caughtError;\n          ReactErrorUtils._caughtError = null;\n          ReactErrorUtils._hasCaughtError = false;\n          return error;\n        } else {\n          invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n    };\n\n    var invokeGuardedCallback = function (name, func, context, a, b, c, d, e, f) {\n      ReactErrorUtils._hasCaughtError = false;\n      ReactErrorUtils._caughtError = null;\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n      try {\n        func.apply(context, funcArgs);\n      } catch (error) {\n        ReactErrorUtils._caughtError = error;\n        ReactErrorUtils._hasCaughtError = true;\n      }\n    };\n\n    {\n      // In DEV mode, we swap out invokeGuardedCallback for a special version\n      // that plays more nicely with the browser's DevTools. The idea is to preserve\n      // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n      // functions in invokeGuardedCallback, and the production version of\n      // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n      // like caught exceptions, and the DevTools won't pause unless the developer\n      // takes the extra step of enabling pause on caught exceptions. This is\n      // untintuitive, though, because even though React has caught the error, from\n      // the developer's perspective, the error is uncaught.\n      //\n      // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n      // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n      // DOM node, and call the user-provided callback from inside an event handler\n      // for that fake event. If the callback throws, the error is \"captured\" using\n      // a global event handler. But because the error happens in a different\n      // event loop context, it does not interrupt the normal program flow.\n      // Effectively, this gives us try-catch behavior without actually using\n      // try-catch. Neat!\n      // Check that the browser supports the APIs we need to implement our special\n      // DEV version of invokeGuardedCallback\n      if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n        var fakeNode = document.createElement('react');\n\n        var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {\n          // Keeps track of whether the user-provided callback threw an error. We\n          // set this to true at the beginning, then set it to false right after\n          // calling the function. If the function errors, `didError` will never be\n          // set to false. This strategy works even if the browser is flaky and\n          // fails to call our global error handler, because it doesn't rely on\n          // the error event at all.\n          var didError = true; // Create an event handler for our fake event. We will synchronously\n          // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n          // call the user-provided callback.\n\n          var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n          function callCallback() {\n            // We immediately remove the callback from event listeners so that\n            // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n            // nested call would trigger the fake event handlers of any call higher\n            // in the stack.\n            fakeNode.removeEventListener(evtType, callCallback, false);\n            func.apply(context, funcArgs);\n            didError = false;\n          } // Create a global error event handler. We use this to capture the value\n          // that was thrown. It's possible that this error handler will fire more\n          // than once; for example, if non-React code also calls `dispatchEvent`\n          // and a handler for that event throws. We should be resilient to most of\n          // those cases. Even if our error event handler fires more than once, the\n          // last error event is always used. If the callback actually does error,\n          // we know that the last error event is the correct one, because it's not\n          // possible for anything else to have happened in between our callback\n          // erroring and the code that follows the `dispatchEvent` call below. If\n          // the callback doesn't error, but the error event was fired, we know to\n          // ignore it because `didError` will be false, as described above.\n\n\n          var error = void 0; // Use this to track whether the error event is ever called.\n\n          var didSetError = false;\n          var isCrossOriginError = false;\n\n          function onError(event) {\n            error = event.error;\n            didSetError = true;\n\n            if (error === null && event.colno === 0 && event.lineno === 0) {\n              isCrossOriginError = true;\n            }\n          } // Create a fake event type.\n\n\n          var evtType = 'react-' + (name ? name : 'invokeguardedcallback'); // Attach our event handlers\n\n          window.addEventListener('error', onError);\n          fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function\n          // errors, it will trigger our global error handler.\n\n          var evt = document.createEvent('Event');\n          evt.initEvent(evtType, false, false);\n          fakeNode.dispatchEvent(evt);\n\n          if (didError) {\n            if (!didSetError) {\n              // The callback errored, but the error event never fired.\n              error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n            } else if (isCrossOriginError) {\n              error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');\n            }\n\n            ReactErrorUtils._hasCaughtError = true;\n            ReactErrorUtils._caughtError = error;\n          } else {\n            ReactErrorUtils._hasCaughtError = false;\n            ReactErrorUtils._caughtError = null;\n          } // Remove our event listeners\n\n\n          window.removeEventListener('error', onError);\n        };\n\n        invokeGuardedCallback = invokeGuardedCallbackDev;\n      }\n    }\n\n    var rethrowCaughtError = function () {\n      if (ReactErrorUtils._hasRethrowError) {\n        var error = ReactErrorUtils._rethrowError;\n        ReactErrorUtils._rethrowError = null;\n        ReactErrorUtils._hasRethrowError = false;\n        throw error;\n      }\n    };\n    /**\n     * Injectable ordering of event plugins.\n     */\n\n\n    var eventPluginOrder = null;\n    /**\n     * Injectable mapping from names to event plugin modules.\n     */\n\n    var namesToPlugins = {};\n    /**\n     * Recomputes the plugin list using the injected plugins and plugin ordering.\n     *\n     * @private\n     */\n\n    function recomputePluginOrdering() {\n      if (!eventPluginOrder) {\n        // Wait until an `eventPluginOrder` is injected.\n        return;\n      }\n\n      for (var pluginName in namesToPlugins) {\n        var pluginModule = namesToPlugins[pluginName];\n        var pluginIndex = eventPluginOrder.indexOf(pluginName);\n        !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;\n\n        if (plugins[pluginIndex]) {\n          continue;\n        }\n\n        !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;\n        plugins[pluginIndex] = pluginModule;\n        var publishedEvents = pluginModule.eventTypes;\n\n        for (var eventName in publishedEvents) {\n          !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;\n        }\n      }\n    }\n    /**\n     * Publishes an event so that it can be dispatched by the supplied plugin.\n     *\n     * @param {object} dispatchConfig Dispatch configuration for the event.\n     * @param {object} PluginModule Plugin publishing the event.\n     * @return {boolean} True if the event was successfully published.\n     * @private\n     */\n\n\n    function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n      !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;\n      eventNameDispatchConfigs[eventName] = dispatchConfig;\n      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n\n      if (phasedRegistrationNames) {\n        for (var phaseName in phasedRegistrationNames) {\n          if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n            var phasedRegistrationName = phasedRegistrationNames[phaseName];\n            publishRegistrationName(phasedRegistrationName, pluginModule, eventName);\n          }\n        }\n\n        return true;\n      } else if (dispatchConfig.registrationName) {\n        publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Publishes a registration name that is used to identify dispatched events.\n     *\n     * @param {string} registrationName Registration name to add.\n     * @param {object} PluginModule Plugin publishing the event.\n     * @private\n     */\n\n\n    function publishRegistrationName(registrationName, pluginModule, eventName) {\n      !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;\n      registrationNameModules[registrationName] = pluginModule;\n      registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;\n      {\n        var lowerCasedName = registrationName.toLowerCase();\n        possibleRegistrationNames[lowerCasedName] = registrationName;\n\n        if (registrationName === 'onDoubleClick') {\n          possibleRegistrationNames.ondblclick = registrationName;\n        }\n      }\n    }\n    /**\n     * Registers plugins so that they can extract and dispatch events.\n     *\n     * @see {EventPluginHub}\n     */\n\n    /**\n     * Ordered list of injected plugins.\n     */\n\n\n    var plugins = [];\n    /**\n     * Mapping from event name to dispatch config\n     */\n\n    var eventNameDispatchConfigs = {};\n    /**\n     * Mapping from registration name to plugin module\n     */\n\n    var registrationNameModules = {};\n    /**\n     * Mapping from registration name to event name\n     */\n\n    var registrationNameDependencies = {};\n    /**\n     * Mapping from lowercase registration names to the properly cased version,\n     * used to warn in the case of missing event handlers. Available\n     * only in true.\n     * @type {Object}\n     */\n\n    var possibleRegistrationNames = {}; // Trust the developer to only use possibleRegistrationNames in true\n\n    /**\n     * Injects an ordering of plugins (by plugin name). This allows the ordering\n     * to be decoupled from injection of the actual plugins so that ordering is\n     * always deterministic regardless of packaging, on-the-fly injection, etc.\n     *\n     * @param {array} InjectedEventPluginOrder\n     * @internal\n     * @see {EventPluginHub.injection.injectEventPluginOrder}\n     */\n\n    function injectEventPluginOrder(injectedEventPluginOrder) {\n      !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0; // Clone the ordering so it cannot be dynamically mutated.\n\n      eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n      recomputePluginOrdering();\n    }\n    /**\n     * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n     * in the ordering injected by `injectEventPluginOrder`.\n     *\n     * Plugins can be injected as part of page initialization or on-the-fly.\n     *\n     * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n     * @internal\n     * @see {EventPluginHub.injection.injectEventPluginsByName}\n     */\n\n\n    function injectEventPluginsByName(injectedNamesToPlugins) {\n      var isOrderingDirty = false;\n\n      for (var pluginName in injectedNamesToPlugins) {\n        if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n          continue;\n        }\n\n        var pluginModule = injectedNamesToPlugins[pluginName];\n\n        if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {\n          !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;\n          namesToPlugins[pluginName] = pluginModule;\n          isOrderingDirty = true;\n        }\n      }\n\n      if (isOrderingDirty) {\n        recomputePluginOrdering();\n      }\n    }\n\n    var EventPluginRegistry = Object.freeze({\n      plugins: plugins,\n      eventNameDispatchConfigs: eventNameDispatchConfigs,\n      registrationNameModules: registrationNameModules,\n      registrationNameDependencies: registrationNameDependencies,\n      possibleRegistrationNames: possibleRegistrationNames,\n      injectEventPluginOrder: injectEventPluginOrder,\n      injectEventPluginsByName: injectEventPluginsByName\n    });\n    var getFiberCurrentPropsFromNode = null;\n    var getInstanceFromNode = null;\n    var getNodeFromInstance = null;\n    var injection$2 = {\n      injectComponentTree: function (Injected) {\n        getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;\n        getInstanceFromNode = Injected.getInstanceFromNode;\n        getNodeFromInstance = Injected.getNodeFromInstance;\n        {\n          warning(getNodeFromInstance && getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');\n        }\n      }\n    };\n    var validateEventDispatches;\n    {\n      validateEventDispatches = function (event) {\n        var dispatchListeners = event._dispatchListeners;\n        var dispatchInstances = event._dispatchInstances;\n        var listenersIsArr = Array.isArray(dispatchListeners);\n        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n        var instancesIsArr = Array.isArray(dispatchInstances);\n        var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n        warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');\n      };\n    }\n    /**\n     * Dispatch the event to the listener.\n     * @param {SyntheticEvent} event SyntheticEvent to handle\n     * @param {boolean} simulated If the event is simulated (changes exn behavior)\n     * @param {function} listener Application-level callback\n     * @param {*} inst Internal component instance\n     */\n\n    function executeDispatch(event, simulated, listener, inst) {\n      var type = event.type || 'unknown-event';\n      event.currentTarget = getNodeFromInstance(inst);\n      ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n      event.currentTarget = null;\n    }\n    /**\n     * Standard/simple iteration through an event's collected dispatches.\n     */\n\n\n    function executeDispatchesInOrder(event, simulated) {\n      var dispatchListeners = event._dispatchListeners;\n      var dispatchInstances = event._dispatchInstances;\n      {\n        validateEventDispatches(event);\n      }\n\n      if (Array.isArray(dispatchListeners)) {\n        for (var i = 0; i < dispatchListeners.length; i++) {\n          if (event.isPropagationStopped()) {\n            break;\n          } // Listeners and Instances are two parallel arrays that are always in sync.\n\n\n          executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);\n        }\n      } else if (dispatchListeners) {\n        executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n      }\n\n      event._dispatchListeners = null;\n      event._dispatchInstances = null;\n    }\n    /**\n     * @see executeDispatchesInOrderStopAtTrueImpl\n     */\n\n    /**\n     * Execution of a \"direct\" dispatch - there must be at most one dispatch\n     * accumulated on the event or it is considered an error. It doesn't really make\n     * sense for an event with multiple dispatches (bubbled) to keep track of the\n     * return values at each dispatch execution, but it does tend to make sense when\n     * dealing with \"direct\" dispatches.\n     *\n     * @return {*} The return value of executing the single dispatch.\n     */\n\n    /**\n     * @param {SyntheticEvent} event\n     * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n     */\n\n    /**\n     * Accumulates items that must not be null or undefined into the first one. This\n     * is used to conserve memory by avoiding array allocations, and thus sacrifices\n     * API cleanness. Since `current` can be null before being passed in and not\n     * null after this function, make sure to assign it back to `current`:\n     *\n     * `a = accumulateInto(a, b);`\n     *\n     * This API should be sparingly used. Try `accumulate` for something cleaner.\n     *\n     * @return {*|array<*>} An accumulation of items.\n     */\n\n\n    function accumulateInto(current, next) {\n      !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;\n\n      if (current == null) {\n        return next;\n      } // Both are not empty. Warning: Never call x.concat(y) when you are not\n      // certain that x is an Array (x could be a string with concat method).\n\n\n      if (Array.isArray(current)) {\n        if (Array.isArray(next)) {\n          current.push.apply(current, next);\n          return current;\n        }\n\n        current.push(next);\n        return current;\n      }\n\n      if (Array.isArray(next)) {\n        // A bit too dangerous to mutate `next`.\n        return [current].concat(next);\n      }\n\n      return [current, next];\n    }\n    /**\n     * @param {array} arr an \"accumulation\" of items which is either an Array or\n     * a single item. Useful when paired with the `accumulate` module. This is a\n     * simple utility that allows us to reason about a collection of items, but\n     * handling the case when there is exactly one item (and we do not need to\n     * allocate an array).\n     * @param {function} cb Callback invoked with each element or a collection.\n     * @param {?} [scope] Scope used as `this` in a callback.\n     */\n\n\n    function forEachAccumulated(arr, cb, scope) {\n      if (Array.isArray(arr)) {\n        arr.forEach(cb, scope);\n      } else if (arr) {\n        cb.call(scope, arr);\n      }\n    }\n    /**\n     * Internal queue of events that have accumulated their dispatches and are\n     * waiting to have their dispatches executed.\n     */\n\n\n    var eventQueue = null;\n    /**\n     * Dispatches an event and releases it back into the pool, unless persistent.\n     *\n     * @param {?object} event Synthetic event to be dispatched.\n     * @param {boolean} simulated If the event is simulated (changes exn behavior)\n     * @private\n     */\n\n    var executeDispatchesAndRelease = function (event, simulated) {\n      if (event) {\n        executeDispatchesInOrder(event, simulated);\n\n        if (!event.isPersistent()) {\n          event.constructor.release(event);\n        }\n      }\n    };\n\n    var executeDispatchesAndReleaseSimulated = function (e) {\n      return executeDispatchesAndRelease(e, true);\n    };\n\n    var executeDispatchesAndReleaseTopLevel = function (e) {\n      return executeDispatchesAndRelease(e, false);\n    };\n\n    function isInteractive(tag) {\n      return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n    }\n\n    function shouldPreventMouseEvent(name, type, props) {\n      switch (name) {\n        case 'onClick':\n        case 'onClickCapture':\n        case 'onDoubleClick':\n        case 'onDoubleClickCapture':\n        case 'onMouseDown':\n        case 'onMouseDownCapture':\n        case 'onMouseMove':\n        case 'onMouseMoveCapture':\n        case 'onMouseUp':\n        case 'onMouseUpCapture':\n          return !!(props.disabled && isInteractive(type));\n\n        default:\n          return false;\n      }\n    }\n    /**\n     * This is a unified interface for event plugins to be installed and configured.\n     *\n     * Event plugins can implement the following properties:\n     *\n     *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n     *     Required. When a top-level event is fired, this method is expected to\n     *     extract synthetic events that will in turn be queued and dispatched.\n     *\n     *   `eventTypes` {object}\n     *     Optional, plugins that fire events must publish a mapping of registration\n     *     names that are used to register listeners. Values of this mapping must\n     *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n     *\n     *   `executeDispatch` {function(object, function, string)}\n     *     Optional, allows plugins to override how an event gets dispatched. By\n     *     default, the listener is simply invoked.\n     *\n     * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n     *\n     * @public\n     */\n\n    /**\n     * Methods for injecting dependencies.\n     */\n\n\n    var injection$1 = {\n      /**\n       * @param {array} InjectedEventPluginOrder\n       * @public\n       */\n      injectEventPluginOrder: injectEventPluginOrder,\n\n      /**\n       * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n       */\n      injectEventPluginsByName: injectEventPluginsByName\n    };\n    /**\n     * @param {object} inst The instance, which is the source of events.\n     * @param {string} registrationName Name of listener (e.g. `onClick`).\n     * @return {?function} The stored callback.\n     */\n\n    function getListener(inst, registrationName) {\n      var listener; // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n      // live here; needs to be moved to a better place soon\n\n      var stateNode = inst.stateNode;\n\n      if (!stateNode) {\n        // Work in progress (ex: onload events in incremental mode).\n        return null;\n      }\n\n      var props = getFiberCurrentPropsFromNode(stateNode);\n\n      if (!props) {\n        // Work in progress.\n        return null;\n      }\n\n      listener = props[registrationName];\n\n      if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n        return null;\n      }\n\n      !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;\n      return listener;\n    }\n    /**\n     * Allows registered plugins an opportunity to extract events from top-level\n     * native browser events.\n     *\n     * @return {*} An accumulation of synthetic events.\n     * @internal\n     */\n\n\n    function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n      var events;\n\n      for (var i = 0; i < plugins.length; i++) {\n        // Not every plugin in the ordering may be loaded at runtime.\n        var possiblePlugin = plugins[i];\n\n        if (possiblePlugin) {\n          var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n\n          if (extractedEvents) {\n            events = accumulateInto(events, extractedEvents);\n          }\n        }\n      }\n\n      return events;\n    }\n    /**\n     * Enqueues a synthetic event that should be dispatched when\n     * `processEventQueue` is invoked.\n     *\n     * @param {*} events An accumulation of synthetic events.\n     * @internal\n     */\n\n\n    function enqueueEvents(events) {\n      if (events) {\n        eventQueue = accumulateInto(eventQueue, events);\n      }\n    }\n    /**\n     * Dispatches all synthetic events on the event queue.\n     *\n     * @internal\n     */\n\n\n    function processEventQueue(simulated) {\n      // Set `eventQueue` to null before processing it so that we can tell if more\n      // events get enqueued while processing.\n      var processingEventQueue = eventQueue;\n      eventQueue = null;\n\n      if (simulated) {\n        forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);\n      } else {\n        forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);\n      }\n\n      !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0; // This would be a good time to rethrow if any of the event handlers threw.\n\n      ReactErrorUtils.rethrowCaughtError();\n    }\n\n    var EventPluginHub = Object.freeze({\n      injection: injection$1,\n      getListener: getListener,\n      extractEvents: extractEvents,\n      enqueueEvents: enqueueEvents,\n      processEventQueue: processEventQueue\n    });\n    var IndeterminateComponent = 0; // Before we know whether it is functional or class\n\n    var FunctionalComponent = 1;\n    var ClassComponent = 2;\n    var HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n\n    var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n\n    var HostComponent = 5;\n    var HostText = 6;\n    var CallComponent = 7;\n    var CallHandlerPhase = 8;\n    var ReturnComponent = 9;\n    var Fragment = 10;\n    var randomKey = Math.random().toString(36).slice(2);\n    var internalInstanceKey = '__reactInternalInstance$' + randomKey;\n    var internalEventHandlersKey = '__reactEventHandlers$' + randomKey;\n\n    function precacheFiberNode$1(hostInst, node) {\n      node[internalInstanceKey] = hostInst;\n    }\n    /**\n     * Given a DOM node, return the closest ReactDOMComponent or\n     * ReactDOMTextComponent instance ancestor.\n     */\n\n\n    function getClosestInstanceFromNode(node) {\n      if (node[internalInstanceKey]) {\n        return node[internalInstanceKey];\n      } // Walk up the tree until we find an ancestor whose instance we have cached.\n\n\n      var parents = [];\n\n      while (!node[internalInstanceKey]) {\n        parents.push(node);\n\n        if (node.parentNode) {\n          node = node.parentNode;\n        } else {\n          // Top of the tree. This node must not be part of a React tree (or is\n          // unmounted, potentially).\n          return null;\n        }\n      }\n\n      var closest = void 0;\n      var inst = node[internalInstanceKey];\n\n      if (inst.tag === HostComponent || inst.tag === HostText) {\n        // In Fiber, this will always be the deepest root.\n        return inst;\n      }\n\n      for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {\n        closest = inst;\n      }\n\n      return closest;\n    }\n    /**\n     * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n     * instance, or null if the node was not rendered by this React.\n     */\n\n\n    function getInstanceFromNode$1(node) {\n      var inst = node[internalInstanceKey];\n\n      if (inst) {\n        if (inst.tag === HostComponent || inst.tag === HostText) {\n          return inst;\n        } else {\n          return null;\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n     * DOM node.\n     */\n\n\n    function getNodeFromInstance$1(inst) {\n      if (inst.tag === HostComponent || inst.tag === HostText) {\n        // In Fiber this, is just the state node right now. We assume it will be\n        // a host component or host text.\n        return inst.stateNode;\n      } // Without this first invariant, passing a non-DOM-component triggers the next\n      // invariant for a missing parent, which is super confusing.\n\n\n      invariant(false, 'getNodeFromInstance: Invalid argument.');\n    }\n\n    function getFiberCurrentPropsFromNode$1(node) {\n      return node[internalEventHandlersKey] || null;\n    }\n\n    function updateFiberProps$1(node, props) {\n      node[internalEventHandlersKey] = props;\n    }\n\n    var ReactDOMComponentTree = Object.freeze({\n      precacheFiberNode: precacheFiberNode$1,\n      getClosestInstanceFromNode: getClosestInstanceFromNode,\n      getInstanceFromNode: getInstanceFromNode$1,\n      getNodeFromInstance: getNodeFromInstance$1,\n      getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,\n      updateFiberProps: updateFiberProps$1\n    });\n\n    function getParent(inst) {\n      do {\n        inst = inst['return']; // TODO: If this is a HostRoot we might want to bail out.\n        // That is depending on if we want nested subtrees (layers) to bubble\n        // events to their parent. We could also go through parentNode on the\n        // host node but that wouldn't work for React Native and doesn't let us\n        // do the portal feature.\n      } while (inst && inst.tag !== HostComponent);\n\n      if (inst) {\n        return inst;\n      }\n\n      return null;\n    }\n    /**\n     * Return the lowest common ancestor of A and B, or null if they are in\n     * different trees.\n     */\n\n\n    function getLowestCommonAncestor(instA, instB) {\n      var depthA = 0;\n\n      for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n        depthA++;\n      }\n\n      var depthB = 0;\n\n      for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n        depthB++;\n      } // If A is deeper, crawl up.\n\n\n      while (depthA - depthB > 0) {\n        instA = getParent(instA);\n        depthA--;\n      } // If B is deeper, crawl up.\n\n\n      while (depthB - depthA > 0) {\n        instB = getParent(instB);\n        depthB--;\n      } // Walk in lockstep until we find a match.\n\n\n      var depth = depthA;\n\n      while (depth--) {\n        if (instA === instB || instA === instB.alternate) {\n          return instA;\n        }\n\n        instA = getParent(instA);\n        instB = getParent(instB);\n      }\n\n      return null;\n    }\n    /**\n     * Return if A is an ancestor of B.\n     */\n\n    /**\n     * Return the parent instance of the passed-in instance.\n     */\n\n\n    function getParentInstance(inst) {\n      return getParent(inst);\n    }\n    /**\n     * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n     */\n\n\n    function traverseTwoPhase(inst, fn, arg) {\n      var path = [];\n\n      while (inst) {\n        path.push(inst);\n        inst = getParent(inst);\n      }\n\n      var i;\n\n      for (i = path.length; i-- > 0;) {\n        fn(path[i], 'captured', arg);\n      }\n\n      for (i = 0; i < path.length; i++) {\n        fn(path[i], 'bubbled', arg);\n      }\n    }\n    /**\n     * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n     * should would receive a `mouseEnter` or `mouseLeave` event.\n     *\n     * Does not invoke the callback on the nearest common ancestor because nothing\n     * \"entered\" or \"left\" that element.\n     */\n\n\n    function traverseEnterLeave(from, to, fn, argFrom, argTo) {\n      var common = from && to ? getLowestCommonAncestor(from, to) : null;\n      var pathFrom = [];\n\n      while (true) {\n        if (!from) {\n          break;\n        }\n\n        if (from === common) {\n          break;\n        }\n\n        var alternate = from.alternate;\n\n        if (alternate !== null && alternate === common) {\n          break;\n        }\n\n        pathFrom.push(from);\n        from = getParent(from);\n      }\n\n      var pathTo = [];\n\n      while (true) {\n        if (!to) {\n          break;\n        }\n\n        if (to === common) {\n          break;\n        }\n\n        var _alternate = to.alternate;\n\n        if (_alternate !== null && _alternate === common) {\n          break;\n        }\n\n        pathTo.push(to);\n        to = getParent(to);\n      }\n\n      for (var i = 0; i < pathFrom.length; i++) {\n        fn(pathFrom[i], 'bubbled', argFrom);\n      }\n\n      for (var _i = pathTo.length; _i-- > 0;) {\n        fn(pathTo[_i], 'captured', argTo);\n      }\n    }\n    /**\n     * Some event types have a notion of different registration names for different\n     * \"phases\" of propagation. This finds listeners by a given phase.\n     */\n\n\n    function listenerAtPhase(inst, event, propagationPhase) {\n      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n      return getListener(inst, registrationName);\n    }\n    /**\n     * A small set of propagation patterns, each of which will accept a small amount\n     * of information, and generate a set of \"dispatch ready event objects\" - which\n     * are sets of events that have already been annotated with a set of dispatched\n     * listener functions/ids. The API is designed this way to discourage these\n     * propagation strategies from actually executing the dispatches, since we\n     * always want to collect the entire set of dispatches before executing even a\n     * single one.\n     */\n\n    /**\n     * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n     * here, allows us to not have to bind or create functions for each event.\n     * Mutating the event's members allows us to not have to create a wrapping\n     * \"dispatch\" object that pairs the event with the listener.\n     */\n\n\n    function accumulateDirectionalDispatches(inst, phase, event) {\n      {\n        warning(inst, 'Dispatching inst must not be null');\n      }\n      var listener = listenerAtPhase(inst, event, phase);\n\n      if (listener) {\n        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n      }\n    }\n    /**\n     * Collect dispatches (must be entirely collected before dispatching - see unit\n     * tests). Lazily allocate the array to conserve memory.  We must loop through\n     * each event and perform the traversal for each one. We cannot perform a\n     * single traversal for the entire collection of events because each event may\n     * have a different target.\n     */\n\n\n    function accumulateTwoPhaseDispatchesSingle(event) {\n      if (event && event.dispatchConfig.phasedRegistrationNames) {\n        traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n      }\n    }\n    /**\n     * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n     */\n\n\n    function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n      if (event && event.dispatchConfig.phasedRegistrationNames) {\n        var targetInst = event._targetInst;\n        var parentInst = targetInst ? getParentInstance(targetInst) : null;\n        traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n      }\n    }\n    /**\n     * Accumulates without regard to direction, does not look for phased\n     * registration names. Same as `accumulateDirectDispatchesSingle` but without\n     * requiring that the `dispatchMarker` be the same as the dispatched ID.\n     */\n\n\n    function accumulateDispatches(inst, ignoredDirection, event) {\n      if (inst && event && event.dispatchConfig.registrationName) {\n        var registrationName = event.dispatchConfig.registrationName;\n        var listener = getListener(inst, registrationName);\n\n        if (listener) {\n          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n          event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n        }\n      }\n    }\n    /**\n     * Accumulates dispatches on an `SyntheticEvent`, but only for the\n     * `dispatchMarker`.\n     * @param {SyntheticEvent} event\n     */\n\n\n    function accumulateDirectDispatchesSingle(event) {\n      if (event && event.dispatchConfig.registrationName) {\n        accumulateDispatches(event._targetInst, null, event);\n      }\n    }\n\n    function accumulateTwoPhaseDispatches(events) {\n      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n    }\n\n    function accumulateTwoPhaseDispatchesSkipTarget(events) {\n      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n    }\n\n    function accumulateEnterLeaveDispatches(leave, enter, from, to) {\n      traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n    }\n\n    function accumulateDirectDispatches(events) {\n      forEachAccumulated(events, accumulateDirectDispatchesSingle);\n    }\n\n    var EventPropagators = Object.freeze({\n      accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n      accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n      accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,\n      accumulateDirectDispatches: accumulateDirectDispatches\n    });\n    var contentKey = null;\n    /**\n     * Gets the key used to access text content on a DOM node.\n     *\n     * @return {?string} Key used to access text content.\n     * @internal\n     */\n\n    function getTextContentAccessor() {\n      if (!contentKey && ExecutionEnvironment.canUseDOM) {\n        // Prefer textContent to innerText because many browsers support both but\n        // SVG <text> elements don't support innerText even when <div> does.\n        contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';\n      }\n\n      return contentKey;\n    }\n    /**\n     * This helper object stores information about text content of a target node,\n     * allowing comparison of content before and after a given event.\n     *\n     * Identify the node where selection currently begins, then observe\n     * both its text content and its current position in the DOM. Since the\n     * browser may natively replace the target node during composition, we can\n     * use its position to find its replacement.\n     *\n     *\n     */\n\n\n    var compositionState = {\n      _root: null,\n      _startText: null,\n      _fallbackText: null\n    };\n\n    function initialize(nativeEventTarget) {\n      compositionState._root = nativeEventTarget;\n      compositionState._startText = getText();\n      return true;\n    }\n\n    function reset() {\n      compositionState._root = null;\n      compositionState._startText = null;\n      compositionState._fallbackText = null;\n    }\n\n    function getData() {\n      if (compositionState._fallbackText) {\n        return compositionState._fallbackText;\n      }\n\n      var start;\n      var startValue = compositionState._startText;\n      var startLength = startValue.length;\n      var end;\n      var endValue = getText();\n      var endLength = endValue.length;\n\n      for (start = 0; start < startLength; start++) {\n        if (startValue[start] !== endValue[start]) {\n          break;\n        }\n      }\n\n      var minEnd = startLength - start;\n\n      for (end = 1; end <= minEnd; end++) {\n        if (startValue[startLength - end] !== endValue[endLength - end]) {\n          break;\n        }\n      }\n\n      var sliceTail = end > 1 ? 1 - end : undefined;\n      compositionState._fallbackText = endValue.slice(start, sliceTail);\n      return compositionState._fallbackText;\n    }\n\n    function getText() {\n      if ('value' in compositionState._root) {\n        return compositionState._root.value;\n      }\n\n      return compositionState._root[getTextContentAccessor()];\n    }\n    /* eslint valid-typeof: 0 */\n\n\n    var didWarnForAddedNewProperty = false;\n    var isProxySupported = typeof Proxy === 'function';\n    var EVENT_POOL_SIZE = 10;\n    var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];\n    /**\n     * @interface Event\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\n     */\n\n    var EventInterface = {\n      type: null,\n      target: null,\n      // currentTarget is set when dispatching; no use in copying it here\n      currentTarget: emptyFunction$1.thatReturnsNull,\n      eventPhase: null,\n      bubbles: null,\n      cancelable: null,\n      timeStamp: function (event) {\n        return event.timeStamp || Date.now();\n      },\n      defaultPrevented: null,\n      isTrusted: null\n    };\n    /**\n     * Synthetic events are dispatched by event plugins, typically in response to a\n     * top-level event delegation handler.\n     *\n     * These systems should generally use pooling to reduce the frequency of garbage\n     * collection. The system should check `isPersistent` to determine whether the\n     * event should be released into the pool after being dispatched. Users that\n     * need a persisted event should invoke `persist`.\n     *\n     * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n     * normalizing browser quirks. Subclasses do not necessarily have to implement a\n     * DOM interface; custom application-specific events can also subclass this.\n     *\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {*} targetInst Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @param {DOMEventTarget} nativeEventTarget Target node.\n     */\n\n    function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n      {\n        // these have a getter/setter for warnings\n        delete this.nativeEvent;\n        delete this.preventDefault;\n        delete this.stopPropagation;\n      }\n      this.dispatchConfig = dispatchConfig;\n      this._targetInst = targetInst;\n      this.nativeEvent = nativeEvent;\n      var Interface = this.constructor.Interface;\n\n      for (var propName in Interface) {\n        if (!Interface.hasOwnProperty(propName)) {\n          continue;\n        }\n\n        {\n          delete this[propName]; // this has a getter/setter for warnings\n        }\n        var normalize = Interface[propName];\n\n        if (normalize) {\n          this[propName] = normalize(nativeEvent);\n        } else {\n          if (propName === 'target') {\n            this.target = nativeEventTarget;\n          } else {\n            this[propName] = nativeEvent[propName];\n          }\n        }\n      }\n\n      var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n\n      if (defaultPrevented) {\n        this.isDefaultPrevented = emptyFunction$1.thatReturnsTrue;\n      } else {\n        this.isDefaultPrevented = emptyFunction$1.thatReturnsFalse;\n      }\n\n      this.isPropagationStopped = emptyFunction$1.thatReturnsFalse;\n      return this;\n    }\n\n    _assign(SyntheticEvent.prototype, {\n      preventDefault: function () {\n        this.defaultPrevented = true;\n        var event = this.nativeEvent;\n\n        if (!event) {\n          return;\n        }\n\n        if (event.preventDefault) {\n          event.preventDefault();\n        } else if (typeof event.returnValue !== 'unknown') {\n          event.returnValue = false;\n        }\n\n        this.isDefaultPrevented = emptyFunction$1.thatReturnsTrue;\n      },\n      stopPropagation: function () {\n        var event = this.nativeEvent;\n\n        if (!event) {\n          return;\n        }\n\n        if (event.stopPropagation) {\n          event.stopPropagation();\n        } else if (typeof event.cancelBubble !== 'unknown') {\n          // The ChangeEventPlugin registers a \"propertychange\" event for\n          // IE. This event does not support bubbling or cancelling, and\n          // any references to cancelBubble throw \"Member not found\".  A\n          // typeof check of \"unknown\" circumvents this issue (and is also\n          // IE specific).\n          event.cancelBubble = true;\n        }\n\n        this.isPropagationStopped = emptyFunction$1.thatReturnsTrue;\n      },\n\n      /**\n       * We release all dispatched `SyntheticEvent`s after each event loop, adding\n       * them back into the pool. This allows a way to hold onto a reference that\n       * won't be added back into the pool.\n       */\n      persist: function () {\n        this.isPersistent = emptyFunction$1.thatReturnsTrue;\n      },\n\n      /**\n       * Checks if this event should be released back into the pool.\n       *\n       * @return {boolean} True if this should not be released, false otherwise.\n       */\n      isPersistent: emptyFunction$1.thatReturnsFalse,\n\n      /**\n       * `PooledClass` looks for `destructor` on each instance it releases.\n       */\n      destructor: function () {\n        var Interface = this.constructor.Interface;\n\n        for (var propName in Interface) {\n          {\n            Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n          }\n        }\n\n        for (var i = 0; i < shouldBeReleasedProperties.length; i++) {\n          this[shouldBeReleasedProperties[i]] = null;\n        }\n\n        {\n          Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n          Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction$1));\n          Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction$1));\n        }\n      }\n    });\n\n    SyntheticEvent.Interface = EventInterface;\n    /**\n     * Helper to reduce boilerplate when creating subclasses.\n     *\n     * @param {function} Class\n     * @param {?object} Interface\n     */\n\n    SyntheticEvent.augmentClass = function (Class, Interface) {\n      var Super = this;\n\n      var E = function () {};\n\n      E.prototype = Super.prototype;\n      var prototype = new E();\n\n      _assign(prototype, Class.prototype);\n\n      Class.prototype = prototype;\n      Class.prototype.constructor = Class;\n      Class.Interface = _assign({}, Super.Interface, Interface);\n      Class.augmentClass = Super.augmentClass;\n      addEventPoolingTo(Class);\n    };\n    /** Proxying after everything set on SyntheticEvent\n     * to resolve Proxy issue on some WebKit browsers\n     * in which some Event properties are set to undefined (GH#10010)\n     */\n\n\n    {\n      if (isProxySupported) {\n        /*eslint-disable no-func-assign */\n        SyntheticEvent = new Proxy(SyntheticEvent, {\n          construct: function (target, args) {\n            return this.apply(target, Object.create(target.prototype), args);\n          },\n          apply: function (constructor, that, args) {\n            return new Proxy(constructor.apply(that, args), {\n              set: function (target, prop, value) {\n                if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {\n                  warning(didWarnForAddedNewProperty || target.isPersistent(), \"This synthetic event is reused for performance reasons. If you're \" + \"seeing this, you're adding a new property in the synthetic event object. \" + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.');\n                  didWarnForAddedNewProperty = true;\n                }\n\n                target[prop] = value;\n                return true;\n              }\n            });\n          }\n        });\n        /*eslint-enable no-func-assign */\n      }\n    }\n    addEventPoolingTo(SyntheticEvent);\n    /**\n     * Helper to nullify syntheticEvent instance properties when destructing\n     *\n     * @param {String} propName\n     * @param {?object} getVal\n     * @return {object} defineProperty object\n     */\n\n    function getPooledWarningPropertyDefinition(propName, getVal) {\n      var isFunction = typeof getVal === 'function';\n      return {\n        configurable: true,\n        set: set,\n        get: get\n      };\n\n      function set(val) {\n        var action = isFunction ? 'setting the method' : 'setting the property';\n        warn(action, 'This is effectively a no-op');\n        return val;\n      }\n\n      function get() {\n        var action = isFunction ? 'accessing the method' : 'accessing the property';\n        var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n        warn(action, result);\n        return getVal;\n      }\n\n      function warn(action, result) {\n        var warningCondition = false;\n        warning(warningCondition, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);\n      }\n    }\n\n    function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n      var EventConstructor = this;\n\n      if (EventConstructor.eventPool.length) {\n        var instance = EventConstructor.eventPool.pop();\n        EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n        return instance;\n      }\n\n      return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n    }\n\n    function releasePooledEvent(event) {\n      var EventConstructor = this;\n      !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;\n      event.destructor();\n\n      if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n        EventConstructor.eventPool.push(event);\n      }\n    }\n\n    function addEventPoolingTo(EventConstructor) {\n      EventConstructor.eventPool = [];\n      EventConstructor.getPooled = getPooledEvent;\n      EventConstructor.release = releasePooledEvent;\n    }\n\n    var SyntheticEvent$1 = SyntheticEvent;\n    /**\n     * @interface Event\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n     */\n\n    var CompositionEventInterface = {\n      data: null\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticEvent}\n     */\n\n    function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticEvent$1.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);\n    /**\n     * @interface Event\n     * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n     *      /#events-inputevents\n     */\n\n    var InputEventInterface = {\n      data: null\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticEvent}\n     */\n\n    function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticEvent$1.augmentClass(SyntheticInputEvent, InputEventInterface);\n    var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\n\n    var START_KEYCODE = 229;\n    var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;\n    var documentMode = null;\n\n    if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {\n      documentMode = document.documentMode;\n    } // Webkit offers a very useful `textInput` event that can be used to\n    // directly represent `beforeInput`. The IE `textinput` event is not as\n    // useful, so we don't use it.\n\n\n    var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto(); // In IE9+, we have access to composition events, but the data supplied\n    // by the native compositionend event may be incorrect. Japanese ideographic\n    // spaces, for instance (\\u3000) are not recorded correctly.\n\n    var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\n    /**\n     * Opera <= 12 includes TextEvent in window, but does not fire\n     * text input events. Rely on keypress instead.\n     */\n\n    function isPresto() {\n      var opera = window.opera;\n      return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;\n    }\n\n    var SPACEBAR_CODE = 32;\n    var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE); // Events and their corresponding property names.\n\n    var eventTypes = {\n      beforeInput: {\n        phasedRegistrationNames: {\n          bubbled: 'onBeforeInput',\n          captured: 'onBeforeInputCapture'\n        },\n        dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']\n      },\n      compositionEnd: {\n        phasedRegistrationNames: {\n          bubbled: 'onCompositionEnd',\n          captured: 'onCompositionEndCapture'\n        },\n        dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n      },\n      compositionStart: {\n        phasedRegistrationNames: {\n          bubbled: 'onCompositionStart',\n          captured: 'onCompositionStartCapture'\n        },\n        dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n      },\n      compositionUpdate: {\n        phasedRegistrationNames: {\n          bubbled: 'onCompositionUpdate',\n          captured: 'onCompositionUpdateCapture'\n        },\n        dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n      }\n    }; // Track whether we've ever handled a keypress on the space key.\n\n    var hasSpaceKeypress = false;\n    /**\n     * Return whether a native keypress event is assumed to be a command.\n     * This is required because Firefox fires `keypress` events for key commands\n     * (cut, copy, select-all, etc.) even though no character is inserted.\n     */\n\n    function isKeypressCommand(nativeEvent) {\n      return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n      !(nativeEvent.ctrlKey && nativeEvent.altKey);\n    }\n    /**\n     * Translate native top level events into event types.\n     *\n     * @param {string} topLevelType\n     * @return {object}\n     */\n\n\n    function getCompositionEventType(topLevelType) {\n      switch (topLevelType) {\n        case 'topCompositionStart':\n          return eventTypes.compositionStart;\n\n        case 'topCompositionEnd':\n          return eventTypes.compositionEnd;\n\n        case 'topCompositionUpdate':\n          return eventTypes.compositionUpdate;\n      }\n    }\n    /**\n     * Does our fallback best-guess model think this event signifies that\n     * composition has begun?\n     *\n     * @param {string} topLevelType\n     * @param {object} nativeEvent\n     * @return {boolean}\n     */\n\n\n    function isFallbackCompositionStart(topLevelType, nativeEvent) {\n      return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;\n    }\n    /**\n     * Does our fallback mode think that this event is the end of composition?\n     *\n     * @param {string} topLevelType\n     * @param {object} nativeEvent\n     * @return {boolean}\n     */\n\n\n    function isFallbackCompositionEnd(topLevelType, nativeEvent) {\n      switch (topLevelType) {\n        case 'topKeyUp':\n          // Command keys insert or clear IME input.\n          return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n\n        case 'topKeyDown':\n          // Expect IME keyCode on each keydown. If we get any other\n          // code we must have exited earlier.\n          return nativeEvent.keyCode !== START_KEYCODE;\n\n        case 'topKeyPress':\n        case 'topMouseDown':\n        case 'topBlur':\n          // Events are not possible without cancelling IME.\n          return true;\n\n        default:\n          return false;\n      }\n    }\n    /**\n     * Google Input Tools provides composition data via a CustomEvent,\n     * with the `data` property populated in the `detail` object. If this\n     * is available on the event object, use it. If not, this is a plain\n     * composition event and we have nothing special to extract.\n     *\n     * @param {object} nativeEvent\n     * @return {?string}\n     */\n\n\n    function getDataFromCustomEvent(nativeEvent) {\n      var detail = nativeEvent.detail;\n\n      if (typeof detail === 'object' && 'data' in detail) {\n        return detail.data;\n      }\n\n      return null;\n    } // Track the current IME composition status, if any.\n\n\n    var isComposing = false;\n    /**\n     * @return {?object} A SyntheticCompositionEvent.\n     */\n\n    function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n      var eventType;\n      var fallbackData;\n\n      if (canUseCompositionEvent) {\n        eventType = getCompositionEventType(topLevelType);\n      } else if (!isComposing) {\n        if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\n          eventType = eventTypes.compositionStart;\n        }\n      } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n        eventType = eventTypes.compositionEnd;\n      }\n\n      if (!eventType) {\n        return null;\n      }\n\n      if (useFallbackCompositionData) {\n        // The current composition is stored statically and must not be\n        // overwritten while composition continues.\n        if (!isComposing && eventType === eventTypes.compositionStart) {\n          isComposing = initialize(nativeEventTarget);\n        } else if (eventType === eventTypes.compositionEnd) {\n          if (isComposing) {\n            fallbackData = getData();\n          }\n        }\n      }\n\n      var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);\n\n      if (fallbackData) {\n        // Inject data generated from fallback path into the synthetic event.\n        // This matches the property of native CompositionEventInterface.\n        event.data = fallbackData;\n      } else {\n        var customData = getDataFromCustomEvent(nativeEvent);\n\n        if (customData !== null) {\n          event.data = customData;\n        }\n      }\n\n      accumulateTwoPhaseDispatches(event);\n      return event;\n    }\n    /**\n     * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.\n     * @param {object} nativeEvent Native browser event.\n     * @return {?string} The string corresponding to this `beforeInput` event.\n     */\n\n\n    function getNativeBeforeInputChars(topLevelType, nativeEvent) {\n      switch (topLevelType) {\n        case 'topCompositionEnd':\n          return getDataFromCustomEvent(nativeEvent);\n\n        case 'topKeyPress':\n          /**\n           * If native `textInput` events are available, our goal is to make\n           * use of them. However, there is a special case: the spacebar key.\n           * In Webkit, preventing default on a spacebar `textInput` event\n           * cancels character insertion, but it *also* causes the browser\n           * to fall back to its default spacebar behavior of scrolling the\n           * page.\n           *\n           * Tracking at:\n           * https://code.google.com/p/chromium/issues/detail?id=355103\n           *\n           * To avoid this issue, use the keypress event as if no `textInput`\n           * event is available.\n           */\n          var which = nativeEvent.which;\n\n          if (which !== SPACEBAR_CODE) {\n            return null;\n          }\n\n          hasSpaceKeypress = true;\n          return SPACEBAR_CHAR;\n\n        case 'topTextInput':\n          // Record the characters to be added to the DOM.\n          var chars = nativeEvent.data; // If it's a spacebar character, assume that we have already handled\n          // it at the keypress level and bail immediately. Android Chrome\n          // doesn't give us keycodes, so we need to blacklist it.\n\n          if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n            return null;\n          }\n\n          return chars;\n\n        default:\n          // For other native event types, do nothing.\n          return null;\n      }\n    }\n    /**\n     * For browsers that do not provide the `textInput` event, extract the\n     * appropriate string to use for SyntheticInputEvent.\n     *\n     * @param {string} topLevelType Record from `BrowserEventConstants`.\n     * @param {object} nativeEvent Native browser event.\n     * @return {?string} The fallback string for this `beforeInput` event.\n     */\n\n\n    function getFallbackBeforeInputChars(topLevelType, nativeEvent) {\n      // If we are currently composing (IME) and using a fallback to do so,\n      // try to extract the composed characters from the fallback object.\n      // If composition event is available, we extract a string only at\n      // compositionevent, otherwise extract it at fallback events.\n      if (isComposing) {\n        if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n          var chars = getData();\n          reset();\n          isComposing = false;\n          return chars;\n        }\n\n        return null;\n      }\n\n      switch (topLevelType) {\n        case 'topPaste':\n          // If a paste event occurs after a keypress, throw out the input\n          // chars. Paste events should not lead to BeforeInput events.\n          return null;\n\n        case 'topKeyPress':\n          /**\n           * As of v27, Firefox may fire keypress events even when no character\n           * will be inserted. A few possibilities:\n           *\n           * - `which` is `0`. Arrow keys, Esc key, etc.\n           *\n           * - `which` is the pressed key code, but no char is available.\n           *   Ex: 'AltGr + d` in Polish. There is no modified character for\n           *   this key combination and no character is inserted into the\n           *   document, but FF fires the keypress for char code `100` anyway.\n           *   No `input` event will occur.\n           *\n           * - `which` is the pressed key code, but a command combination is\n           *   being used. Ex: `Cmd+C`. No character is inserted, and no\n           *   `input` event will occur.\n           */\n          if (!isKeypressCommand(nativeEvent)) {\n            // IE fires the `keypress` event when a user types an emoji via\n            // Touch keyboard of Windows.  In such a case, the `char` property\n            // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n            // is 2, the property `which` does not represent an emoji correctly.\n            // In such a case, we directly return the `char` property instead of\n            // using `which`.\n            if (nativeEvent.char && nativeEvent.char.length > 1) {\n              return nativeEvent.char;\n            } else if (nativeEvent.which) {\n              return String.fromCharCode(nativeEvent.which);\n            }\n          }\n\n          return null;\n\n        case 'topCompositionEnd':\n          return useFallbackCompositionData ? null : nativeEvent.data;\n\n        default:\n          return null;\n      }\n    }\n    /**\n     * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n     * `textInput` or fallback behavior.\n     *\n     * @return {?object} A SyntheticInputEvent.\n     */\n\n\n    function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n      var chars;\n\n      if (canUseTextInputEvent) {\n        chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\n      } else {\n        chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\n      } // If no characters are being inserted, no BeforeInput event should\n      // be fired.\n\n\n      if (!chars) {\n        return null;\n      }\n\n      var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);\n      event.data = chars;\n      accumulateTwoPhaseDispatches(event);\n      return event;\n    }\n    /**\n     * Create an `onBeforeInput` event to match\n     * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n     *\n     * This event plugin is based on the native `textInput` event\n     * available in Chrome, Safari, Opera, and IE. This event fires after\n     * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n     *\n     * `beforeInput` is spec'd but not implemented in any browsers, and\n     * the `input` event does not provide any useful information about what has\n     * actually been added, contrary to the spec. Thus, `textInput` is the best\n     * available event to identify the characters that have actually been inserted\n     * into the target node.\n     *\n     * This plugin is also responsible for emitting `composition` events, thus\n     * allowing us to share composition fallback code for both `beforeInput` and\n     * `composition` event types.\n     */\n\n\n    var BeforeInputEventPlugin = {\n      eventTypes: eventTypes,\n      extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n        return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];\n      }\n    }; // Use to restore controlled state after a change event has fired.\n\n    var fiberHostComponent = null;\n    var ReactControlledComponentInjection = {\n      injectFiberControlledHostComponent: function (hostComponentImpl) {\n        // The fiber implementation doesn't use dynamic dispatch so we need to\n        // inject the implementation.\n        fiberHostComponent = hostComponentImpl;\n      }\n    };\n    var restoreTarget = null;\n    var restoreQueue = null;\n\n    function restoreStateOfTarget(target) {\n      // We perform this translation at the end of the event loop so that we\n      // always receive the correct fiber here\n      var internalInstance = getInstanceFromNode(target);\n\n      if (!internalInstance) {\n        // Unmounted\n        return;\n      }\n\n      !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\n      fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);\n    }\n\n    var injection$3 = ReactControlledComponentInjection;\n\n    function enqueueStateRestore(target) {\n      if (restoreTarget) {\n        if (restoreQueue) {\n          restoreQueue.push(target);\n        } else {\n          restoreQueue = [target];\n        }\n      } else {\n        restoreTarget = target;\n      }\n    }\n\n    function restoreStateIfNeeded() {\n      if (!restoreTarget) {\n        return;\n      }\n\n      var target = restoreTarget;\n      var queuedTargets = restoreQueue;\n      restoreTarget = null;\n      restoreQueue = null;\n      restoreStateOfTarget(target);\n\n      if (queuedTargets) {\n        for (var i = 0; i < queuedTargets.length; i++) {\n          restoreStateOfTarget(queuedTargets[i]);\n        }\n      }\n    }\n\n    var ReactControlledComponent = Object.freeze({\n      injection: injection$3,\n      enqueueStateRestore: enqueueStateRestore,\n      restoreStateIfNeeded: restoreStateIfNeeded\n    }); // Used as a way to call batchedUpdates when we don't have a reference to\n    // the renderer. Such as when we're dispatching events or if third party\n    // libraries need to call batchedUpdates. Eventually, this API will go away when\n    // everything is batched by default. We'll then have a similar API to opt-out of\n    // scheduled work and instead do synchronous work.\n    // Defaults\n\n    var fiberBatchedUpdates = function (fn, bookkeeping) {\n      return fn(bookkeeping);\n    };\n\n    var isNestingBatched = false;\n\n    function batchedUpdates(fn, bookkeeping) {\n      if (isNestingBatched) {\n        // If we are currently inside another batch, we need to wait until it\n        // fully completes before restoring state. Therefore, we add the target to\n        // a queue of work.\n        return fiberBatchedUpdates(fn, bookkeeping);\n      }\n\n      isNestingBatched = true;\n\n      try {\n        return fiberBatchedUpdates(fn, bookkeeping);\n      } finally {\n        // Here we wait until all updates have propagated, which is important\n        // when using controlled components within layers:\n        // https://github.com/facebook/react/issues/1698\n        // Then we restore state of any controlled component.\n        isNestingBatched = false;\n        restoreStateIfNeeded();\n      }\n    }\n\n    var ReactGenericBatchingInjection = {\n      injectFiberBatchedUpdates: function (_batchedUpdates) {\n        fiberBatchedUpdates = _batchedUpdates;\n      }\n    };\n    var injection$4 = ReactGenericBatchingInjection;\n    /**\n     * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n     */\n\n    var supportedInputTypes = {\n      color: true,\n      date: true,\n      datetime: true,\n      'datetime-local': true,\n      email: true,\n      month: true,\n      number: true,\n      password: true,\n      range: true,\n      search: true,\n      tel: true,\n      text: true,\n      time: true,\n      url: true,\n      week: true\n    };\n\n    function isTextInputElement(elem) {\n      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n\n      if (nodeName === 'input') {\n        return !!supportedInputTypes[elem.type];\n      }\n\n      if (nodeName === 'textarea') {\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * HTML nodeType values that represent the type of the node\n     */\n\n\n    var ELEMENT_NODE = 1;\n    var TEXT_NODE = 3;\n    var COMMENT_NODE = 8;\n    var DOCUMENT_NODE = 9;\n    var DOCUMENT_FRAGMENT_NODE = 11;\n    /**\n     * Gets the target node from a native browser event by accounting for\n     * inconsistencies in browser DOM APIs.\n     *\n     * @param {object} nativeEvent Native browser event.\n     * @return {DOMEventTarget} Target node.\n     */\n\n    function getEventTarget(nativeEvent) {\n      var target = nativeEvent.target || nativeEvent.srcElement || window; // Normalize SVG <use> element events #4963\n\n      if (target.correspondingUseElement) {\n        target = target.correspondingUseElement;\n      } // Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n      // @see http://www.quirksmode.org/js/events_properties.html\n\n\n      return target.nodeType === TEXT_NODE ? target.parentNode : target;\n    }\n\n    var useHasFeature;\n\n    if (ExecutionEnvironment.canUseDOM) {\n      useHasFeature = document.implementation && document.implementation.hasFeature && // always returns true in newer browsers as per the standard.\n      // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n      document.implementation.hasFeature('', '') !== true;\n    }\n    /**\n     * Checks if an event is supported in the current execution environment.\n     *\n     * NOTE: This will not work correctly for non-generic events such as `change`,\n     * `reset`, `load`, `error`, and `select`.\n     *\n     * Borrows from Modernizr.\n     *\n     * @param {string} eventNameSuffix Event name, e.g. \"click\".\n     * @param {?boolean} capture Check if the capture phase is supported.\n     * @return {boolean} True if the event is supported.\n     * @internal\n     * @license Modernizr 3.0.0pre (Custom Build) | MIT\n     */\n\n\n    function isEventSupported(eventNameSuffix, capture) {\n      if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {\n        return false;\n      }\n\n      var eventName = 'on' + eventNameSuffix;\n      var isSupported = eventName in document;\n\n      if (!isSupported) {\n        var element = document.createElement('div');\n        element.setAttribute(eventName, 'return;');\n        isSupported = typeof element[eventName] === 'function';\n      }\n\n      if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {\n        // This is the only way to test support for the `wheel` event in IE9+.\n        isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n      }\n\n      return isSupported;\n    }\n\n    function isCheckable(elem) {\n      var type = elem.type;\n      var nodeName = elem.nodeName;\n      return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');\n    }\n\n    function getTracker(node) {\n      return node._valueTracker;\n    }\n\n    function detachTracker(node) {\n      node._valueTracker = null;\n    }\n\n    function getValueFromNode(node) {\n      var value = '';\n\n      if (!node) {\n        return value;\n      }\n\n      if (isCheckable(node)) {\n        value = node.checked ? 'true' : 'false';\n      } else {\n        value = node.value;\n      }\n\n      return value;\n    }\n\n    function trackValueOnNode(node) {\n      var valueField = isCheckable(node) ? 'checked' : 'value';\n      var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\n      var currentValue = '' + node[valueField]; // if someone has already defined a value or Safari, then bail\n      // and don't track value will cause over reporting of changes,\n      // but it's better then a hard failure\n      // (needed for certain tests that spyOn input values and Safari)\n\n      if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {\n        return;\n      }\n\n      Object.defineProperty(node, valueField, {\n        enumerable: descriptor.enumerable,\n        configurable: true,\n        get: function () {\n          return descriptor.get.call(this);\n        },\n        set: function (value) {\n          currentValue = '' + value;\n          descriptor.set.call(this, value);\n        }\n      });\n      var tracker = {\n        getValue: function () {\n          return currentValue;\n        },\n        setValue: function (value) {\n          currentValue = '' + value;\n        },\n        stopTracking: function () {\n          detachTracker(node);\n          delete node[valueField];\n        }\n      };\n      return tracker;\n    }\n\n    function track(node) {\n      if (getTracker(node)) {\n        return;\n      } // TODO: Once it's just Fiber we can move this to node._wrapperState\n\n\n      node._valueTracker = trackValueOnNode(node);\n    }\n\n    function updateValueIfChanged(node) {\n      if (!node) {\n        return false;\n      }\n\n      var tracker = getTracker(node); // if there is no tracker at this point it's unlikely\n      // that trying again will succeed\n\n      if (!tracker) {\n        return true;\n      }\n\n      var lastValue = tracker.getValue();\n      var nextValue = getValueFromNode(node);\n\n      if (nextValue !== lastValue) {\n        tracker.setValue(nextValue);\n        return true;\n      }\n\n      return false;\n    }\n\n    var eventTypes$1 = {\n      change: {\n        phasedRegistrationNames: {\n          bubbled: 'onChange',\n          captured: 'onChangeCapture'\n        },\n        dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']\n      }\n    };\n\n    function createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n      var event = SyntheticEvent$1.getPooled(eventTypes$1.change, inst, nativeEvent, target);\n      event.type = 'change'; // Flag this event loop as needing state restore.\n\n      enqueueStateRestore(target);\n      accumulateTwoPhaseDispatches(event);\n      return event;\n    }\n    /**\n     * For IE shims\n     */\n\n\n    var activeElement = null;\n    var activeElementInst = null;\n    /**\n     * SECTION: handle `change` event\n     */\n\n    function shouldUseChangeEvent(elem) {\n      var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n      return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n    }\n\n    function manualDispatchChangeEvent(nativeEvent) {\n      var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent)); // If change and propertychange bubbled, we'd just bind to it like all the\n      // other events and have it go through ReactBrowserEventEmitter. Since it\n      // doesn't, we manually listen for the events and so we have to enqueue and\n      // process the abstract event manually.\n      //\n      // Batching is necessary here in order to ensure that all event handlers run\n      // before the next rerender (including event handlers attached to ancestor\n      // elements instead of directly on the input). Without this, controlled\n      // components don't work properly in conjunction with event bubbling because\n      // the component is rerendered and the value reverted before all the event\n      // handlers can run. See https://github.com/facebook/react/issues/708.\n\n      batchedUpdates(runEventInBatch, event);\n    }\n\n    function runEventInBatch(event) {\n      enqueueEvents(event);\n      processEventQueue(false);\n    }\n\n    function getInstIfValueChanged(targetInst) {\n      var targetNode = getNodeFromInstance$1(targetInst);\n\n      if (updateValueIfChanged(targetNode)) {\n        return targetInst;\n      }\n    }\n\n    function getTargetInstForChangeEvent(topLevelType, targetInst) {\n      if (topLevelType === 'topChange') {\n        return targetInst;\n      }\n    }\n    /**\n     * SECTION: handle `input` event\n     */\n\n\n    var isInputEventSupported = false;\n\n    if (ExecutionEnvironment.canUseDOM) {\n      // IE9 claims to support the input event but fails to trigger it when\n      // deleting text, so we ignore its input events.\n      isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\n    }\n    /**\n     * (For IE <=9) Starts tracking propertychange events on the passed-in element\n     * and override the value property so that we can distinguish user events from\n     * value changes in JS.\n     */\n\n\n    function startWatchingForValueChange(target, targetInst) {\n      activeElement = target;\n      activeElementInst = targetInst;\n      activeElement.attachEvent('onpropertychange', handlePropertyChange);\n    }\n    /**\n     * (For IE <=9) Removes the event listeners from the currently-tracked element,\n     * if any exists.\n     */\n\n\n    function stopWatchingForValueChange() {\n      if (!activeElement) {\n        return;\n      }\n\n      activeElement.detachEvent('onpropertychange', handlePropertyChange);\n      activeElement = null;\n      activeElementInst = null;\n    }\n    /**\n     * (For IE <=9) Handles a propertychange event, sending a `change` event if\n     * the value of the active element has changed.\n     */\n\n\n    function handlePropertyChange(nativeEvent) {\n      if (nativeEvent.propertyName !== 'value') {\n        return;\n      }\n\n      if (getInstIfValueChanged(activeElementInst)) {\n        manualDispatchChangeEvent(nativeEvent);\n      }\n    }\n\n    function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n      if (topLevelType === 'topFocus') {\n        // In IE9, propertychange fires for most input events but is buggy and\n        // doesn't fire when text is deleted, but conveniently, selectionchange\n        // appears to fire in all of the remaining cases so we catch those and\n        // forward the event if the value has changed\n        // In either case, we don't want to call the event handler if the value\n        // is changed from JS so we redefine a setter for `.value` that updates\n        // our activeElementValue variable, allowing us to ignore those changes\n        //\n        // stopWatching() should be a noop here but we call it just in case we\n        // missed a blur event somehow.\n        stopWatchingForValueChange();\n        startWatchingForValueChange(target, targetInst);\n      } else if (topLevelType === 'topBlur') {\n        stopWatchingForValueChange();\n      }\n    } // For IE8 and IE9.\n\n\n    function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {\n      if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {\n        // On the selectionchange event, the target is just document which isn't\n        // helpful for us so just check activeElement instead.\n        //\n        // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n        // propertychange on the first input event after setting `value` from a\n        // script and fires only keydown, keypress, keyup. Catching keyup usually\n        // gets it and catching keydown lets us fire an event for the first\n        // keystroke if user does a key repeat (it'll be a little delayed: right\n        // before the second keystroke). Other input methods (e.g., paste) seem to\n        // fire selectionchange normally.\n        return getInstIfValueChanged(activeElementInst);\n      }\n    }\n    /**\n     * SECTION: handle `click` event\n     */\n\n\n    function shouldUseClickEvent(elem) {\n      // Use the `click` event to detect changes to checkbox and radio inputs.\n      // This approach works across all browsers, whereas `change` does not fire\n      // until `blur` in IE8.\n      var nodeName = elem.nodeName;\n      return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n    }\n\n    function getTargetInstForClickEvent(topLevelType, targetInst) {\n      if (topLevelType === 'topClick') {\n        return getInstIfValueChanged(targetInst);\n      }\n    }\n\n    function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {\n      if (topLevelType === 'topInput' || topLevelType === 'topChange') {\n        return getInstIfValueChanged(targetInst);\n      }\n    }\n\n    function handleControlledInputBlur(inst, node) {\n      // TODO: In IE, inst is occasionally null. Why?\n      if (inst == null) {\n        return;\n      } // Fiber and ReactDOM keep wrapper state in separate places\n\n\n      var state = inst._wrapperState || node._wrapperState;\n\n      if (!state || !state.controlled || node.type !== 'number') {\n        return;\n      } // If controlled, assign the value attribute to the current value on blur\n\n\n      var value = '' + node.value;\n\n      if (node.getAttribute('value') !== value) {\n        node.setAttribute('value', value);\n      }\n    }\n    /**\n     * This plugin creates an `onChange` event that normalizes change events\n     * across form elements. This event fires at a time when it's possible to\n     * change the element's value without seeing a flicker.\n     *\n     * Supported elements are:\n     * - input (see `isTextInputElement`)\n     * - textarea\n     * - select\n     */\n\n\n    var ChangeEventPlugin = {\n      eventTypes: eventTypes$1,\n      _isInputEventSupported: isInputEventSupported,\n      extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n        var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n        var getTargetInstFunc, handleEventFunc;\n\n        if (shouldUseChangeEvent(targetNode)) {\n          getTargetInstFunc = getTargetInstForChangeEvent;\n        } else if (isTextInputElement(targetNode)) {\n          if (isInputEventSupported) {\n            getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n          } else {\n            getTargetInstFunc = getTargetInstForInputEventPolyfill;\n            handleEventFunc = handleEventsForInputEventPolyfill;\n          }\n        } else if (shouldUseClickEvent(targetNode)) {\n          getTargetInstFunc = getTargetInstForClickEvent;\n        }\n\n        if (getTargetInstFunc) {\n          var inst = getTargetInstFunc(topLevelType, targetInst);\n\n          if (inst) {\n            var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\n            return event;\n          }\n        }\n\n        if (handleEventFunc) {\n          handleEventFunc(topLevelType, targetNode, targetInst);\n        } // When blurring, set the value attribute for number inputs\n\n\n        if (topLevelType === 'topBlur') {\n          handleControlledInputBlur(targetInst, targetNode);\n        }\n      }\n    };\n    /**\n     * Module that is injectable into `EventPluginHub`, that specifies a\n     * deterministic ordering of `EventPlugin`s. A convenient way to reason about\n     * plugins, without having to package every one of them. This is better than\n     * having plugins be ordered in the same order that they are injected because\n     * that ordering would be influenced by the packaging order.\n     * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that\n     * preventing default on events is convenient in `SimpleEventPlugin` handlers.\n     */\n\n    var DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];\n    /**\n     * @interface UIEvent\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\n     */\n\n    var UIEventInterface = {\n      view: null,\n      detail: null\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticEvent}\n     */\n\n    function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticEvent$1.augmentClass(SyntheticUIEvent, UIEventInterface);\n    /**\n     * Translation from modifier key to the associated property in the event.\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n     */\n\n    var modifierKeyToProp = {\n      Alt: 'altKey',\n      Control: 'ctrlKey',\n      Meta: 'metaKey',\n      Shift: 'shiftKey'\n    }; // IE8 does not implement getModifierState so we simply map it to the only\n    // modifier keys exposed by the event itself, does not support Lock-keys.\n    // Currently, all major browsers except Chrome seems to support Lock-keys.\n\n    function modifierStateGetter(keyArg) {\n      var syntheticEvent = this;\n      var nativeEvent = syntheticEvent.nativeEvent;\n\n      if (nativeEvent.getModifierState) {\n        return nativeEvent.getModifierState(keyArg);\n      }\n\n      var keyProp = modifierKeyToProp[keyArg];\n      return keyProp ? !!nativeEvent[keyProp] : false;\n    }\n\n    function getEventModifierState(nativeEvent) {\n      return modifierStateGetter;\n    }\n    /**\n     * @interface MouseEvent\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\n     */\n\n\n    var MouseEventInterface = {\n      screenX: null,\n      screenY: null,\n      clientX: null,\n      clientY: null,\n      pageX: null,\n      pageY: null,\n      ctrlKey: null,\n      shiftKey: null,\n      altKey: null,\n      metaKey: null,\n      getModifierState: getEventModifierState,\n      button: null,\n      buttons: null,\n      relatedTarget: function (event) {\n        return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);\n      }\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticUIEvent}\n     */\n\n    function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);\n    var eventTypes$2 = {\n      mouseEnter: {\n        registrationName: 'onMouseEnter',\n        dependencies: ['topMouseOut', 'topMouseOver']\n      },\n      mouseLeave: {\n        registrationName: 'onMouseLeave',\n        dependencies: ['topMouseOut', 'topMouseOver']\n      }\n    };\n    var EnterLeaveEventPlugin = {\n      eventTypes: eventTypes$2,\n\n      /**\n       * For almost every interaction we care about, there will be both a top-level\n       * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n       * we do not extract duplicate events. However, moving the mouse into the\n       * browser from outside will not fire a `mouseout` event. In this case, we use\n       * the `mouseover` top-level event.\n       */\n      extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n        if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n          return null;\n        }\n\n        if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {\n          // Must not be a mouse in or mouse out - ignoring.\n          return null;\n        }\n\n        var win;\n\n        if (nativeEventTarget.window === nativeEventTarget) {\n          // `nativeEventTarget` is probably a window object.\n          win = nativeEventTarget;\n        } else {\n          // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n          var doc = nativeEventTarget.ownerDocument;\n\n          if (doc) {\n            win = doc.defaultView || doc.parentWindow;\n          } else {\n            win = window;\n          }\n        }\n\n        var from;\n        var to;\n\n        if (topLevelType === 'topMouseOut') {\n          from = targetInst;\n          var related = nativeEvent.relatedTarget || nativeEvent.toElement;\n          to = related ? getClosestInstanceFromNode(related) : null;\n        } else {\n          // Moving to a node from outside the window.\n          from = null;\n          to = targetInst;\n        }\n\n        if (from === to) {\n          // Nothing pertains to our managed components.\n          return null;\n        }\n\n        var fromNode = from == null ? win : getNodeFromInstance$1(from);\n        var toNode = to == null ? win : getNodeFromInstance$1(to);\n        var leave = SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);\n        leave.type = 'mouseleave';\n        leave.target = fromNode;\n        leave.relatedTarget = toNode;\n        var enter = SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);\n        enter.type = 'mouseenter';\n        enter.target = toNode;\n        enter.relatedTarget = fromNode;\n        accumulateEnterLeaveDispatches(leave, enter, from, to);\n        return [leave, enter];\n      }\n    };\n    /**\n     * `ReactInstanceMap` maintains a mapping from a public facing stateful\n     * instance (key) and the internal representation (value). This allows public\n     * methods to accept the user facing instance as an argument and map them back\n     * to internal methods.\n     *\n     * Note that this module is currently shared and assumed to be stateless.\n     * If this becomes an actual Map, that will break.\n     */\n\n    /**\n     * This API should be called `delete` but we'd have to make sure to always\n     * transform these to strings for IE support. When this transform is fully\n     * supported we can rename it.\n     */\n\n    function get(key) {\n      return key._reactInternalFiber;\n    }\n\n    function has(key) {\n      return key._reactInternalFiber !== undefined;\n    }\n\n    function set(key, value) {\n      key._reactInternalFiber = value;\n    }\n\n    var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    var ReactCurrentOwner = ReactInternals.ReactCurrentOwner;\n    var ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;\n\n    function getComponentName(fiber) {\n      var type = fiber.type;\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      if (typeof type === 'function') {\n        return type.displayName || type.name;\n      }\n\n      return null;\n    } // Don't change these two values:\n\n\n    var NoEffect = 0; //           0b00000000\n\n    var PerformedWork = 1; //      0b00000001\n    // You can change the rest (and add more).\n\n    var Placement = 2; //          0b00000010\n\n    var Update = 4; //             0b00000100\n\n    var PlacementAndUpdate = 6; // 0b00000110\n\n    var Deletion = 8; //           0b00001000\n\n    var ContentReset = 16; //      0b00010000\n\n    var Callback = 32; //          0b00100000\n\n    var Err = 64; //               0b01000000\n\n    var Ref = 128; //              0b10000000\n\n    var MOUNTING = 1;\n    var MOUNTED = 2;\n    var UNMOUNTED = 3;\n\n    function isFiberMountedImpl(fiber) {\n      var node = fiber;\n\n      if (!fiber.alternate) {\n        // If there is no alternate, this might be a new tree that isn't inserted\n        // yet. If it is, then it will have a pending insertion effect on it.\n        if ((node.effectTag & Placement) !== NoEffect) {\n          return MOUNTING;\n        }\n\n        while (node['return']) {\n          node = node['return'];\n\n          if ((node.effectTag & Placement) !== NoEffect) {\n            return MOUNTING;\n          }\n        }\n      } else {\n        while (node['return']) {\n          node = node['return'];\n        }\n      }\n\n      if (node.tag === HostRoot) {\n        // TODO: Check if this was a nested HostRoot when used with\n        // renderContainerIntoSubtree.\n        return MOUNTED;\n      } // If we didn't hit the root, that means that we're in an disconnected tree\n      // that has been unmounted.\n\n\n      return UNMOUNTED;\n    }\n\n    function isFiberMounted(fiber) {\n      return isFiberMountedImpl(fiber) === MOUNTED;\n    }\n\n    function isMounted(component) {\n      {\n        var owner = ReactCurrentOwner.current;\n\n        if (owner !== null && owner.tag === ClassComponent) {\n          var ownerFiber = owner;\n          var instance = ownerFiber.stateNode;\n          warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');\n          instance._warnedAboutRefsInRender = true;\n        }\n      }\n      var fiber = get(component);\n\n      if (!fiber) {\n        return false;\n      }\n\n      return isFiberMountedImpl(fiber) === MOUNTED;\n    }\n\n    function assertIsMounted(fiber) {\n      !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    }\n\n    function findCurrentFiberUsingSlowPath(fiber) {\n      var alternate = fiber.alternate;\n\n      if (!alternate) {\n        // If there is no alternate, then we only need to check if it is mounted.\n        var state = isFiberMountedImpl(fiber);\n        !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n\n        if (state === MOUNTING) {\n          return null;\n        }\n\n        return fiber;\n      } // If we have two possible branches, we'll walk backwards up to the root\n      // to see what path the root points to. On the way we may hit one of the\n      // special cases and we'll deal with them.\n\n\n      var a = fiber;\n      var b = alternate;\n\n      while (true) {\n        var parentA = a['return'];\n        var parentB = parentA ? parentA.alternate : null;\n\n        if (!parentA || !parentB) {\n          // We're at the root.\n          break;\n        } // If both copies of the parent fiber point to the same child, we can\n        // assume that the child is current. This happens when we bailout on low\n        // priority: the bailed out fiber's child reuses the current child.\n\n\n        if (parentA.child === parentB.child) {\n          var child = parentA.child;\n\n          while (child) {\n            if (child === a) {\n              // We've determined that A is the current branch.\n              assertIsMounted(parentA);\n              return fiber;\n            }\n\n            if (child === b) {\n              // We've determined that B is the current branch.\n              assertIsMounted(parentA);\n              return alternate;\n            }\n\n            child = child.sibling;\n          } // We should never have an alternate for any mounting node. So the only\n          // way this could possibly happen is if this was unmounted, if at all.\n\n\n          invariant(false, 'Unable to find node on an unmounted component.');\n        }\n\n        if (a['return'] !== b['return']) {\n          // The return pointer of A and the return pointer of B point to different\n          // fibers. We assume that return pointers never criss-cross, so A must\n          // belong to the child set of A.return, and B must belong to the child\n          // set of B.return.\n          a = parentA;\n          b = parentB;\n        } else {\n          // The return pointers point to the same fiber. We'll have to use the\n          // default, slow path: scan the child sets of each parent alternate to see\n          // which child belongs to which set.\n          //\n          // Search parent A's child set\n          var didFindChild = false;\n          var _child = parentA.child;\n\n          while (_child) {\n            if (_child === a) {\n              didFindChild = true;\n              a = parentA;\n              b = parentB;\n              break;\n            }\n\n            if (_child === b) {\n              didFindChild = true;\n              b = parentA;\n              a = parentB;\n              break;\n            }\n\n            _child = _child.sibling;\n          }\n\n          if (!didFindChild) {\n            // Search parent B's child set\n            _child = parentB.child;\n\n            while (_child) {\n              if (_child === a) {\n                didFindChild = true;\n                a = parentB;\n                b = parentA;\n                break;\n              }\n\n              if (_child === b) {\n                didFindChild = true;\n                b = parentB;\n                a = parentA;\n                break;\n              }\n\n              _child = _child.sibling;\n            }\n\n            !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n          }\n        }\n\n        !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      } // If the root is not a host container, we're in a disconnected tree. I.e.\n      // unmounted.\n\n\n      !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n\n      if (a.stateNode.current === a) {\n        // We've determined that A is the current branch.\n        return fiber;\n      } // Otherwise B has to be current branch.\n\n\n      return alternate;\n    }\n\n    function findCurrentHostFiber(parent) {\n      var currentParent = findCurrentFiberUsingSlowPath(parent);\n\n      if (!currentParent) {\n        return null;\n      } // Next we'll drill down this component to find the first HostComponent/Text.\n\n\n      var node = currentParent;\n\n      while (true) {\n        if (node.tag === HostComponent || node.tag === HostText) {\n          return node;\n        } else if (node.child) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n\n        if (node === currentParent) {\n          return null;\n        }\n\n        while (!node.sibling) {\n          if (!node['return'] || node['return'] === currentParent) {\n            return null;\n          }\n\n          node = node['return'];\n        }\n\n        node.sibling['return'] = node['return'];\n        node = node.sibling;\n      } // Flow needs the return null here, but ESLint complains about it.\n      // eslint-disable-next-line no-unreachable\n\n\n      return null;\n    }\n\n    function findCurrentHostFiberWithNoPortals(parent) {\n      var currentParent = findCurrentFiberUsingSlowPath(parent);\n\n      if (!currentParent) {\n        return null;\n      } // Next we'll drill down this component to find the first HostComponent/Text.\n\n\n      var node = currentParent;\n\n      while (true) {\n        if (node.tag === HostComponent || node.tag === HostText) {\n          return node;\n        } else if (node.child && node.tag !== HostPortal) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n\n        if (node === currentParent) {\n          return null;\n        }\n\n        while (!node.sibling) {\n          if (!node['return'] || node['return'] === currentParent) {\n            return null;\n          }\n\n          node = node['return'];\n        }\n\n        node.sibling['return'] = node['return'];\n        node = node.sibling;\n      } // Flow needs the return null here, but ESLint complains about it.\n      // eslint-disable-next-line no-unreachable\n\n\n      return null;\n    }\n\n    var CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\n    var callbackBookkeepingPool = [];\n    /**\n     * Find the deepest React component completely containing the root of the\n     * passed-in instance (for use when entire React trees are nested within each\n     * other). If React trees are not nested, returns null.\n     */\n\n    function findRootContainerNode(inst) {\n      // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n      // traversal, but caching is difficult to do correctly without using a\n      // mutation observer to listen for all DOM changes.\n      while (inst['return']) {\n        inst = inst['return'];\n      }\n\n      if (inst.tag !== HostRoot) {\n        // This can happen if we're in a detached tree.\n        return null;\n      }\n\n      return inst.stateNode.containerInfo;\n    } // Used to store ancestor hierarchy in top level callback\n\n\n    function getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {\n      if (callbackBookkeepingPool.length) {\n        var instance = callbackBookkeepingPool.pop();\n        instance.topLevelType = topLevelType;\n        instance.nativeEvent = nativeEvent;\n        instance.targetInst = targetInst;\n        return instance;\n      }\n\n      return {\n        topLevelType: topLevelType,\n        nativeEvent: nativeEvent,\n        targetInst: targetInst,\n        ancestors: []\n      };\n    }\n\n    function releaseTopLevelCallbackBookKeeping(instance) {\n      instance.topLevelType = null;\n      instance.nativeEvent = null;\n      instance.targetInst = null;\n      instance.ancestors.length = 0;\n\n      if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n        callbackBookkeepingPool.push(instance);\n      }\n    }\n\n    function handleTopLevelImpl(bookKeeping) {\n      var targetInst = bookKeeping.targetInst; // Loop through the hierarchy, in case there's any nested components.\n      // It's important that we build the array of ancestors before calling any\n      // event handlers, because event handlers can modify the DOM, leading to\n      // inconsistencies with ReactMount's node cache. See #1105.\n\n      var ancestor = targetInst;\n\n      do {\n        if (!ancestor) {\n          bookKeeping.ancestors.push(ancestor);\n          break;\n        }\n\n        var root = findRootContainerNode(ancestor);\n\n        if (!root) {\n          break;\n        }\n\n        bookKeeping.ancestors.push(ancestor);\n        ancestor = getClosestInstanceFromNode(root);\n      } while (ancestor);\n\n      for (var i = 0; i < bookKeeping.ancestors.length; i++) {\n        targetInst = bookKeeping.ancestors[i];\n\n        _handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));\n      }\n    } // TODO: can we stop exporting these?\n\n\n    var _enabled = true;\n\n    var _handleTopLevel = void 0;\n\n    function setHandleTopLevel(handleTopLevel) {\n      _handleTopLevel = handleTopLevel;\n    }\n\n    function setEnabled(enabled) {\n      _enabled = !!enabled;\n    }\n\n    function isEnabled() {\n      return _enabled;\n    }\n    /**\n     * Traps top-level events by using event bubbling.\n     *\n     * @param {string} topLevelType Record from `BrowserEventConstants`.\n     * @param {string} handlerBaseName Event name (e.g. \"click\").\n     * @param {object} element Element on which to attach listener.\n     * @return {?object} An object with a remove function which will forcefully\n     *                  remove the listener.\n     * @internal\n     */\n\n\n    function trapBubbledEvent(topLevelType, handlerBaseName, element) {\n      if (!element) {\n        return null;\n      }\n\n      return EventListener.listen(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));\n    }\n    /**\n     * Traps a top-level event by using event capturing.\n     *\n     * @param {string} topLevelType Record from `BrowserEventConstants`.\n     * @param {string} handlerBaseName Event name (e.g. \"click\").\n     * @param {object} element Element on which to attach listener.\n     * @return {?object} An object with a remove function which will forcefully\n     *                  remove the listener.\n     * @internal\n     */\n\n\n    function trapCapturedEvent(topLevelType, handlerBaseName, element) {\n      if (!element) {\n        return null;\n      }\n\n      return EventListener.capture(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));\n    }\n\n    function dispatchEvent(topLevelType, nativeEvent) {\n      if (!_enabled) {\n        return;\n      }\n\n      var nativeEventTarget = getEventTarget(nativeEvent);\n      var targetInst = getClosestInstanceFromNode(nativeEventTarget);\n\n      if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {\n        // If we get an event (ex: img onload) before committing that\n        // component's mount, ignore it for now (that is, treat it as if it was an\n        // event on a non-React tree). We might also consider queueing events and\n        // dispatching them after the mount.\n        targetInst = null;\n      }\n\n      var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);\n\n      try {\n        // Event queue being processed in the same cycle allows\n        // `preventDefault`.\n        batchedUpdates(handleTopLevelImpl, bookKeeping);\n      } finally {\n        releaseTopLevelCallbackBookKeeping(bookKeeping);\n      }\n    }\n\n    var ReactDOMEventListener = Object.freeze({\n      get _enabled() {\n        return _enabled;\n      },\n\n      get _handleTopLevel() {\n        return _handleTopLevel;\n      },\n\n      setHandleTopLevel: setHandleTopLevel,\n      setEnabled: setEnabled,\n      isEnabled: isEnabled,\n      trapBubbledEvent: trapBubbledEvent,\n      trapCapturedEvent: trapCapturedEvent,\n      dispatchEvent: dispatchEvent\n    });\n    /**\n     * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n     *\n     * @param {string} styleProp\n     * @param {string} eventName\n     * @returns {object}\n     */\n\n    function makePrefixMap(styleProp, eventName) {\n      var prefixes = {};\n      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n      prefixes['Webkit' + styleProp] = 'webkit' + eventName;\n      prefixes['Moz' + styleProp] = 'moz' + eventName;\n      prefixes['ms' + styleProp] = 'MS' + eventName;\n      prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();\n      return prefixes;\n    }\n    /**\n     * A list of event names to a configurable list of vendor prefixes.\n     */\n\n\n    var vendorPrefixes = {\n      animationend: makePrefixMap('Animation', 'AnimationEnd'),\n      animationiteration: makePrefixMap('Animation', 'AnimationIteration'),\n      animationstart: makePrefixMap('Animation', 'AnimationStart'),\n      transitionend: makePrefixMap('Transition', 'TransitionEnd')\n    };\n    /**\n     * Event names that have already been detected and prefixed (if applicable).\n     */\n\n    var prefixedEventNames = {};\n    /**\n     * Element to check for prefixes on.\n     */\n\n    var style = {};\n    /**\n     * Bootstrap if a DOM exists.\n     */\n\n    if (ExecutionEnvironment.canUseDOM) {\n      style = document.createElement('div').style; // On some platforms, in particular some releases of Android 4.x,\n      // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n      // style object but the events that fire will still be prefixed, so we need\n      // to check if the un-prefixed events are usable, and if not remove them from the map.\n\n      if (!('AnimationEvent' in window)) {\n        delete vendorPrefixes.animationend.animation;\n        delete vendorPrefixes.animationiteration.animation;\n        delete vendorPrefixes.animationstart.animation;\n      } // Same as above\n\n\n      if (!('TransitionEvent' in window)) {\n        delete vendorPrefixes.transitionend.transition;\n      }\n    }\n    /**\n     * Attempts to determine the correct vendor prefixed event name.\n     *\n     * @param {string} eventName\n     * @returns {string}\n     */\n\n\n    function getVendorPrefixedEventName(eventName) {\n      if (prefixedEventNames[eventName]) {\n        return prefixedEventNames[eventName];\n      } else if (!vendorPrefixes[eventName]) {\n        return eventName;\n      }\n\n      var prefixMap = vendorPrefixes[eventName];\n\n      for (var styleProp in prefixMap) {\n        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\n          return prefixedEventNames[eventName] = prefixMap[styleProp];\n        }\n      }\n\n      return '';\n    }\n    /**\n     * Types of raw signals from the browser caught at the top level.\n     *\n     * For events like 'submit' which don't consistently bubble (which we\n     * trap at a lower node than `document`), binding at `document` would\n     * cause duplicate events so we don't include them here.\n     */\n\n\n    var topLevelTypes$1 = {\n      topAbort: 'abort',\n      topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',\n      topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',\n      topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',\n      topBlur: 'blur',\n      topCancel: 'cancel',\n      topCanPlay: 'canplay',\n      topCanPlayThrough: 'canplaythrough',\n      topChange: 'change',\n      topClick: 'click',\n      topClose: 'close',\n      topCompositionEnd: 'compositionend',\n      topCompositionStart: 'compositionstart',\n      topCompositionUpdate: 'compositionupdate',\n      topContextMenu: 'contextmenu',\n      topCopy: 'copy',\n      topCut: 'cut',\n      topDoubleClick: 'dblclick',\n      topDrag: 'drag',\n      topDragEnd: 'dragend',\n      topDragEnter: 'dragenter',\n      topDragExit: 'dragexit',\n      topDragLeave: 'dragleave',\n      topDragOver: 'dragover',\n      topDragStart: 'dragstart',\n      topDrop: 'drop',\n      topDurationChange: 'durationchange',\n      topEmptied: 'emptied',\n      topEncrypted: 'encrypted',\n      topEnded: 'ended',\n      topError: 'error',\n      topFocus: 'focus',\n      topInput: 'input',\n      topKeyDown: 'keydown',\n      topKeyPress: 'keypress',\n      topKeyUp: 'keyup',\n      topLoadedData: 'loadeddata',\n      topLoad: 'load',\n      topLoadedMetadata: 'loadedmetadata',\n      topLoadStart: 'loadstart',\n      topMouseDown: 'mousedown',\n      topMouseMove: 'mousemove',\n      topMouseOut: 'mouseout',\n      topMouseOver: 'mouseover',\n      topMouseUp: 'mouseup',\n      topPaste: 'paste',\n      topPause: 'pause',\n      topPlay: 'play',\n      topPlaying: 'playing',\n      topProgress: 'progress',\n      topRateChange: 'ratechange',\n      topScroll: 'scroll',\n      topSeeked: 'seeked',\n      topSeeking: 'seeking',\n      topSelectionChange: 'selectionchange',\n      topStalled: 'stalled',\n      topSuspend: 'suspend',\n      topTextInput: 'textInput',\n      topTimeUpdate: 'timeupdate',\n      topToggle: 'toggle',\n      topTouchCancel: 'touchcancel',\n      topTouchEnd: 'touchend',\n      topTouchMove: 'touchmove',\n      topTouchStart: 'touchstart',\n      topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',\n      topVolumeChange: 'volumechange',\n      topWaiting: 'waiting',\n      topWheel: 'wheel'\n    };\n    var BrowserEventConstants = {\n      topLevelTypes: topLevelTypes$1\n    };\n\n    function runEventQueueInBatch(events) {\n      enqueueEvents(events);\n      processEventQueue(false);\n    }\n    /**\n     * Streams a fired top-level event to `EventPluginHub` where plugins have the\n     * opportunity to create `ReactEvent`s to be dispatched.\n     */\n\n\n    function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n      var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n      runEventQueueInBatch(events);\n    }\n\n    var topLevelTypes = BrowserEventConstants.topLevelTypes;\n    /**\n     * Summary of `ReactBrowserEventEmitter` event handling:\n     *\n     *  - Top-level delegation is used to trap most native browser events. This\n     *    may only occur in the main thread and is the responsibility of\n     *    ReactDOMEventListener, which is injected and can therefore support\n     *    pluggable event sources. This is the only work that occurs in the main\n     *    thread.\n     *\n     *  - We normalize and de-duplicate events to account for browser quirks. This\n     *    may be done in the worker thread.\n     *\n     *  - Forward these native events (with the associated top-level type used to\n     *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n     *    to extract any synthetic events.\n     *\n     *  - The `EventPluginHub` will then process each event by annotating them with\n     *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n     *\n     *  - The `EventPluginHub` then dispatches the events.\n     *\n     * Overview of React and the event system:\n     *\n     * +------------+    .\n     * |    DOM     |    .\n     * +------------+    .\n     *       |           .\n     *       v           .\n     * +------------+    .\n     * | ReactEvent |    .\n     * |  Listener  |    .\n     * +------------+    .                         +-----------+\n     *       |           .               +--------+|SimpleEvent|\n     *       |           .               |         |Plugin     |\n     * +-----|------+    .               v         +-----------+\n     * |     |      |    .    +--------------+                    +------------+\n     * |     +-----------.--->|EventPluginHub|                    |    Event   |\n     * |            |    .    |              |     +-----------+  | Propagators|\n     * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n     * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n     * |            |    .    |              |     +-----------+  |  utilities |\n     * |     +-----------.--->|              |                    +------------+\n     * |     |      |    .    +--------------+\n     * +-----|------+    .                ^        +-----------+\n     *       |           .                |        |Enter/Leave|\n     *       +           .                +-------+|Plugin     |\n     * +-------------+   .                         +-----------+\n     * | application |   .\n     * |-------------|   .\n     * |             |   .\n     * |             |   .\n     * +-------------+   .\n     *                   .\n     *    React Core     .  General Purpose Event Plugin System\n     */\n\n    var alreadyListeningTo = {};\n    var reactTopListenersCounter = 0;\n    /**\n     * To ensure no conflicts with other potential React instances on the page\n     */\n\n    var topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);\n\n    function getListeningForDocument(mountAt) {\n      // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`\n      // directly.\n      if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {\n        mountAt[topListenersIDKey] = reactTopListenersCounter++;\n        alreadyListeningTo[mountAt[topListenersIDKey]] = {};\n      }\n\n      return alreadyListeningTo[mountAt[topListenersIDKey]];\n    }\n    /**\n     * We listen for bubbled touch events on the document object.\n     *\n     * Firefox v8.01 (and possibly others) exhibited strange behavior when\n     * mounting `onmousemove` events at some node that was not the document\n     * element. The symptoms were that if your mouse is not moving over something\n     * contained within that mount point (for example on the background) the\n     * top-level listeners for `onmousemove` won't be called. However, if you\n     * register the `mousemove` on the document object, then it will of course\n     * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n     * top-level listeners to the document object only, at least for these\n     * movement types of events and possibly all events.\n     *\n     * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n     *\n     * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n     * they bubble to document.\n     *\n     * @param {string} registrationName Name of listener (e.g. `onClick`).\n     * @param {object} contentDocumentHandle Document which owns the container\n     */\n\n\n    function listenTo(registrationName, contentDocumentHandle) {\n      var mountAt = contentDocumentHandle;\n      var isListening = getListeningForDocument(mountAt);\n      var dependencies = registrationNameDependencies[registrationName];\n\n      for (var i = 0; i < dependencies.length; i++) {\n        var dependency = dependencies[i];\n\n        if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n          if (dependency === 'topWheel') {\n            if (isEventSupported('wheel')) {\n              trapBubbledEvent('topWheel', 'wheel', mountAt);\n            } else if (isEventSupported('mousewheel')) {\n              trapBubbledEvent('topWheel', 'mousewheel', mountAt);\n            } else {\n              // Firefox needs to capture a different mouse scroll event.\n              // @see http://www.quirksmode.org/dom/events/tests/scroll.html\n              trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);\n            }\n          } else if (dependency === 'topScroll') {\n            trapCapturedEvent('topScroll', 'scroll', mountAt);\n          } else if (dependency === 'topFocus' || dependency === 'topBlur') {\n            trapCapturedEvent('topFocus', 'focus', mountAt);\n            trapCapturedEvent('topBlur', 'blur', mountAt); // to make sure blur and focus event listeners are only attached once\n\n            isListening.topBlur = true;\n            isListening.topFocus = true;\n          } else if (dependency === 'topCancel') {\n            if (isEventSupported('cancel', true)) {\n              trapCapturedEvent('topCancel', 'cancel', mountAt);\n            }\n\n            isListening.topCancel = true;\n          } else if (dependency === 'topClose') {\n            if (isEventSupported('close', true)) {\n              trapCapturedEvent('topClose', 'close', mountAt);\n            }\n\n            isListening.topClose = true;\n          } else if (topLevelTypes.hasOwnProperty(dependency)) {\n            trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);\n          }\n\n          isListening[dependency] = true;\n        }\n      }\n    }\n\n    function isListeningToAllDependencies(registrationName, mountAt) {\n      var isListening = getListeningForDocument(mountAt);\n      var dependencies = registrationNameDependencies[registrationName];\n\n      for (var i = 0; i < dependencies.length; i++) {\n        var dependency = dependencies[i];\n\n        if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Given any node return the first leaf node without children.\n     *\n     * @param {DOMElement|DOMTextNode} node\n     * @return {DOMElement|DOMTextNode}\n     */\n\n\n    function getLeafNode(node) {\n      while (node && node.firstChild) {\n        node = node.firstChild;\n      }\n\n      return node;\n    }\n    /**\n     * Get the next sibling within a container. This will walk up the\n     * DOM if a node's siblings have been exhausted.\n     *\n     * @param {DOMElement|DOMTextNode} node\n     * @return {?DOMElement|DOMTextNode}\n     */\n\n\n    function getSiblingNode(node) {\n      while (node) {\n        if (node.nextSibling) {\n          return node.nextSibling;\n        }\n\n        node = node.parentNode;\n      }\n    }\n    /**\n     * Get object describing the nodes which contain characters at offset.\n     *\n     * @param {DOMElement|DOMTextNode} root\n     * @param {number} offset\n     * @return {?object}\n     */\n\n\n    function getNodeForCharacterOffset(root, offset) {\n      var node = getLeafNode(root);\n      var nodeStart = 0;\n      var nodeEnd = 0;\n\n      while (node) {\n        if (node.nodeType === TEXT_NODE) {\n          nodeEnd = nodeStart + node.textContent.length;\n\n          if (nodeStart <= offset && nodeEnd >= offset) {\n            return {\n              node: node,\n              offset: offset - nodeStart\n            };\n          }\n\n          nodeStart = nodeEnd;\n        }\n\n        node = getLeafNode(getSiblingNode(node));\n      }\n    }\n    /**\n     * @param {DOMElement} outerNode\n     * @return {?object}\n     */\n\n\n    function getOffsets(outerNode) {\n      var selection = window.getSelection && window.getSelection();\n\n      if (!selection || selection.rangeCount === 0) {\n        return null;\n      }\n\n      var anchorNode = selection.anchorNode;\n      var anchorOffset = selection.anchorOffset;\n      var focusNode$$1 = selection.focusNode;\n      var focusOffset = selection.focusOffset; // In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n      // up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n      // expose properties, triggering a \"Permission denied error\" if any of its\n      // properties are accessed. The only seemingly possible way to avoid erroring\n      // is to access a property that typically works for non-anonymous divs and\n      // catch any error that may otherwise arise. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n\n      try {\n        /* eslint-disable no-unused-expressions */\n        anchorNode.nodeType;\n        focusNode$$1.nodeType;\n        /* eslint-enable no-unused-expressions */\n      } catch (e) {\n        return null;\n      }\n\n      return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset);\n    }\n    /**\n     * Returns {start, end} where `start` is the character/codepoint index of\n     * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n     * `end` is the index of (focusNode, focusOffset).\n     *\n     * Returns null if you pass in garbage input but we should probably just crash.\n     *\n     * Exported only for testing.\n     */\n\n\n    function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset) {\n      var length = 0;\n      var start = -1;\n      var end = -1;\n      var indexWithinAnchor = 0;\n      var indexWithinFocus = 0;\n      var node = outerNode;\n      var parentNode = null;\n\n      outer: while (true) {\n        var next = null;\n\n        while (true) {\n          if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\n            start = length + anchorOffset;\n          }\n\n          if (node === focusNode$$1 && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\n            end = length + focusOffset;\n          }\n\n          if (node.nodeType === TEXT_NODE) {\n            length += node.nodeValue.length;\n          }\n\n          if ((next = node.firstChild) === null) {\n            break;\n          } // Moving from `node` to its first child `next`.\n\n\n          parentNode = node;\n          node = next;\n        }\n\n        while (true) {\n          if (node === outerNode) {\n            // If `outerNode` has children, this is always the second time visiting\n            // it. If it has no children, this is still the first loop, and the only\n            // valid selection is anchorNode and focusNode both equal to this node\n            // and both offsets 0, in which case we will have handled above.\n            break outer;\n          }\n\n          if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\n            start = length;\n          }\n\n          if (parentNode === focusNode$$1 && ++indexWithinFocus === focusOffset) {\n            end = length;\n          }\n\n          if ((next = node.nextSibling) !== null) {\n            break;\n          }\n\n          node = parentNode;\n          parentNode = node.parentNode;\n        } // Moving from `node` to its next sibling `next`.\n\n\n        node = next;\n      }\n\n      if (start === -1 || end === -1) {\n        // This should never happen. (Would happen if the anchor/focus nodes aren't\n        // actually inside the passed-in node.)\n        return null;\n      }\n\n      return {\n        start: start,\n        end: end\n      };\n    }\n    /**\n     * In modern non-IE browsers, we can support both forward and backward\n     * selections.\n     *\n     * Note: IE10+ supports the Selection object, but it does not support\n     * the `extend` method, which means that even in modern IE, it's not possible\n     * to programmatically create a backward selection. Thus, for all IE\n     * versions, we use the old IE API to create our selections.\n     *\n     * @param {DOMElement|DOMTextNode} node\n     * @param {object} offsets\n     */\n\n\n    function setOffsets(node, offsets) {\n      if (!window.getSelection) {\n        return;\n      }\n\n      var selection = window.getSelection();\n      var length = node[getTextContentAccessor()].length;\n      var start = Math.min(offsets.start, length);\n      var end = offsets.end === undefined ? start : Math.min(offsets.end, length); // IE 11 uses modern selection, but doesn't support the extend method.\n      // Flip backward selections, so we can set with a single range.\n\n      if (!selection.extend && start > end) {\n        var temp = end;\n        end = start;\n        start = temp;\n      }\n\n      var startMarker = getNodeForCharacterOffset(node, start);\n      var endMarker = getNodeForCharacterOffset(node, end);\n\n      if (startMarker && endMarker) {\n        if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\n          return;\n        }\n\n        var range = document.createRange();\n        range.setStart(startMarker.node, startMarker.offset);\n        selection.removeAllRanges();\n\n        if (start > end) {\n          selection.addRange(range);\n          selection.extend(endMarker.node, endMarker.offset);\n        } else {\n          range.setEnd(endMarker.node, endMarker.offset);\n          selection.addRange(range);\n        }\n      }\n    }\n\n    function isInDocument(node) {\n      return containsNode(document.documentElement, node);\n    }\n    /**\n     * @ReactInputSelection: React input selection module. Based on Selection.js,\n     * but modified to be suitable for react and has a couple of bug fixes (doesn't\n     * assume buttons have range selections allowed).\n     * Input selection module for React.\n     */\n\n\n    function hasSelectionCapabilities(elem) {\n      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n      return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');\n    }\n\n    function getSelectionInformation() {\n      var focusedElem = getActiveElement();\n      return {\n        focusedElem: focusedElem,\n        selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null\n      };\n    }\n    /**\n     * @restoreSelection: If any selection information was potentially lost,\n     * restore it. This is useful when performing operations that could remove dom\n     * nodes and place them back in, resulting in focus being lost.\n     */\n\n\n    function restoreSelection(priorSelectionInformation) {\n      var curFocusedElem = getActiveElement();\n      var priorFocusedElem = priorSelectionInformation.focusedElem;\n      var priorSelectionRange = priorSelectionInformation.selectionRange;\n\n      if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n        if (hasSelectionCapabilities(priorFocusedElem)) {\n          setSelection(priorFocusedElem, priorSelectionRange);\n        } // Focusing a node can change the scroll position, which is undesirable\n\n\n        var ancestors = [];\n        var ancestor = priorFocusedElem;\n\n        while (ancestor = ancestor.parentNode) {\n          if (ancestor.nodeType === ELEMENT_NODE) {\n            ancestors.push({\n              element: ancestor,\n              left: ancestor.scrollLeft,\n              top: ancestor.scrollTop\n            });\n          }\n        }\n\n        focusNode(priorFocusedElem);\n\n        for (var i = 0; i < ancestors.length; i++) {\n          var info = ancestors[i];\n          info.element.scrollLeft = info.left;\n          info.element.scrollTop = info.top;\n        }\n      }\n    }\n    /**\n     * @getSelection: Gets the selection bounds of a focused textarea, input or\n     * contentEditable node.\n     * -@input: Look up selection bounds of this input\n     * -@return {start: selectionStart, end: selectionEnd}\n     */\n\n\n    function getSelection$1(input) {\n      var selection = void 0;\n\n      if ('selectionStart' in input) {\n        // Modern browser with input or textarea.\n        selection = {\n          start: input.selectionStart,\n          end: input.selectionEnd\n        };\n      } else {\n        // Content editable or old IE textarea.\n        selection = getOffsets(input);\n      }\n\n      return selection || {\n        start: 0,\n        end: 0\n      };\n    }\n    /**\n     * @setSelection: Sets the selection bounds of a textarea or input and focuses\n     * the input.\n     * -@input     Set selection bounds of this input or textarea\n     * -@offsets   Object of same form that is returned from get*\n     */\n\n\n    function setSelection(input, offsets) {\n      var start = offsets.start,\n          end = offsets.end;\n\n      if (end === undefined) {\n        end = start;\n      }\n\n      if ('selectionStart' in input) {\n        input.selectionStart = start;\n        input.selectionEnd = Math.min(end, input.value.length);\n      } else {\n        setOffsets(input, offsets);\n      }\n    }\n\n    var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;\n    var eventTypes$3 = {\n      select: {\n        phasedRegistrationNames: {\n          bubbled: 'onSelect',\n          captured: 'onSelectCapture'\n        },\n        dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']\n      }\n    };\n    var activeElement$1 = null;\n    var activeElementInst$1 = null;\n    var lastSelection = null;\n    var mouseDown = false;\n    /**\n     * Get an object which is a unique representation of the current selection.\n     *\n     * The return value will not be consistent across nodes or browsers, but\n     * two identical selections on the same node will return identical objects.\n     *\n     * @param {DOMElement} node\n     * @return {object}\n     */\n\n    function getSelection(node) {\n      if ('selectionStart' in node && hasSelectionCapabilities(node)) {\n        return {\n          start: node.selectionStart,\n          end: node.selectionEnd\n        };\n      } else if (window.getSelection) {\n        var selection = window.getSelection();\n        return {\n          anchorNode: selection.anchorNode,\n          anchorOffset: selection.anchorOffset,\n          focusNode: selection.focusNode,\n          focusOffset: selection.focusOffset\n        };\n      }\n    }\n    /**\n     * Poll selection to see whether it's changed.\n     *\n     * @param {object} nativeEvent\n     * @return {?SyntheticEvent}\n     */\n\n\n    function constructSelectEvent(nativeEvent, nativeEventTarget) {\n      // Ensure we have the right element, and that the user is not dragging a\n      // selection (this matches native `select` event behavior). In HTML5, select\n      // fires only on input and textarea thus if there's no focused element we\n      // won't dispatch.\n      if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {\n        return null;\n      } // Only fire when selection has actually changed.\n\n\n      var currentSelection = getSelection(activeElement$1);\n\n      if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n        lastSelection = currentSelection;\n        var syntheticEvent = SyntheticEvent$1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);\n        syntheticEvent.type = 'select';\n        syntheticEvent.target = activeElement$1;\n        accumulateTwoPhaseDispatches(syntheticEvent);\n        return syntheticEvent;\n      }\n\n      return null;\n    }\n    /**\n     * This plugin creates an `onSelect` event that normalizes select events\n     * across form elements.\n     *\n     * Supported elements are:\n     * - input (see `isTextInputElement`)\n     * - textarea\n     * - contentEditable\n     *\n     * This differs from native browser implementations in the following ways:\n     * - Fires on contentEditable fields as well as inputs.\n     * - Fires for collapsed selection.\n     * - Fires after user input.\n     */\n\n\n    var SelectEventPlugin = {\n      eventTypes: eventTypes$3,\n      extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n        var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE ? nativeEventTarget : nativeEventTarget.ownerDocument; // Track whether all listeners exists for this plugin. If none exist, we do\n        // not extract events. See #3639.\n\n        if (!doc || !isListeningToAllDependencies('onSelect', doc)) {\n          return null;\n        }\n\n        var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n        switch (topLevelType) {\n          // Track the input node that has focus.\n          case 'topFocus':\n            if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {\n              activeElement$1 = targetNode;\n              activeElementInst$1 = targetInst;\n              lastSelection = null;\n            }\n\n            break;\n\n          case 'topBlur':\n            activeElement$1 = null;\n            activeElementInst$1 = null;\n            lastSelection = null;\n            break;\n          // Don't fire the event while the user is dragging. This matches the\n          // semantics of the native select event.\n\n          case 'topMouseDown':\n            mouseDown = true;\n            break;\n\n          case 'topContextMenu':\n          case 'topMouseUp':\n            mouseDown = false;\n            return constructSelectEvent(nativeEvent, nativeEventTarget);\n          // Chrome and IE fire non-standard event when selection is changed (and\n          // sometimes when it hasn't). IE's event fires out of order with respect\n          // to key and input events on deletion, so we discard it.\n          //\n          // Firefox doesn't support selectionchange, so check selection status\n          // after each key entry. The selection changes after keydown and before\n          // keyup, but we check on keydown as well in the case of holding down a\n          // key, when multiple keydown events are fired but only one keyup is.\n          // This is also our approach for IE handling, for the reason above.\n\n          case 'topSelectionChange':\n            if (skipSelectionChangeEvent) {\n              break;\n            }\n\n          // falls through\n\n          case 'topKeyDown':\n          case 'topKeyUp':\n            return constructSelectEvent(nativeEvent, nativeEventTarget);\n        }\n\n        return null;\n      }\n    };\n    /**\n     * @interface Event\n     * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n     */\n\n    var AnimationEventInterface = {\n      animationName: null,\n      elapsedTime: null,\n      pseudoElement: null\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticEvent}\n     */\n\n    function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticEvent$1.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);\n    /**\n     * @interface Event\n     * @see http://www.w3.org/TR/clipboard-apis/\n     */\n\n    var ClipboardEventInterface = {\n      clipboardData: function (event) {\n        return 'clipboardData' in event ? event.clipboardData : window.clipboardData;\n      }\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticEvent}\n     */\n\n    function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticEvent$1.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);\n    /**\n     * @interface FocusEvent\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\n     */\n\n    var FocusEventInterface = {\n      relatedTarget: null\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticUIEvent}\n     */\n\n    function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);\n    /**\n     * `charCode` represents the actual \"character code\" and is safe to use with\n     * `String.fromCharCode`. As such, only keys that correspond to printable\n     * characters produce a valid `charCode`, the only exception to this is Enter.\n     * The Tab-key is considered non-printable and does not have a `charCode`,\n     * presumably because it does not produce a tab-character in browsers.\n     *\n     * @param {object} nativeEvent Native browser event.\n     * @return {number} Normalized `charCode` property.\n     */\n\n    function getEventCharCode(nativeEvent) {\n      var charCode;\n      var keyCode = nativeEvent.keyCode;\n\n      if ('charCode' in nativeEvent) {\n        charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`.\n\n        if (charCode === 0 && keyCode === 13) {\n          charCode = 13;\n        }\n      } else {\n        // IE8 does not implement `charCode`, but `keyCode` has the correct value.\n        charCode = keyCode;\n      } // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n      // Must not discard the (non-)printable Enter-key.\n\n\n      if (charCode >= 32 || charCode === 13) {\n        return charCode;\n      }\n\n      return 0;\n    }\n    /**\n     * Normalization of deprecated HTML5 `key` values\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n     */\n\n\n    var normalizeKey = {\n      Esc: 'Escape',\n      Spacebar: ' ',\n      Left: 'ArrowLeft',\n      Up: 'ArrowUp',\n      Right: 'ArrowRight',\n      Down: 'ArrowDown',\n      Del: 'Delete',\n      Win: 'OS',\n      Menu: 'ContextMenu',\n      Apps: 'ContextMenu',\n      Scroll: 'ScrollLock',\n      MozPrintableKey: 'Unidentified'\n    };\n    /**\n     * Translation from legacy `keyCode` to HTML5 `key`\n     * Only special keys supported, all others depend on keyboard layout or browser\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n     */\n\n    var translateToKey = {\n      '8': 'Backspace',\n      '9': 'Tab',\n      '12': 'Clear',\n      '13': 'Enter',\n      '16': 'Shift',\n      '17': 'Control',\n      '18': 'Alt',\n      '19': 'Pause',\n      '20': 'CapsLock',\n      '27': 'Escape',\n      '32': ' ',\n      '33': 'PageUp',\n      '34': 'PageDown',\n      '35': 'End',\n      '36': 'Home',\n      '37': 'ArrowLeft',\n      '38': 'ArrowUp',\n      '39': 'ArrowRight',\n      '40': 'ArrowDown',\n      '45': 'Insert',\n      '46': 'Delete',\n      '112': 'F1',\n      '113': 'F2',\n      '114': 'F3',\n      '115': 'F4',\n      '116': 'F5',\n      '117': 'F6',\n      '118': 'F7',\n      '119': 'F8',\n      '120': 'F9',\n      '121': 'F10',\n      '122': 'F11',\n      '123': 'F12',\n      '144': 'NumLock',\n      '145': 'ScrollLock',\n      '224': 'Meta'\n    };\n    /**\n     * @param {object} nativeEvent Native browser event.\n     * @return {string} Normalized `key` property.\n     */\n\n    function getEventKey(nativeEvent) {\n      if (nativeEvent.key) {\n        // Normalize inconsistent values reported by browsers due to\n        // implementations of a working draft specification.\n        // FireFox implements `key` but returns `MozPrintableKey` for all\n        // printable characters (normalized to `Unidentified`), ignore it.\n        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n\n        if (key !== 'Unidentified') {\n          return key;\n        }\n      } // Browser does not implement `key`, polyfill as much of it as we can.\n\n\n      if (nativeEvent.type === 'keypress') {\n        var charCode = getEventCharCode(nativeEvent); // The enter-key is technically both printable and non-printable and can\n        // thus be captured by `keypress`, no other non-printable key should.\n\n        return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);\n      }\n\n      if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {\n        // While user keyboard layout determines the actual meaning of each\n        // `keyCode` value, almost all function keys have a universal value.\n        return translateToKey[nativeEvent.keyCode] || 'Unidentified';\n      }\n\n      return '';\n    }\n    /**\n     * @interface KeyboardEvent\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\n     */\n\n\n    var KeyboardEventInterface = {\n      key: getEventKey,\n      location: null,\n      ctrlKey: null,\n      shiftKey: null,\n      altKey: null,\n      metaKey: null,\n      repeat: null,\n      locale: null,\n      getModifierState: getEventModifierState,\n      // Legacy Interface\n      charCode: function (event) {\n        // `charCode` is the result of a KeyPress event and represents the value of\n        // the actual printable character.\n        // KeyPress is deprecated, but its replacement is not yet final and not\n        // implemented in any major browser. Only KeyPress has charCode.\n        if (event.type === 'keypress') {\n          return getEventCharCode(event);\n        }\n\n        return 0;\n      },\n      keyCode: function (event) {\n        // `keyCode` is the result of a KeyDown/Up event and represents the value of\n        // physical keyboard key.\n        // The actual meaning of the value depends on the users' keyboard layout\n        // which cannot be detected. Assuming that it is a US keyboard layout\n        // provides a surprisingly accurate mapping for US and European users.\n        // Due to this, it is left to the user to implement at this time.\n        if (event.type === 'keydown' || event.type === 'keyup') {\n          return event.keyCode;\n        }\n\n        return 0;\n      },\n      which: function (event) {\n        // `which` is an alias for either `keyCode` or `charCode` depending on the\n        // type of the event.\n        if (event.type === 'keypress') {\n          return getEventCharCode(event);\n        }\n\n        if (event.type === 'keydown' || event.type === 'keyup') {\n          return event.keyCode;\n        }\n\n        return 0;\n      }\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticUIEvent}\n     */\n\n    function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);\n    /**\n     * @interface DragEvent\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\n     */\n\n    var DragEventInterface = {\n      dataTransfer: null\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticMouseEvent}\n     */\n\n    function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);\n    /**\n     * @interface TouchEvent\n     * @see http://www.w3.org/TR/touch-events/\n     */\n\n    var TouchEventInterface = {\n      touches: null,\n      targetTouches: null,\n      changedTouches: null,\n      altKey: null,\n      metaKey: null,\n      ctrlKey: null,\n      shiftKey: null,\n      getModifierState: getEventModifierState\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticUIEvent}\n     */\n\n    function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);\n    /**\n     * @interface Event\n     * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n     */\n\n    var TransitionEventInterface = {\n      propertyName: null,\n      elapsedTime: null,\n      pseudoElement: null\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticEvent}\n     */\n\n    function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticEvent$1.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);\n    /**\n     * @interface WheelEvent\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\n     */\n\n    var WheelEventInterface = {\n      deltaX: function (event) {\n        return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n        'wheelDeltaX' in event ? -event.wheelDeltaX : 0;\n      },\n      deltaY: function (event) {\n        return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n        'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n        'wheelDelta' in event ? -event.wheelDelta : 0;\n      },\n      deltaZ: null,\n      // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n      // notch on the scroll is always +/- 120, roughly equivalent to pixels.\n      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n      deltaMode: null\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticMouseEvent}\n     */\n\n    function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);\n    /**\n     * Turns\n     * ['abort', ...]\n     * into\n     * eventTypes = {\n     *   'abort': {\n     *     phasedRegistrationNames: {\n     *       bubbled: 'onAbort',\n     *       captured: 'onAbortCapture',\n     *     },\n     *     dependencies: ['topAbort'],\n     *   },\n     *   ...\n     * };\n     * topLevelEventsToDispatchConfig = {\n     *   'topAbort': { sameConfig }\n     * };\n     */\n\n    var eventTypes$4 = {};\n    var topLevelEventsToDispatchConfig = {};\n    ['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'cancel', 'canPlay', 'canPlayThrough', 'click', 'close', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'toggle', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {\n      var capitalizedEvent = event[0].toUpperCase() + event.slice(1);\n      var onEvent = 'on' + capitalizedEvent;\n      var topEvent = 'top' + capitalizedEvent;\n      var type = {\n        phasedRegistrationNames: {\n          bubbled: onEvent,\n          captured: onEvent + 'Capture'\n        },\n        dependencies: [topEvent]\n      };\n      eventTypes$4[event] = type;\n      topLevelEventsToDispatchConfig[topEvent] = type;\n    }); // Only used in DEV for exhaustiveness validation.\n\n    var knownHTMLTopLevelTypes = ['topAbort', 'topCancel', 'topCanPlay', 'topCanPlayThrough', 'topClose', 'topDurationChange', 'topEmptied', 'topEncrypted', 'topEnded', 'topError', 'topInput', 'topInvalid', 'topLoad', 'topLoadedData', 'topLoadedMetadata', 'topLoadStart', 'topPause', 'topPlay', 'topPlaying', 'topProgress', 'topRateChange', 'topReset', 'topSeeked', 'topSeeking', 'topStalled', 'topSubmit', 'topSuspend', 'topTimeUpdate', 'topToggle', 'topVolumeChange', 'topWaiting'];\n    var SimpleEventPlugin = {\n      eventTypes: eventTypes$4,\n      extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n        var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];\n\n        if (!dispatchConfig) {\n          return null;\n        }\n\n        var EventConstructor;\n\n        switch (topLevelType) {\n          case 'topKeyPress':\n            // Firefox creates a keypress event for function keys too. This removes\n            // the unwanted keypress events. Enter is however both printable and\n            // non-printable. One would expect Tab to be as well (but it isn't).\n            if (getEventCharCode(nativeEvent) === 0) {\n              return null;\n            }\n\n          /* falls through */\n\n          case 'topKeyDown':\n          case 'topKeyUp':\n            EventConstructor = SyntheticKeyboardEvent;\n            break;\n\n          case 'topBlur':\n          case 'topFocus':\n            EventConstructor = SyntheticFocusEvent;\n            break;\n\n          case 'topClick':\n            // Firefox creates a click event on right mouse clicks. This removes the\n            // unwanted click events.\n            if (nativeEvent.button === 2) {\n              return null;\n            }\n\n          /* falls through */\n\n          case 'topDoubleClick':\n          case 'topMouseDown':\n          case 'topMouseMove':\n          case 'topMouseUp': // TODO: Disabled elements should not respond to mouse events\n\n          /* falls through */\n\n          case 'topMouseOut':\n          case 'topMouseOver':\n          case 'topContextMenu':\n            EventConstructor = SyntheticMouseEvent;\n            break;\n\n          case 'topDrag':\n          case 'topDragEnd':\n          case 'topDragEnter':\n          case 'topDragExit':\n          case 'topDragLeave':\n          case 'topDragOver':\n          case 'topDragStart':\n          case 'topDrop':\n            EventConstructor = SyntheticDragEvent;\n            break;\n\n          case 'topTouchCancel':\n          case 'topTouchEnd':\n          case 'topTouchMove':\n          case 'topTouchStart':\n            EventConstructor = SyntheticTouchEvent;\n            break;\n\n          case 'topAnimationEnd':\n          case 'topAnimationIteration':\n          case 'topAnimationStart':\n            EventConstructor = SyntheticAnimationEvent;\n            break;\n\n          case 'topTransitionEnd':\n            EventConstructor = SyntheticTransitionEvent;\n            break;\n\n          case 'topScroll':\n            EventConstructor = SyntheticUIEvent;\n            break;\n\n          case 'topWheel':\n            EventConstructor = SyntheticWheelEvent;\n            break;\n\n          case 'topCopy':\n          case 'topCut':\n          case 'topPaste':\n            EventConstructor = SyntheticClipboardEvent;\n            break;\n\n          default:\n            {\n              if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {\n                warning(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);\n              }\n            } // HTML Events\n            // @see http://www.w3.org/TR/html5/index.html#events-0\n\n            EventConstructor = SyntheticEvent$1;\n            break;\n        }\n\n        var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);\n        accumulateTwoPhaseDispatches(event);\n        return event;\n      }\n    };\n    setHandleTopLevel(handleTopLevel);\n    /**\n     * Inject modules for resolving DOM hierarchy and plugin ordering.\n     */\n\n    injection$1.injectEventPluginOrder(DOMEventPluginOrder);\n    injection$2.injectComponentTree(ReactDOMComponentTree);\n    /**\n     * Some important event plugins included by default (without having to require\n     * them).\n     */\n\n    injection$1.injectEventPluginsByName({\n      SimpleEventPlugin: SimpleEventPlugin,\n      EnterLeaveEventPlugin: EnterLeaveEventPlugin,\n      ChangeEventPlugin: ChangeEventPlugin,\n      SelectEventPlugin: SelectEventPlugin,\n      BeforeInputEventPlugin: BeforeInputEventPlugin\n    });\n    var enableAsyncSubtreeAPI = true;\n    var enableAsyncSchedulingByDefaultInReactDOM = false; // Exports React.Fragment\n\n    var enableReactFragment = false; // Exports ReactDOM.createRoot\n\n    var enableCreateRoot = false;\n    var enableUserTimingAPI = true; // Mutating mode (React DOM, React ART, React Native):\n\n    var enableMutatingReconciler = true; // Experimental noop mode (currently unused):\n\n    var enableNoopReconciler = false; // Experimental persistent mode (CS):\n\n    var enablePersistentReconciler = false; // Only used in www builds.\n\n    var valueStack = [];\n    {\n      var fiberStack = [];\n    }\n    var index = -1;\n\n    function createCursor(defaultValue) {\n      return {\n        current: defaultValue\n      };\n    }\n\n    function pop(cursor, fiber) {\n      if (index < 0) {\n        {\n          warning(false, 'Unexpected pop.');\n        }\n        return;\n      }\n\n      {\n        if (fiber !== fiberStack[index]) {\n          warning(false, 'Unexpected Fiber popped.');\n        }\n      }\n      cursor.current = valueStack[index];\n      valueStack[index] = null;\n      {\n        fiberStack[index] = null;\n      }\n      index--;\n    }\n\n    function push(cursor, value, fiber) {\n      index++;\n      valueStack[index] = cursor.current;\n      {\n        fiberStack[index] = fiber;\n      }\n      cursor.current = value;\n    }\n\n    function reset$1() {\n      while (index > -1) {\n        valueStack[index] = null;\n        {\n          fiberStack[index] = null;\n        }\n        index--;\n      }\n    }\n\n    var describeComponentFrame = function (name, source, ownerName) {\n      return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n    };\n\n    function describeFiber(fiber) {\n      switch (fiber.tag) {\n        case IndeterminateComponent:\n        case FunctionalComponent:\n        case ClassComponent:\n        case HostComponent:\n          var owner = fiber._debugOwner;\n          var source = fiber._debugSource;\n          var name = getComponentName(fiber);\n          var ownerName = null;\n\n          if (owner) {\n            ownerName = getComponentName(owner);\n          }\n\n          return describeComponentFrame(name, source, ownerName);\n\n        default:\n          return '';\n      }\n    } // This function can only be called with a work-in-progress fiber and\n    // only during begin or complete phase. Do not call it under any other\n    // circumstances.\n\n\n    function getStackAddendumByWorkInProgressFiber(workInProgress) {\n      var info = '';\n      var node = workInProgress;\n\n      do {\n        info += describeFiber(node); // Otherwise this return pointer might point to the wrong tree:\n\n        node = node['return'];\n      } while (node);\n\n      return info;\n    }\n\n    function getCurrentFiberOwnerName() {\n      {\n        var fiber = ReactDebugCurrentFiber.current;\n\n        if (fiber === null) {\n          return null;\n        }\n\n        var owner = fiber._debugOwner;\n\n        if (owner !== null && typeof owner !== 'undefined') {\n          return getComponentName(owner);\n        }\n      }\n      return null;\n    }\n\n    function getCurrentFiberStackAddendum() {\n      {\n        var fiber = ReactDebugCurrentFiber.current;\n\n        if (fiber === null) {\n          return null;\n        } // Safe because if current fiber exists, we are reconciling,\n        // and it is guaranteed to be the work-in-progress version.\n\n\n        return getStackAddendumByWorkInProgressFiber(fiber);\n      }\n      return null;\n    }\n\n    function resetCurrentFiber() {\n      ReactDebugCurrentFrame.getCurrentStack = null;\n      ReactDebugCurrentFiber.current = null;\n      ReactDebugCurrentFiber.phase = null;\n    }\n\n    function setCurrentFiber(fiber) {\n      ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;\n      ReactDebugCurrentFiber.current = fiber;\n      ReactDebugCurrentFiber.phase = null;\n    }\n\n    function setCurrentPhase(phase) {\n      ReactDebugCurrentFiber.phase = phase;\n    }\n\n    var ReactDebugCurrentFiber = {\n      current: null,\n      phase: null,\n      resetCurrentFiber: resetCurrentFiber,\n      setCurrentFiber: setCurrentFiber,\n      setCurrentPhase: setCurrentPhase,\n      getCurrentFiberOwnerName: getCurrentFiberOwnerName,\n      getCurrentFiberStackAddendum: getCurrentFiberStackAddendum\n    }; // Prefix measurements so that it's possible to filter them.\n    // Longer prefixes are hard to read in DevTools.\n\n    var reactEmoji = '\\u269B';\n    var warningEmoji = '\\u26D4';\n    var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function'; // Keep track of current fiber so that we know the path to unwind on pause.\n    // TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\n\n    var currentFiber = null; // If we're in the middle of user code, which fiber and method is it?\n    // Reusing `currentFiber` would be confusing for this because user code fiber\n    // can change during commit phase too, but we don't need to unwind it (since\n    // lifecycles in the commit phase don't resemble a tree).\n\n    var currentPhase = null;\n    var currentPhaseFiber = null; // Did lifecycle hook schedule an update? This is often a performance problem,\n    // so we will keep track of it, and include it in the report.\n    // Track commits caused by cascading updates.\n\n    var isCommitting = false;\n    var hasScheduledUpdateInCurrentCommit = false;\n    var hasScheduledUpdateInCurrentPhase = false;\n    var commitCountInCurrentWorkLoop = 0;\n    var effectCountInCurrentCommit = 0;\n    var isWaitingForCallback = false; // During commits, we only show a measurement once per method name\n    // to avoid stretch the commit phase with measurement overhead.\n\n    var labelsInCurrentCommit = new Set();\n\n    var formatMarkName = function (markName) {\n      return reactEmoji + ' ' + markName;\n    };\n\n    var formatLabel = function (label, warning$$1) {\n      var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';\n      var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';\n      return '' + prefix + label + suffix;\n    };\n\n    var beginMark = function (markName) {\n      performance.mark(formatMarkName(markName));\n    };\n\n    var clearMark = function (markName) {\n      performance.clearMarks(formatMarkName(markName));\n    };\n\n    var endMark = function (label, markName, warning$$1) {\n      var formattedMarkName = formatMarkName(markName);\n      var formattedLabel = formatLabel(label, warning$$1);\n\n      try {\n        performance.measure(formattedLabel, formattedMarkName);\n      } catch (err) {} // If previous mark was missing for some reason, this will throw.\n      // This could only happen if React crashed in an unexpected place earlier.\n      // Don't pile on with more errors.\n      // Clear marks immediately to avoid growing buffer.\n\n\n      performance.clearMarks(formattedMarkName);\n      performance.clearMeasures(formattedLabel);\n    };\n\n    var getFiberMarkName = function (label, debugID) {\n      return label + ' (#' + debugID + ')';\n    };\n\n    var getFiberLabel = function (componentName, isMounted, phase) {\n      if (phase === null) {\n        // These are composite component total time measurements.\n        return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';\n      } else {\n        // Composite component methods.\n        return componentName + '.' + phase;\n      }\n    };\n\n    var beginFiberMark = function (fiber, phase) {\n      var componentName = getComponentName(fiber) || 'Unknown';\n      var debugID = fiber._debugID;\n      var isMounted = fiber.alternate !== null;\n      var label = getFiberLabel(componentName, isMounted, phase);\n\n      if (isCommitting && labelsInCurrentCommit.has(label)) {\n        // During the commit phase, we don't show duplicate labels because\n        // there is a fixed overhead for every measurement, and we don't\n        // want to stretch the commit phase beyond necessary.\n        return false;\n      }\n\n      labelsInCurrentCommit.add(label);\n      var markName = getFiberMarkName(label, debugID);\n      beginMark(markName);\n      return true;\n    };\n\n    var clearFiberMark = function (fiber, phase) {\n      var componentName = getComponentName(fiber) || 'Unknown';\n      var debugID = fiber._debugID;\n      var isMounted = fiber.alternate !== null;\n      var label = getFiberLabel(componentName, isMounted, phase);\n      var markName = getFiberMarkName(label, debugID);\n      clearMark(markName);\n    };\n\n    var endFiberMark = function (fiber, phase, warning$$1) {\n      var componentName = getComponentName(fiber) || 'Unknown';\n      var debugID = fiber._debugID;\n      var isMounted = fiber.alternate !== null;\n      var label = getFiberLabel(componentName, isMounted, phase);\n      var markName = getFiberMarkName(label, debugID);\n      endMark(label, markName, warning$$1);\n    };\n\n    var shouldIgnoreFiber = function (fiber) {\n      // Host components should be skipped in the timeline.\n      // We could check typeof fiber.type, but does this work with RN?\n      switch (fiber.tag) {\n        case HostRoot:\n        case HostComponent:\n        case HostText:\n        case HostPortal:\n        case ReturnComponent:\n        case Fragment:\n          return true;\n\n        default:\n          return false;\n      }\n    };\n\n    var clearPendingPhaseMeasurement = function () {\n      if (currentPhase !== null && currentPhaseFiber !== null) {\n        clearFiberMark(currentPhaseFiber, currentPhase);\n      }\n\n      currentPhaseFiber = null;\n      currentPhase = null;\n      hasScheduledUpdateInCurrentPhase = false;\n    };\n\n    var pauseTimers = function () {\n      // Stops all currently active measurements so that they can be resumed\n      // if we continue in a later deferred loop from the same unit of work.\n      var fiber = currentFiber;\n\n      while (fiber) {\n        if (fiber._debugIsCurrentlyTiming) {\n          endFiberMark(fiber, null, null);\n        }\n\n        fiber = fiber['return'];\n      }\n    };\n\n    var resumeTimersRecursively = function (fiber) {\n      if (fiber['return'] !== null) {\n        resumeTimersRecursively(fiber['return']);\n      }\n\n      if (fiber._debugIsCurrentlyTiming) {\n        beginFiberMark(fiber, null);\n      }\n    };\n\n    var resumeTimers = function () {\n      // Resumes all measurements that were active during the last deferred loop.\n      if (currentFiber !== null) {\n        resumeTimersRecursively(currentFiber);\n      }\n    };\n\n    function recordEffect() {\n      if (enableUserTimingAPI) {\n        effectCountInCurrentCommit++;\n      }\n    }\n\n    function recordScheduleUpdate() {\n      if (enableUserTimingAPI) {\n        if (isCommitting) {\n          hasScheduledUpdateInCurrentCommit = true;\n        }\n\n        if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n          hasScheduledUpdateInCurrentPhase = true;\n        }\n      }\n    }\n\n    function startRequestCallbackTimer() {\n      if (enableUserTimingAPI) {\n        if (supportsUserTiming && !isWaitingForCallback) {\n          isWaitingForCallback = true;\n          beginMark('(Waiting for async callback...)');\n        }\n      }\n    }\n\n    function stopRequestCallbackTimer(didExpire) {\n      if (enableUserTimingAPI) {\n        if (supportsUserTiming) {\n          isWaitingForCallback = false;\n          var warning$$1 = didExpire ? 'React was blocked by main thread' : null;\n          endMark('(Waiting for async callback...)', '(Waiting for async callback...)', warning$$1);\n        }\n      }\n    }\n\n    function startWorkTimer(fiber) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n          return;\n        } // If we pause, this is the fiber to unwind from.\n\n\n        currentFiber = fiber;\n\n        if (!beginFiberMark(fiber, null)) {\n          return;\n        }\n\n        fiber._debugIsCurrentlyTiming = true;\n      }\n    }\n\n    function cancelWorkTimer(fiber) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n          return;\n        } // Remember we shouldn't complete measurement for this fiber.\n        // Otherwise flamechart will be deep even for small updates.\n\n\n        fiber._debugIsCurrentlyTiming = false;\n        clearFiberMark(fiber, null);\n      }\n    }\n\n    function stopWorkTimer(fiber) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n          return;\n        } // If we pause, its parent is the fiber to unwind from.\n\n\n        currentFiber = fiber['return'];\n\n        if (!fiber._debugIsCurrentlyTiming) {\n          return;\n        }\n\n        fiber._debugIsCurrentlyTiming = false;\n        endFiberMark(fiber, null, null);\n      }\n    }\n\n    function stopFailedWorkTimer(fiber) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n          return;\n        } // If we pause, its parent is the fiber to unwind from.\n\n\n        currentFiber = fiber['return'];\n\n        if (!fiber._debugIsCurrentlyTiming) {\n          return;\n        }\n\n        fiber._debugIsCurrentlyTiming = false;\n        var warning$$1 = 'An error was thrown inside this error boundary';\n        endFiberMark(fiber, null, warning$$1);\n      }\n    }\n\n    function startPhaseTimer(fiber, phase) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        clearPendingPhaseMeasurement();\n\n        if (!beginFiberMark(fiber, phase)) {\n          return;\n        }\n\n        currentPhaseFiber = fiber;\n        currentPhase = phase;\n      }\n    }\n\n    function stopPhaseTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        if (currentPhase !== null && currentPhaseFiber !== null) {\n          var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n          endFiberMark(currentPhaseFiber, currentPhase, warning$$1);\n        }\n\n        currentPhase = null;\n        currentPhaseFiber = null;\n      }\n    }\n\n    function startWorkLoopTimer(nextUnitOfWork) {\n      if (enableUserTimingAPI) {\n        currentFiber = nextUnitOfWork;\n\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        commitCountInCurrentWorkLoop = 0; // This is top level call.\n        // Any other measurements are performed within.\n\n        beginMark('(React Tree Reconciliation)'); // Resume any measurements that were in progress during the last loop.\n\n        resumeTimers();\n      }\n    }\n\n    function stopWorkLoopTimer(interruptedBy) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        var warning$$1 = null;\n\n        if (interruptedBy !== null) {\n          if (interruptedBy.tag === HostRoot) {\n            warning$$1 = 'A top-level update interrupted the previous render';\n          } else {\n            var componentName = getComponentName(interruptedBy) || 'Unknown';\n            warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';\n          }\n        } else if (commitCountInCurrentWorkLoop > 1) {\n          warning$$1 = 'There were cascading updates';\n        }\n\n        commitCountInCurrentWorkLoop = 0; // Pause any measurements until the next loop.\n\n        pauseTimers();\n        endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);\n      }\n    }\n\n    function startCommitTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        isCommitting = true;\n        hasScheduledUpdateInCurrentCommit = false;\n        labelsInCurrentCommit.clear();\n        beginMark('(Committing Changes)');\n      }\n    }\n\n    function stopCommitTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        var warning$$1 = null;\n\n        if (hasScheduledUpdateInCurrentCommit) {\n          warning$$1 = 'Lifecycle hook scheduled a cascading update';\n        } else if (commitCountInCurrentWorkLoop > 0) {\n          warning$$1 = 'Caused by a cascading update in earlier commit';\n        }\n\n        hasScheduledUpdateInCurrentCommit = false;\n        commitCountInCurrentWorkLoop++;\n        isCommitting = false;\n        labelsInCurrentCommit.clear();\n        endMark('(Committing Changes)', '(Committing Changes)', warning$$1);\n      }\n    }\n\n    function startCommitHostEffectsTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        effectCountInCurrentCommit = 0;\n        beginMark('(Committing Host Effects)');\n      }\n    }\n\n    function stopCommitHostEffectsTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        var count = effectCountInCurrentCommit;\n        effectCountInCurrentCommit = 0;\n        endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);\n      }\n    }\n\n    function startCommitLifeCyclesTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        effectCountInCurrentCommit = 0;\n        beginMark('(Calling Lifecycle Methods)');\n      }\n    }\n\n    function stopCommitLifeCyclesTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        var count = effectCountInCurrentCommit;\n        effectCountInCurrentCommit = 0;\n        endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);\n      }\n    }\n\n    {\n      var warnedAboutMissingGetChildContext = {};\n    } // A cursor to the current merged context object on the stack.\n\n    var contextStackCursor = createCursor(emptyObject); // A cursor to a boolean indicating whether the context has changed.\n\n    var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.\n    // We use this to get access to the parent context after we have already\n    // pushed the next context provider, and now need to merge their contexts.\n\n    var previousContext = emptyObject;\n\n    function getUnmaskedContext(workInProgress) {\n      var hasOwnContext = isContextProvider(workInProgress);\n\n      if (hasOwnContext) {\n        // If the fiber is a context provider itself, when we read its context\n        // we have already pushed its own child context on the stack. A context\n        // provider should not \"see\" its own child context. Therefore we read the\n        // previous (parent) context instead for a context provider.\n        return previousContext;\n      }\n\n      return contextStackCursor.current;\n    }\n\n    function cacheContext(workInProgress, unmaskedContext, maskedContext) {\n      var instance = workInProgress.stateNode;\n      instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n      instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n    }\n\n    function getMaskedContext(workInProgress, unmaskedContext) {\n      var type = workInProgress.type;\n      var contextTypes = type.contextTypes;\n\n      if (!contextTypes) {\n        return emptyObject;\n      } // Avoid recreating masked context unless unmasked context has changed.\n      // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n      // This may trigger infinite loops if componentWillReceiveProps calls setState.\n\n\n      var instance = workInProgress.stateNode;\n\n      if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n        return instance.__reactInternalMemoizedMaskedChildContext;\n      }\n\n      var context = {};\n\n      for (var key in contextTypes) {\n        context[key] = unmaskedContext[key];\n      }\n\n      {\n        var name = getComponentName(workInProgress) || 'Unknown';\n        checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n      } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n      // Context is created before the class component is instantiated so check for instance.\n\n      if (instance) {\n        cacheContext(workInProgress, unmaskedContext, context);\n      }\n\n      return context;\n    }\n\n    function hasContextChanged() {\n      return didPerformWorkStackCursor.current;\n    }\n\n    function isContextConsumer(fiber) {\n      return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n    }\n\n    function isContextProvider(fiber) {\n      return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n    }\n\n    function popContextProvider(fiber) {\n      if (!isContextProvider(fiber)) {\n        return;\n      }\n\n      pop(didPerformWorkStackCursor, fiber);\n      pop(contextStackCursor, fiber);\n    }\n\n    function popTopLevelContextObject(fiber) {\n      pop(didPerformWorkStackCursor, fiber);\n      pop(contextStackCursor, fiber);\n    }\n\n    function pushTopLevelContextObject(fiber, context, didChange) {\n      !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      push(contextStackCursor, context, fiber);\n      push(didPerformWorkStackCursor, didChange, fiber);\n    }\n\n    function processChildContext(fiber, parentContext) {\n      var instance = fiber.stateNode;\n      var childContextTypes = fiber.type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n      // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n\n      if (typeof instance.getChildContext !== 'function') {\n        {\n          var componentName = getComponentName(fiber) || 'Unknown';\n\n          if (!warnedAboutMissingGetChildContext[componentName]) {\n            warnedAboutMissingGetChildContext[componentName] = true;\n            warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n          }\n        }\n        return parentContext;\n      }\n\n      var childContext = void 0;\n      {\n        ReactDebugCurrentFiber.setCurrentPhase('getChildContext');\n      }\n      startPhaseTimer(fiber, 'getChildContext');\n      childContext = instance.getChildContext();\n      stopPhaseTimer();\n      {\n        ReactDebugCurrentFiber.setCurrentPhase(null);\n      }\n\n      for (var contextKey in childContext) {\n        !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;\n      }\n\n      {\n        var name = getComponentName(fiber) || 'Unknown';\n        checkPropTypes(childContextTypes, childContext, 'child context', name, // In practice, there is one case in which we won't get a stack. It's when\n        // somebody calls unstable_renderSubtreeIntoContainer() and we process\n        // context from the parent component instance. The stack will be missing\n        // because it's outside of the reconciliation, and so the pointer has not\n        // been set. This is rare and doesn't matter. We'll also remove that API.\n        ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n      }\n      return _assign({}, parentContext, childContext);\n    }\n\n    function pushContextProvider(workInProgress) {\n      if (!isContextProvider(workInProgress)) {\n        return false;\n      }\n\n      var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.\n      // If the instance does not exist yet, we will push null at first,\n      // and replace it on the stack later when invalidating the context.\n\n      var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject; // Remember the parent context so we can merge with it later.\n      // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n\n      previousContext = contextStackCursor.current;\n      push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n      push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n      return true;\n    }\n\n    function invalidateContextProvider(workInProgress, didChange) {\n      var instance = workInProgress.stateNode;\n      !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n      if (didChange) {\n        // Merge parent and own context.\n        // Skip this if we're not updating due to sCU.\n        // This avoids unnecessarily recomputing memoized values.\n        var mergedContext = processChildContext(workInProgress, previousContext);\n        instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.\n        // It is important to unwind the context in the reverse order.\n\n        pop(didPerformWorkStackCursor, workInProgress);\n        pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.\n\n        push(contextStackCursor, mergedContext, workInProgress);\n        push(didPerformWorkStackCursor, didChange, workInProgress);\n      } else {\n        pop(didPerformWorkStackCursor, workInProgress);\n        push(didPerformWorkStackCursor, didChange, workInProgress);\n      }\n    }\n\n    function resetContext() {\n      previousContext = emptyObject;\n      contextStackCursor.current = emptyObject;\n      didPerformWorkStackCursor.current = false;\n    }\n\n    function findCurrentUnmaskedContext(fiber) {\n      // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n      // makes sense elsewhere\n      !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      var node = fiber;\n\n      while (node.tag !== HostRoot) {\n        if (isContextProvider(node)) {\n          return node.stateNode.__reactInternalMemoizedMergedChildContext;\n        }\n\n        var parent = node['return'];\n        !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        node = parent;\n      }\n\n      return node.stateNode.context;\n    }\n\n    var NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax\n\n    var Sync = 1;\n    var Never = 2147483647; // Max int32: Math.pow(2, 31) - 1\n\n    var UNIT_SIZE = 10;\n    var MAGIC_NUMBER_OFFSET = 2; // 1 unit of expiration time represents 10ms.\n\n    function msToExpirationTime(ms) {\n      // Always add an offset so that we don't clash with the magic number for NoWork.\n      return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;\n    }\n\n    function ceiling(num, precision) {\n      return ((num / precision | 0) + 1) * precision;\n    }\n\n    function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n      return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\n    }\n\n    var NoContext = 0;\n    var AsyncUpdates = 1;\n    {\n      var hasBadMapPolyfill = false;\n\n      try {\n        var nonExtensibleObject = Object.preventExtensions({});\n        /* eslint-disable no-new */\n\n        new Map([[nonExtensibleObject, null]]);\n        new Set([nonExtensibleObject]);\n        /* eslint-enable no-new */\n      } catch (e) {\n        // TODO: Consider warning about bad polyfills\n        hasBadMapPolyfill = true;\n      }\n    } // A Fiber is work on a Component that needs to be done or was done. There can\n    // be more than one per component.\n\n    {\n      var debugCounter = 1;\n    }\n\n    function FiberNode(tag, key, internalContextTag) {\n      // Instance\n      this.tag = tag;\n      this.key = key;\n      this.type = null;\n      this.stateNode = null; // Fiber\n\n      this['return'] = null;\n      this.child = null;\n      this.sibling = null;\n      this.index = 0;\n      this.ref = null;\n      this.pendingProps = null;\n      this.memoizedProps = null;\n      this.updateQueue = null;\n      this.memoizedState = null;\n      this.internalContextTag = internalContextTag; // Effects\n\n      this.effectTag = NoEffect;\n      this.nextEffect = null;\n      this.firstEffect = null;\n      this.lastEffect = null;\n      this.expirationTime = NoWork;\n      this.alternate = null;\n      {\n        this._debugID = debugCounter++;\n        this._debugSource = null;\n        this._debugOwner = null;\n        this._debugIsCurrentlyTiming = false;\n\n        if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n          Object.preventExtensions(this);\n        }\n      }\n    } // This is a constructor function, rather than a POJO constructor, still\n    // please ensure we do the following:\n    // 1) Nobody should add any instance methods on this. Instance methods can be\n    //    more difficult to predict when they get optimized and they are almost\n    //    never inlined properly in static compilers.\n    // 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n    //    always know when it is a fiber.\n    // 3) We might want to experiment with using numeric keys since they are easier\n    //    to optimize in a non-JIT environment.\n    // 4) We can easily go from a constructor to a createFiber object literal if that\n    //    is faster.\n    // 5) It should be easy to port this to a C struct and keep a C implementation\n    //    compatible.\n\n\n    var createFiber = function (tag, key, internalContextTag) {\n      // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n      return new FiberNode(tag, key, internalContextTag);\n    };\n\n    function shouldConstruct(Component) {\n      return !!(Component.prototype && Component.prototype.isReactComponent);\n    } // This is used to create an alternate fiber to do work on.\n\n\n    function createWorkInProgress(current, pendingProps, expirationTime) {\n      var workInProgress = current.alternate;\n\n      if (workInProgress === null) {\n        // We use a double buffering pooling technique because we know that we'll\n        // only ever need at most two versions of a tree. We pool the \"other\" unused\n        // node that we're free to reuse. This is lazily created to avoid allocating\n        // extra objects for things that are never updated. It also allow us to\n        // reclaim the extra memory if needed.\n        workInProgress = createFiber(current.tag, current.key, current.internalContextTag);\n        workInProgress.type = current.type;\n        workInProgress.stateNode = current.stateNode;\n        {\n          // DEV-only fields\n          workInProgress._debugID = current._debugID;\n          workInProgress._debugSource = current._debugSource;\n          workInProgress._debugOwner = current._debugOwner;\n        }\n        workInProgress.alternate = current;\n        current.alternate = workInProgress;\n      } else {\n        // We already have an alternate.\n        // Reset the effect tag.\n        workInProgress.effectTag = NoEffect; // The effect list is no longer valid.\n\n        workInProgress.nextEffect = null;\n        workInProgress.firstEffect = null;\n        workInProgress.lastEffect = null;\n      }\n\n      workInProgress.expirationTime = expirationTime;\n      workInProgress.pendingProps = pendingProps;\n      workInProgress.child = current.child;\n      workInProgress.memoizedProps = current.memoizedProps;\n      workInProgress.memoizedState = current.memoizedState;\n      workInProgress.updateQueue = current.updateQueue; // These will be overridden during the parent's reconciliation\n\n      workInProgress.sibling = current.sibling;\n      workInProgress.index = current.index;\n      workInProgress.ref = current.ref;\n      return workInProgress;\n    }\n\n    function createHostRootFiber() {\n      var fiber = createFiber(HostRoot, null, NoContext);\n      return fiber;\n    }\n\n    function createFiberFromElement(element, internalContextTag, expirationTime) {\n      var owner = null;\n      {\n        owner = element._owner;\n      }\n      var fiber = void 0;\n      var type = element.type,\n          key = element.key;\n\n      if (typeof type === 'function') {\n        fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);\n        fiber.type = type;\n        fiber.pendingProps = element.props;\n      } else if (typeof type === 'string') {\n        fiber = createFiber(HostComponent, key, internalContextTag);\n        fiber.type = type;\n        fiber.pendingProps = element.props;\n      } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {\n        // Currently assumed to be a continuation and therefore is a fiber already.\n        // TODO: The yield system is currently broken for updates in some cases.\n        // The reified yield stores a fiber, but we don't know which fiber that is;\n        // the current or a workInProgress? When the continuation gets rendered here\n        // we don't know if we can reuse that fiber or if we need to clone it.\n        // There is probably a clever way to restructure this.\n        fiber = type;\n        fiber.pendingProps = element.props;\n      } else {\n        var info = '';\n        {\n          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n            info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n          }\n\n          var ownerName = owner ? getComponentName(owner) : null;\n\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n        }\n        invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);\n      }\n\n      {\n        fiber._debugSource = element._source;\n        fiber._debugOwner = element._owner;\n      }\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromFragment(elements, internalContextTag, expirationTime, key) {\n      var fiber = createFiber(Fragment, key, internalContextTag);\n      fiber.pendingProps = elements;\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromText(content, internalContextTag, expirationTime) {\n      var fiber = createFiber(HostText, null, internalContextTag);\n      fiber.pendingProps = content;\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromHostInstanceForDeletion() {\n      var fiber = createFiber(HostComponent, null, NoContext);\n      fiber.type = 'DELETED';\n      return fiber;\n    }\n\n    function createFiberFromCall(call, internalContextTag, expirationTime) {\n      var fiber = createFiber(CallComponent, call.key, internalContextTag);\n      fiber.type = call.handler;\n      fiber.pendingProps = call;\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromReturn(returnNode, internalContextTag, expirationTime) {\n      var fiber = createFiber(ReturnComponent, null, internalContextTag);\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromPortal(portal, internalContextTag, expirationTime) {\n      var fiber = createFiber(HostPortal, portal.key, internalContextTag);\n      fiber.pendingProps = portal.children || [];\n      fiber.expirationTime = expirationTime;\n      fiber.stateNode = {\n        containerInfo: portal.containerInfo,\n        pendingChildren: null,\n        // Used by persistent updates\n        implementation: portal.implementation\n      };\n      return fiber;\n    }\n\n    function createFiberRoot(containerInfo, hydrate) {\n      // Cyclic construction. This cheats the type system right now because\n      // stateNode is any.\n      var uninitializedFiber = createHostRootFiber();\n      var root = {\n        current: uninitializedFiber,\n        containerInfo: containerInfo,\n        pendingChildren: null,\n        remainingExpirationTime: NoWork,\n        isReadyForCommit: false,\n        finishedWork: null,\n        context: null,\n        pendingContext: null,\n        hydrate: hydrate,\n        nextScheduledRoot: null\n      };\n      uninitializedFiber.stateNode = root;\n      return root;\n    }\n\n    var onCommitFiberRoot = null;\n    var onCommitFiberUnmount = null;\n    var hasLoggedError = false;\n\n    function catchErrors(fn) {\n      return function (arg) {\n        try {\n          return fn(arg);\n        } catch (err) {\n          if (true && !hasLoggedError) {\n            hasLoggedError = true;\n            warning(false, 'React DevTools encountered an error: %s', err);\n          }\n        }\n      };\n    }\n\n    function injectInternals(internals) {\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n        // No DevTools\n        return false;\n      }\n\n      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n      if (hook.isDisabled) {\n        // This isn't a real property on the hook, but it can be set to opt out\n        // of DevTools integration and associated warnings and logs.\n        // https://github.com/facebook/react/issues/3877\n        return true;\n      }\n\n      if (!hook.supportsFiber) {\n        {\n          warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');\n        } // DevTools exists, even though it doesn't support Fiber.\n\n        return true;\n      }\n\n      try {\n        var rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.\n\n        onCommitFiberRoot = catchErrors(function (root) {\n          return hook.onCommitFiberRoot(rendererID, root);\n        });\n        onCommitFiberUnmount = catchErrors(function (fiber) {\n          return hook.onCommitFiberUnmount(rendererID, fiber);\n        });\n      } catch (err) {\n        // Catch all errors because it is unsafe to throw during initialization.\n        {\n          warning(false, 'React DevTools encountered an error: %s.', err);\n        }\n      } // DevTools exists\n\n\n      return true;\n    }\n\n    function onCommitRoot(root) {\n      if (typeof onCommitFiberRoot === 'function') {\n        onCommitFiberRoot(root);\n      }\n    }\n\n    function onCommitUnmount(fiber) {\n      if (typeof onCommitFiberUnmount === 'function') {\n        onCommitFiberUnmount(fiber);\n      }\n    }\n\n    {\n      var didWarnUpdateInsideUpdate = false;\n    } // Callbacks are not validated until invocation\n    // Singly linked-list of updates. When an update is scheduled, it is added to\n    // the queue of the current fiber and the work-in-progress fiber. The two queues\n    // are separate but they share a persistent structure.\n    //\n    // During reconciliation, updates are removed from the work-in-progress fiber,\n    // but they remain on the current fiber. That ensures that if a work-in-progress\n    // is aborted, the aborted updates are recovered by cloning from current.\n    //\n    // The work-in-progress queue is always a subset of the current queue.\n    //\n    // When the tree is committed, the work-in-progress becomes the current.\n\n    function createUpdateQueue(baseState) {\n      var queue = {\n        baseState: baseState,\n        expirationTime: NoWork,\n        first: null,\n        last: null,\n        callbackList: null,\n        hasForceUpdate: false,\n        isInitialized: false\n      };\n      {\n        queue.isProcessing = false;\n      }\n      return queue;\n    }\n\n    function insertUpdateIntoQueue(queue, update) {\n      // Append the update to the end of the list.\n      if (queue.last === null) {\n        // Queue is empty\n        queue.first = queue.last = update;\n      } else {\n        queue.last.next = update;\n        queue.last = update;\n      }\n\n      if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {\n        queue.expirationTime = update.expirationTime;\n      }\n    }\n\n    function insertUpdateIntoFiber(fiber, update) {\n      // We'll have at least one and at most two distinct update queues.\n      var alternateFiber = fiber.alternate;\n      var queue1 = fiber.updateQueue;\n\n      if (queue1 === null) {\n        // TODO: We don't know what the base state will be until we begin work.\n        // It depends on which fiber is the next current. Initialize with an empty\n        // base state, then set to the memoizedState when rendering. Not super\n        // happy with this approach.\n        queue1 = fiber.updateQueue = createUpdateQueue(null);\n      }\n\n      var queue2 = void 0;\n\n      if (alternateFiber !== null) {\n        queue2 = alternateFiber.updateQueue;\n\n        if (queue2 === null) {\n          queue2 = alternateFiber.updateQueue = createUpdateQueue(null);\n        }\n      } else {\n        queue2 = null;\n      }\n\n      queue2 = queue2 !== queue1 ? queue2 : null; // Warn if an update is scheduled from inside an updater function.\n\n      {\n        if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {\n          warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n          didWarnUpdateInsideUpdate = true;\n        }\n      } // If there's only one queue, add the update to that queue and exit.\n\n      if (queue2 === null) {\n        insertUpdateIntoQueue(queue1, update);\n        return;\n      } // If either queue is empty, we need to add to both queues.\n\n\n      if (queue1.last === null || queue2.last === null) {\n        insertUpdateIntoQueue(queue1, update);\n        insertUpdateIntoQueue(queue2, update);\n        return;\n      } // If both lists are not empty, the last update is the same for both lists\n      // because of structural sharing. So, we should only append to one of\n      // the lists.\n\n\n      insertUpdateIntoQueue(queue1, update); // But we still need to update the `last` pointer of queue2.\n\n      queue2.last = update;\n    }\n\n    function getUpdateExpirationTime(fiber) {\n      if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {\n        return NoWork;\n      }\n\n      var updateQueue = fiber.updateQueue;\n\n      if (updateQueue === null) {\n        return NoWork;\n      }\n\n      return updateQueue.expirationTime;\n    }\n\n    function getStateFromUpdate(update, instance, prevState, props) {\n      var partialState = update.partialState;\n\n      if (typeof partialState === 'function') {\n        var updateFn = partialState;\n        return updateFn.call(instance, prevState, props);\n      } else {\n        return partialState;\n      }\n    }\n\n    function processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {\n      if (current !== null && current.updateQueue === queue) {\n        // We need to create a work-in-progress queue, by cloning the current queue.\n        var currentQueue = queue;\n        queue = workInProgress.updateQueue = {\n          baseState: currentQueue.baseState,\n          expirationTime: currentQueue.expirationTime,\n          first: currentQueue.first,\n          last: currentQueue.last,\n          isInitialized: currentQueue.isInitialized,\n          // These fields are no longer valid because they were already committed.\n          // Reset them.\n          callbackList: null,\n          hasForceUpdate: false\n        };\n      }\n\n      {\n        // Set this flag so we can warn if setState is called inside the update\n        // function of another setState.\n        queue.isProcessing = true;\n      } // Reset the remaining expiration time. If we skip over any updates, we'll\n      // increase this accordingly.\n\n      queue.expirationTime = NoWork; // TODO: We don't know what the base state will be until we begin work.\n      // It depends on which fiber is the next current. Initialize with an empty\n      // base state, then set to the memoizedState when rendering. Not super\n      // happy with this approach.\n\n      var state = void 0;\n\n      if (queue.isInitialized) {\n        state = queue.baseState;\n      } else {\n        state = queue.baseState = workInProgress.memoizedState;\n        queue.isInitialized = true;\n      }\n\n      var dontMutatePrevState = true;\n      var update = queue.first;\n      var didSkip = false;\n\n      while (update !== null) {\n        var updateExpirationTime = update.expirationTime;\n\n        if (updateExpirationTime > renderExpirationTime) {\n          // This update does not have sufficient priority. Skip it.\n          var remainingExpirationTime = queue.expirationTime;\n\n          if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {\n            // Update the remaining expiration time.\n            queue.expirationTime = updateExpirationTime;\n          }\n\n          if (!didSkip) {\n            didSkip = true;\n            queue.baseState = state;\n          } // Continue to the next update.\n\n\n          update = update.next;\n          continue;\n        } // This update does have sufficient priority.\n        // If no previous updates were skipped, drop this update from the queue by\n        // advancing the head of the list.\n\n\n        if (!didSkip) {\n          queue.first = update.next;\n\n          if (queue.first === null) {\n            queue.last = null;\n          }\n        } // Process the update\n\n\n        var _partialState = void 0;\n\n        if (update.isReplace) {\n          state = getStateFromUpdate(update, instance, state, props);\n          dontMutatePrevState = true;\n        } else {\n          _partialState = getStateFromUpdate(update, instance, state, props);\n\n          if (_partialState) {\n            if (dontMutatePrevState) {\n              // $FlowFixMe: Idk how to type this properly.\n              state = _assign({}, state, _partialState);\n            } else {\n              state = _assign(state, _partialState);\n            }\n\n            dontMutatePrevState = false;\n          }\n        }\n\n        if (update.isForced) {\n          queue.hasForceUpdate = true;\n        }\n\n        if (update.callback !== null) {\n          // Append to list of callbacks.\n          var _callbackList = queue.callbackList;\n\n          if (_callbackList === null) {\n            _callbackList = queue.callbackList = [];\n          }\n\n          _callbackList.push(update);\n        }\n\n        update = update.next;\n      }\n\n      if (queue.callbackList !== null) {\n        workInProgress.effectTag |= Callback;\n      } else if (queue.first === null && !queue.hasForceUpdate) {\n        // The queue is empty. We can reset it.\n        workInProgress.updateQueue = null;\n      }\n\n      if (!didSkip) {\n        didSkip = true;\n        queue.baseState = state;\n      }\n\n      {\n        // No longer processing.\n        queue.isProcessing = false;\n      }\n      return state;\n    }\n\n    function commitCallbacks(queue, context) {\n      var callbackList = queue.callbackList;\n\n      if (callbackList === null) {\n        return;\n      } // Set the list to null to make sure they don't get called more than once.\n\n\n      queue.callbackList = null;\n\n      for (var i = 0; i < callbackList.length; i++) {\n        var update = callbackList[i];\n        var _callback = update.callback; // This update might be processed again. Clear the callback so it's only\n        // called once.\n\n        update.callback = null;\n        !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;\n\n        _callback.call(context);\n      }\n    }\n\n    var fakeInternalInstance = {};\n    var isArray = Array.isArray;\n    {\n      var didWarnAboutStateAssignmentForComponent = {};\n\n      var warnOnInvalidCallback = function (callback, callerName) {\n        warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n      }; // This is so gross but it's at least non-critical and can be removed if\n      // it causes problems. This is meant to give a nicer error message for\n      // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n      // ...)) which otherwise throws a \"_processChildContext is not a function\"\n      // exception.\n\n\n      Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n        enumerable: false,\n        value: function () {\n          invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');\n        }\n      });\n      Object.freeze(fakeInternalInstance);\n    }\n\n    var ReactFiberClassComponent = function (scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {\n      // Class component state updater\n      var updater = {\n        isMounted: isMounted,\n        enqueueSetState: function (instance, partialState, callback) {\n          var fiber = get(instance);\n          callback = callback === undefined ? null : callback;\n          {\n            warnOnInvalidCallback(callback, 'setState');\n          }\n          var expirationTime = computeExpirationForFiber(fiber);\n          var update = {\n            expirationTime: expirationTime,\n            partialState: partialState,\n            callback: callback,\n            isReplace: false,\n            isForced: false,\n            nextCallback: null,\n            next: null\n          };\n          insertUpdateIntoFiber(fiber, update);\n          scheduleWork(fiber, expirationTime);\n        },\n        enqueueReplaceState: function (instance, state, callback) {\n          var fiber = get(instance);\n          callback = callback === undefined ? null : callback;\n          {\n            warnOnInvalidCallback(callback, 'replaceState');\n          }\n          var expirationTime = computeExpirationForFiber(fiber);\n          var update = {\n            expirationTime: expirationTime,\n            partialState: state,\n            callback: callback,\n            isReplace: true,\n            isForced: false,\n            nextCallback: null,\n            next: null\n          };\n          insertUpdateIntoFiber(fiber, update);\n          scheduleWork(fiber, expirationTime);\n        },\n        enqueueForceUpdate: function (instance, callback) {\n          var fiber = get(instance);\n          callback = callback === undefined ? null : callback;\n          {\n            warnOnInvalidCallback(callback, 'forceUpdate');\n          }\n          var expirationTime = computeExpirationForFiber(fiber);\n          var update = {\n            expirationTime: expirationTime,\n            partialState: null,\n            callback: callback,\n            isReplace: false,\n            isForced: true,\n            nextCallback: null,\n            next: null\n          };\n          insertUpdateIntoFiber(fiber, update);\n          scheduleWork(fiber, expirationTime);\n        }\n      };\n\n      function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {\n        if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {\n          // If the workInProgress already has an Update effect, return true\n          return true;\n        }\n\n        var instance = workInProgress.stateNode;\n        var type = workInProgress.type;\n\n        if (typeof instance.shouldComponentUpdate === 'function') {\n          startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n          var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);\n          stopPhaseTimer();\n          {\n            warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');\n          }\n          return shouldUpdate;\n        }\n\n        if (type.prototype && type.prototype.isPureReactComponent) {\n          return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n        }\n\n        return true;\n      }\n\n      function checkClassInstance(workInProgress) {\n        var instance = workInProgress.stateNode;\n        var type = workInProgress.type;\n        {\n          var name = getComponentName(workInProgress);\n          var renderPresent = instance.render;\n\n          if (!renderPresent) {\n            if (type.prototype && typeof type.prototype.render === 'function') {\n              warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n            } else {\n              warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n            }\n          }\n\n          var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n          warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n          var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n          warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n          var noInstancePropTypes = !instance.propTypes;\n          warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n          var noInstanceContextTypes = !instance.contextTypes;\n          warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n          var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n          warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n\n          if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n            warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');\n          }\n\n          var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n          warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n          var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';\n          warning(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n          var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n          warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n          var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n          warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n          var noInstanceDefaultProps = !instance.defaultProps;\n          warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n        }\n        var state = instance.state;\n\n        if (state && (typeof state !== 'object' || isArray(state))) {\n          invariant(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));\n        }\n\n        if (typeof instance.getChildContext === 'function') {\n          !(typeof workInProgress.type.childContextTypes === 'object') ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', getComponentName(workInProgress)) : void 0;\n        }\n      }\n\n      function resetInputPointers(workInProgress, instance) {\n        instance.props = workInProgress.memoizedProps;\n        instance.state = workInProgress.memoizedState;\n      }\n\n      function adoptClassInstance(workInProgress, instance) {\n        instance.updater = updater;\n        workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n\n        set(instance, workInProgress);\n        {\n          instance._reactInternalInstance = fakeInternalInstance;\n        }\n      }\n\n      function constructClassInstance(workInProgress, props) {\n        var ctor = workInProgress.type;\n        var unmaskedContext = getUnmaskedContext(workInProgress);\n        var needsContext = isContextConsumer(workInProgress);\n        var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;\n        var instance = new ctor(props, context);\n        adoptClassInstance(workInProgress, instance); // Cache unmasked context so we can avoid recreating masked context unless necessary.\n        // ReactFiberContext usually updates this cache but can't for newly-created instances.\n\n        if (needsContext) {\n          cacheContext(workInProgress, unmaskedContext, context);\n        }\n\n        return instance;\n      }\n\n      function callComponentWillMount(workInProgress, instance) {\n        startPhaseTimer(workInProgress, 'componentWillMount');\n        var oldState = instance.state;\n        instance.componentWillMount();\n        stopPhaseTimer();\n\n        if (oldState !== instance.state) {\n          {\n            warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress));\n          }\n          updater.enqueueReplaceState(instance, instance.state, null);\n        }\n      }\n\n      function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {\n        startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n        var oldState = instance.state;\n        instance.componentWillReceiveProps(newProps, newContext);\n        stopPhaseTimer();\n\n        if (instance.state !== oldState) {\n          {\n            var componentName = getComponentName(workInProgress) || 'Component';\n\n            if (!didWarnAboutStateAssignmentForComponent[componentName]) {\n              warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n              didWarnAboutStateAssignmentForComponent[componentName] = true;\n            }\n          }\n          updater.enqueueReplaceState(instance, instance.state, null);\n        }\n      } // Invokes the mount life-cycles on a previously never rendered instance.\n\n\n      function mountClassInstance(workInProgress, renderExpirationTime) {\n        var current = workInProgress.alternate;\n        {\n          checkClassInstance(workInProgress);\n        }\n        var instance = workInProgress.stateNode;\n        var state = instance.state || null;\n        var props = workInProgress.pendingProps;\n        !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        var unmaskedContext = getUnmaskedContext(workInProgress);\n        instance.props = props;\n        instance.state = workInProgress.memoizedState = state;\n        instance.refs = emptyObject;\n        instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n        if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {\n          workInProgress.internalContextTag |= AsyncUpdates;\n        }\n\n        if (typeof instance.componentWillMount === 'function') {\n          callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n          // process them now.\n\n          var updateQueue = workInProgress.updateQueue;\n\n          if (updateQueue !== null) {\n            instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);\n          }\n        }\n\n        if (typeof instance.componentDidMount === 'function') {\n          workInProgress.effectTag |= Update;\n        }\n      } // Called on a preexisting class instance. Returns false if a resumed render\n      // could be reused.\n      // function resumeMountClassInstance(\n      //   workInProgress: Fiber,\n      //   priorityLevel: PriorityLevel,\n      // ): boolean {\n      //   const instance = workInProgress.stateNode;\n      //   resetInputPointers(workInProgress, instance);\n      //   let newState = workInProgress.memoizedState;\n      //   let newProps = workInProgress.pendingProps;\n      //   if (!newProps) {\n      //     // If there isn't any new props, then we'll reuse the memoized props.\n      //     // This could be from already completed work.\n      //     newProps = workInProgress.memoizedProps;\n      //     invariant(\n      //       newProps != null,\n      //       'There should always be pending or memoized props. This error is ' +\n      //         'likely caused by a bug in React. Please file an issue.',\n      //     );\n      //   }\n      //   const newUnmaskedContext = getUnmaskedContext(workInProgress);\n      //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n      //   const oldContext = instance.context;\n      //   const oldProps = workInProgress.memoizedProps;\n      //   if (\n      //     typeof instance.componentWillReceiveProps === 'function' &&\n      //     (oldProps !== newProps || oldContext !== newContext)\n      //   ) {\n      //     callComponentWillReceiveProps(\n      //       workInProgress,\n      //       instance,\n      //       newProps,\n      //       newContext,\n      //     );\n      //   }\n      //   // Process the update queue before calling shouldComponentUpdate\n      //   const updateQueue = workInProgress.updateQueue;\n      //   if (updateQueue !== null) {\n      //     newState = processUpdateQueue(\n      //       workInProgress,\n      //       updateQueue,\n      //       instance,\n      //       newState,\n      //       newProps,\n      //       priorityLevel,\n      //     );\n      //   }\n      //   // TODO: Should we deal with a setState that happened after the last\n      //   // componentWillMount and before this componentWillMount? Probably\n      //   // unsupported anyway.\n      //   if (\n      //     !checkShouldComponentUpdate(\n      //       workInProgress,\n      //       workInProgress.memoizedProps,\n      //       newProps,\n      //       workInProgress.memoizedState,\n      //       newState,\n      //       newContext,\n      //     )\n      //   ) {\n      //     // Update the existing instance's state, props, and context pointers even\n      //     // though we're bailing out.\n      //     instance.props = newProps;\n      //     instance.state = newState;\n      //     instance.context = newContext;\n      //     return false;\n      //   }\n      //   // Update the input pointers now so that they are correct when we call\n      //   // componentWillMount\n      //   instance.props = newProps;\n      //   instance.state = newState;\n      //   instance.context = newContext;\n      //   if (typeof instance.componentWillMount === 'function') {\n      //     callComponentWillMount(workInProgress, instance);\n      //     // componentWillMount may have called setState. Process the update queue.\n      //     const newUpdateQueue = workInProgress.updateQueue;\n      //     if (newUpdateQueue !== null) {\n      //       newState = processUpdateQueue(\n      //         workInProgress,\n      //         newUpdateQueue,\n      //         instance,\n      //         newState,\n      //         newProps,\n      //         priorityLevel,\n      //       );\n      //     }\n      //   }\n      //   if (typeof instance.componentDidMount === 'function') {\n      //     workInProgress.effectTag |= Update;\n      //   }\n      //   instance.state = newState;\n      //   return true;\n      // }\n      // Invokes the update life-cycles and returns false if it shouldn't rerender.\n\n\n      function updateClassInstance(current, workInProgress, renderExpirationTime) {\n        var instance = workInProgress.stateNode;\n        resetInputPointers(workInProgress, instance);\n        var oldProps = workInProgress.memoizedProps;\n        var newProps = workInProgress.pendingProps;\n\n        if (!newProps) {\n          // If there aren't any new props, then we'll reuse the memoized props.\n          // This could be from already completed work.\n          newProps = oldProps;\n          !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        }\n\n        var oldContext = instance.context;\n        var newUnmaskedContext = getUnmaskedContext(workInProgress);\n        var newContext = getMaskedContext(workInProgress, newUnmaskedContext); // Note: During these life-cycles, instance.props/instance.state are what\n        // ever the previously attempted to render - not the \"current\". However,\n        // during componentDidUpdate we pass the \"current\" props.\n\n        if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {\n          callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n        } // Compute the next state using the memoized state and the update queue.\n\n\n        var oldState = workInProgress.memoizedState; // TODO: Previous state can be null.\n\n        var newState = void 0;\n\n        if (workInProgress.updateQueue !== null) {\n          newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);\n        } else {\n          newState = oldState;\n        }\n\n        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {\n          // If an update was already in progress, we should schedule an Update\n          // effect even though we're bailing out, so that cWU/cDU are called.\n          if (typeof instance.componentDidUpdate === 'function') {\n            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n              workInProgress.effectTag |= Update;\n            }\n          }\n\n          return false;\n        }\n\n        var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n\n        if (shouldUpdate) {\n          if (typeof instance.componentWillUpdate === 'function') {\n            startPhaseTimer(workInProgress, 'componentWillUpdate');\n            instance.componentWillUpdate(newProps, newState, newContext);\n            stopPhaseTimer();\n          }\n\n          if (typeof instance.componentDidUpdate === 'function') {\n            workInProgress.effectTag |= Update;\n          }\n        } else {\n          // If an update was already in progress, we should schedule an Update\n          // effect even though we're bailing out, so that cWU/cDU are called.\n          if (typeof instance.componentDidUpdate === 'function') {\n            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n              workInProgress.effectTag |= Update;\n            }\n          } // If shouldComponentUpdate returned false, we should still update the\n          // memoized props/state to indicate that this work can be reused.\n\n\n          memoizeProps(workInProgress, newProps);\n          memoizeState(workInProgress, newState);\n        } // Update the existing instance's state, props, and context pointers even\n        // if shouldComponentUpdate returns false.\n\n\n        instance.props = newProps;\n        instance.state = newState;\n        instance.context = newContext;\n        return shouldUpdate;\n      }\n\n      return {\n        adoptClassInstance: adoptClassInstance,\n        constructClassInstance: constructClassInstance,\n        mountClassInstance: mountClassInstance,\n        // resumeMountClassInstance,\n        updateClassInstance: updateClassInstance\n      };\n    }; // The Symbol used to tag the special React types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n\n    var REACT_PORTAL_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.portal') || 0xeaca;\n\n    function createPortal$1(children, containerInfo, // TODO: figure out the API for cross-renderer implementation.\n    implementation) {\n      var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      return {\n        // This tag allow us to uniquely identify this as a React Portal\n        $$typeof: REACT_PORTAL_TYPE,\n        key: key == null ? null : '' + key,\n        children: children,\n        containerInfo: containerInfo,\n        implementation: implementation\n      };\n    }\n\n    var getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n    {\n      var didWarnAboutMaps = false;\n      /**\n       * Warn if there's no key explicitly set on dynamic arrays of children or\n       * object keys are not valid. This allows us to keep track of children between\n       * updates.\n       */\n\n      var ownerHasKeyUseWarning = {};\n      var ownerHasFunctionTypeWarning = {};\n\n      var warnForMissingKey = function (child) {\n        if (child === null || typeof child !== 'object') {\n          return;\n        }\n\n        if (!child._store || child._store.validated || child.key != null) {\n          return;\n        }\n\n        !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        child._store.validated = true;\n        var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');\n\n        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n          return;\n        }\n\n        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n        warning(false, 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());\n      };\n    }\n    var isArray$1 = Array.isArray;\n    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n    var REACT_ELEMENT_TYPE;\n    var REACT_CALL_TYPE;\n    var REACT_RETURN_TYPE;\n    var REACT_FRAGMENT_TYPE;\n\n    if (typeof Symbol === 'function' && Symbol['for']) {\n      REACT_ELEMENT_TYPE = Symbol['for']('react.element');\n      REACT_CALL_TYPE = Symbol['for']('react.call');\n      REACT_RETURN_TYPE = Symbol['for']('react.return');\n      REACT_FRAGMENT_TYPE = Symbol['for']('react.fragment');\n    } else {\n      REACT_ELEMENT_TYPE = 0xeac7;\n      REACT_CALL_TYPE = 0xeac8;\n      REACT_RETURN_TYPE = 0xeac9;\n      REACT_FRAGMENT_TYPE = 0xeacb;\n    }\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n        return null;\n      }\n\n      var iteratorFn = ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof iteratorFn === 'function') {\n        return iteratorFn;\n      }\n\n      return null;\n    }\n\n    function coerceRef(current, element) {\n      var mixedRef = element.ref;\n\n      if (mixedRef !== null && typeof mixedRef !== 'function') {\n        if (element._owner) {\n          var owner = element._owner;\n          var inst = void 0;\n\n          if (owner) {\n            var ownerFiber = owner;\n            !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;\n            inst = ownerFiber.stateNode;\n          }\n\n          !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;\n          var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref\n\n          if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {\n            return current.ref;\n          }\n\n          var ref = function (value) {\n            var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n\n            if (value === null) {\n              delete refs[stringRef];\n            } else {\n              refs[stringRef] = value;\n            }\n          };\n\n          ref._stringRef = stringRef;\n          return ref;\n        } else {\n          !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;\n          !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;\n        }\n      }\n\n      return mixedRef;\n    }\n\n    function throwOnInvalidObjectType(returnFiber, newChild) {\n      if (returnFiber.type !== 'textarea') {\n        var addendum = '';\n        {\n          addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');\n        }\n        invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n      }\n    }\n\n    function warnOnFunctionType() {\n      var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');\n\n      if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n        return;\n      }\n\n      ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n      warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');\n    } // This wrapper function exists because I expect to clone the code in each path\n    // to be able to optimize each path individually by branching early. This needs\n    // a compiler or we can do it manually. Helpers that don't need this branching\n    // live outside of this function.\n\n\n    function ChildReconciler(shouldClone, shouldTrackSideEffects) {\n      function deleteChild(returnFiber, childToDelete) {\n        if (!shouldTrackSideEffects) {\n          // Noop.\n          return;\n        }\n\n        if (!shouldClone) {\n          // When we're reconciling in place we have a work in progress copy. We\n          // actually want the current copy. If there is no current copy, then we\n          // don't need to track deletion side-effects.\n          if (childToDelete.alternate === null) {\n            return;\n          }\n\n          childToDelete = childToDelete.alternate;\n        } // Deletions are added in reversed order so we add it to the front.\n        // At this point, the return fiber's effect list is empty except for\n        // deletions, so we can just append the deletion to the list. The remaining\n        // effects aren't added until the complete phase. Once we implement\n        // resuming, this may not be true.\n\n\n        var last = returnFiber.lastEffect;\n\n        if (last !== null) {\n          last.nextEffect = childToDelete;\n          returnFiber.lastEffect = childToDelete;\n        } else {\n          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n        }\n\n        childToDelete.nextEffect = null;\n        childToDelete.effectTag = Deletion;\n      }\n\n      function deleteRemainingChildren(returnFiber, currentFirstChild) {\n        if (!shouldTrackSideEffects) {\n          // Noop.\n          return null;\n        } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n        // assuming that after the first child we've already added everything.\n\n\n        var childToDelete = currentFirstChild;\n\n        while (childToDelete !== null) {\n          deleteChild(returnFiber, childToDelete);\n          childToDelete = childToDelete.sibling;\n        }\n\n        return null;\n      }\n\n      function mapRemainingChildren(returnFiber, currentFirstChild) {\n        // Add the remaining children to a temporary map so that we can find them by\n        // keys quickly. Implicit (null) keys get added to this set with their index\n        var existingChildren = new Map();\n        var existingChild = currentFirstChild;\n\n        while (existingChild !== null) {\n          if (existingChild.key !== null) {\n            existingChildren.set(existingChild.key, existingChild);\n          } else {\n            existingChildren.set(existingChild.index, existingChild);\n          }\n\n          existingChild = existingChild.sibling;\n        }\n\n        return existingChildren;\n      }\n\n      function useFiber(fiber, pendingProps, expirationTime) {\n        // We currently set sibling to null and index to 0 here because it is easy\n        // to forget to do before returning it. E.g. for the single child case.\n        if (shouldClone) {\n          var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n          clone.index = 0;\n          clone.sibling = null;\n          return clone;\n        } else {\n          // We override the expiration time even if it is earlier, because if\n          // we're reconciling at a later time that means that this was\n          // down-prioritized.\n          fiber.expirationTime = expirationTime;\n          fiber.effectTag = NoEffect;\n          fiber.index = 0;\n          fiber.sibling = null;\n          fiber.pendingProps = pendingProps;\n          return fiber;\n        }\n      }\n\n      function placeChild(newFiber, lastPlacedIndex, newIndex) {\n        newFiber.index = newIndex;\n\n        if (!shouldTrackSideEffects) {\n          // Noop.\n          return lastPlacedIndex;\n        }\n\n        var current = newFiber.alternate;\n\n        if (current !== null) {\n          var oldIndex = current.index;\n\n          if (oldIndex < lastPlacedIndex) {\n            // This is a move.\n            newFiber.effectTag = Placement;\n            return lastPlacedIndex;\n          } else {\n            // This item can stay in place.\n            return oldIndex;\n          }\n        } else {\n          // This is an insertion.\n          newFiber.effectTag = Placement;\n          return lastPlacedIndex;\n        }\n      }\n\n      function placeSingleChild(newFiber) {\n        // This is simpler for the single child case. We only need to do a\n        // placement for inserting new children.\n        if (shouldTrackSideEffects && newFiber.alternate === null) {\n          newFiber.effectTag = Placement;\n        }\n\n        return newFiber;\n      }\n\n      function updateTextNode(returnFiber, current, textContent, expirationTime) {\n        if (current === null || current.tag !== HostText) {\n          // Insert\n          var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Update\n          var existing = useFiber(current, textContent, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function updateElement(returnFiber, current, element, expirationTime) {\n        if (current !== null && current.type === element.type) {\n          // Move based on index\n          var existing = useFiber(current, element.props, expirationTime);\n          existing.ref = coerceRef(current, element);\n          existing['return'] = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          // Insert\n          var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n          created.ref = coerceRef(current, element);\n          created['return'] = returnFiber;\n          return created;\n        }\n      }\n\n      function updateCall(returnFiber, current, call, expirationTime) {\n        // TODO: Should this also compare handler to determine whether to reuse?\n        if (current === null || current.tag !== CallComponent) {\n          // Insert\n          var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Move based on index\n          var existing = useFiber(current, call, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function updateReturn(returnFiber, current, returnNode, expirationTime) {\n        if (current === null || current.tag !== ReturnComponent) {\n          // Insert\n          var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n          created.type = returnNode.value;\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Move based on index\n          var existing = useFiber(current, null, expirationTime);\n          existing.type = returnNode.value;\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function updatePortal(returnFiber, current, portal, expirationTime) {\n        if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n          // Insert\n          var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Update\n          var existing = useFiber(current, portal.children || [], expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n        if (current === null || current.tag !== Fragment) {\n          // Insert\n          var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Update\n          var existing = useFiber(current, fragment, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function createChild(returnFiber, newChild, expirationTime) {\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          // Text nodes don't have keys. If the previous node is implicitly keyed\n          // we can continue to replace it without aborting even if it is not a text\n          // node.\n          var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);\n          created['return'] = returnFiber;\n          return created;\n        }\n\n        if (typeof newChild === 'object' && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                if (newChild.type === REACT_FRAGMENT_TYPE) {\n                  var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);\n\n                  _created['return'] = returnFiber;\n                  return _created;\n                } else {\n                  var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);\n\n                  _created2.ref = coerceRef(null, newChild);\n                  _created2['return'] = returnFiber;\n                  return _created2;\n                }\n              }\n\n            case REACT_CALL_TYPE:\n              {\n                var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);\n\n                _created3['return'] = returnFiber;\n                return _created3;\n              }\n\n            case REACT_RETURN_TYPE:\n              {\n                var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);\n\n                _created4.type = newChild.value;\n                _created4['return'] = returnFiber;\n                return _created4;\n              }\n\n            case REACT_PORTAL_TYPE:\n              {\n                var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);\n\n                _created5['return'] = returnFiber;\n                return _created5;\n              }\n          }\n\n          if (isArray$1(newChild) || getIteratorFn(newChild)) {\n            var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);\n\n            _created6['return'] = returnFiber;\n            return _created6;\n          }\n\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n\n      function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n        // Update the fiber if the keys match, otherwise return null.\n        var key = oldFiber !== null ? oldFiber.key : null;\n\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          // Text nodes don't have keys. If the previous node is implicitly keyed\n          // we can continue to replace it without aborting even if it is not a text\n          // node.\n          if (key !== null) {\n            return null;\n          }\n\n          return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);\n        }\n\n        if (typeof newChild === 'object' && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                if (newChild.key === key) {\n                  if (newChild.type === REACT_FRAGMENT_TYPE) {\n                    return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n                  }\n\n                  return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n\n            case REACT_CALL_TYPE:\n              {\n                if (newChild.key === key) {\n                  return updateCall(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n\n            case REACT_RETURN_TYPE:\n              {\n                // Returns don't have keys. If the previous node is implicitly keyed\n                // we can continue to replace it without aborting even if it is not a\n                // yield.\n                if (key === null) {\n                  return updateReturn(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n\n            case REACT_PORTAL_TYPE:\n              {\n                if (newChild.key === key) {\n                  return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n          }\n\n          if (isArray$1(newChild) || getIteratorFn(newChild)) {\n            if (key !== null) {\n              return null;\n            }\n\n            return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n          }\n\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n\n      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          // Text nodes don't have keys, so we neither have to check the old nor\n          // new node for the key. If both are text nodes, they match.\n          var matchedFiber = existingChildren.get(newIdx) || null;\n          return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);\n        }\n\n        if (typeof newChild === 'object' && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n                if (newChild.type === REACT_FRAGMENT_TYPE) {\n                  return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);\n                }\n\n                return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);\n              }\n\n            case REACT_CALL_TYPE:\n              {\n                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n                return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);\n              }\n\n            case REACT_RETURN_TYPE:\n              {\n                // Returns don't have keys, so we neither have to check the old nor\n                // new node for the key. If both are returns, they match.\n                var _matchedFiber3 = existingChildren.get(newIdx) || null;\n\n                return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);\n              }\n\n            case REACT_PORTAL_TYPE:\n              {\n                var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n                return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);\n              }\n          }\n\n          if (isArray$1(newChild) || getIteratorFn(newChild)) {\n            var _matchedFiber5 = existingChildren.get(newIdx) || null;\n\n            return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);\n          }\n\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n      /**\n       * Warns if there is a duplicate or missing key\n       */\n\n\n      function warnOnInvalidKey(child, knownKeys) {\n        {\n          if (typeof child !== 'object' || child === null) {\n            return knownKeys;\n          }\n\n          switch (child.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n            case REACT_CALL_TYPE:\n            case REACT_PORTAL_TYPE:\n              warnForMissingKey(child);\n              var key = child.key;\n\n              if (typeof key !== 'string') {\n                break;\n              }\n\n              if (knownKeys === null) {\n                knownKeys = new Set();\n                knownKeys.add(key);\n                break;\n              }\n\n              if (!knownKeys.has(key)) {\n                knownKeys.add(key);\n                break;\n              }\n\n              warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());\n              break;\n\n            default:\n              break;\n          }\n        }\n        return knownKeys;\n      }\n\n      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {\n        // This algorithm can't optimize by searching from boths ends since we\n        // don't have backpointers on fibers. I'm trying to see how far we can get\n        // with that model. If it ends up not being worth the tradeoffs, we can\n        // add it later.\n        // Even with a two ended optimization, we'd want to optimize for the case\n        // where there are few changes and brute force the comparison instead of\n        // going for the Map. It'd like to explore hitting that path first in\n        // forward-only mode and only go for the Map once we notice that we need\n        // lots of look ahead. This doesn't handle reversal as well as two ended\n        // search but that's unusual. Besides, for the two ended optimization to\n        // work on Iterables, we'd need to copy the whole set.\n        // In this first iteration, we'll just live with hitting the bad case\n        // (adding everything to a Map) in for every insert/move.\n        // If you change this code, also update reconcileChildrenIterator() which\n        // uses the same algorithm.\n        {\n          // First, validate keys.\n          var knownKeys = null;\n\n          for (var i = 0; i < newChildren.length; i++) {\n            var child = newChildren[i];\n            knownKeys = warnOnInvalidKey(child, knownKeys);\n          }\n        }\n        var resultingFirstChild = null;\n        var previousNewFiber = null;\n        var oldFiber = currentFirstChild;\n        var lastPlacedIndex = 0;\n        var newIdx = 0;\n        var nextOldFiber = null;\n\n        for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n          if (oldFiber.index > newIdx) {\n            nextOldFiber = oldFiber;\n            oldFiber = null;\n          } else {\n            nextOldFiber = oldFiber.sibling;\n          }\n\n          var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n\n          if (newFiber === null) {\n            // TODO: This breaks on empty slots like null children. That's\n            // unfortunate because it triggers the slow path all the time. We need\n            // a better way to communicate whether this was a miss or null,\n            // boolean, undefined, etc.\n            if (oldFiber === null) {\n              oldFiber = nextOldFiber;\n            }\n\n            break;\n          }\n\n          if (shouldTrackSideEffects) {\n            if (oldFiber && newFiber.alternate === null) {\n              // We matched the slot, but we didn't reuse the existing fiber, so we\n              // need to delete the existing child.\n              deleteChild(returnFiber, oldFiber);\n            }\n          }\n\n          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n          if (previousNewFiber === null) {\n            // TODO: Move out of the loop. This only happens for the first run.\n            resultingFirstChild = newFiber;\n          } else {\n            // TODO: Defer siblings if we're not at the right index for this slot.\n            // I.e. if we had null values before, then we want to defer this\n            // for each null value. However, we also don't want to call updateSlot\n            // with the previous one.\n            previousNewFiber.sibling = newFiber;\n          }\n\n          previousNewFiber = newFiber;\n          oldFiber = nextOldFiber;\n        }\n\n        if (newIdx === newChildren.length) {\n          // We've reached the end of the new children. We can delete the rest.\n          deleteRemainingChildren(returnFiber, oldFiber);\n          return resultingFirstChild;\n        }\n\n        if (oldFiber === null) {\n          // If we don't have any more existing children we can choose a fast path\n          // since the rest will all be insertions.\n          for (; newIdx < newChildren.length; newIdx++) {\n            var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);\n\n            if (!_newFiber) {\n              continue;\n            }\n\n            lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              // TODO: Move out of the loop. This only happens for the first run.\n              resultingFirstChild = _newFiber;\n            } else {\n              previousNewFiber.sibling = _newFiber;\n            }\n\n            previousNewFiber = _newFiber;\n          }\n\n          return resultingFirstChild;\n        } // Add all children to a key map for quick lookups.\n\n\n        var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n        for (; newIdx < newChildren.length; newIdx++) {\n          var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n\n          if (_newFiber2) {\n            if (shouldTrackSideEffects) {\n              if (_newFiber2.alternate !== null) {\n                // The new fiber is a work in progress, but if there exists a\n                // current, that means that we reused the fiber. We need to delete\n                // it from the child list so that we don't add it to the deletion\n                // list.\n                existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);\n              }\n            }\n\n            lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              resultingFirstChild = _newFiber2;\n            } else {\n              previousNewFiber.sibling = _newFiber2;\n            }\n\n            previousNewFiber = _newFiber2;\n          }\n        }\n\n        if (shouldTrackSideEffects) {\n          // Any existing children that weren't consumed above were deleted. We need\n          // to add them to the deletion list.\n          existingChildren.forEach(function (child) {\n            return deleteChild(returnFiber, child);\n          });\n        }\n\n        return resultingFirstChild;\n      }\n\n      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n        // This is the same implementation as reconcileChildrenArray(),\n        // but using the iterator instead.\n        var iteratorFn = getIteratorFn(newChildrenIterable);\n        !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        {\n          // Warn about using Maps as children\n          if (typeof newChildrenIterable.entries === 'function') {\n            var possibleMap = newChildrenIterable;\n\n            if (possibleMap.entries === iteratorFn) {\n              warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());\n              didWarnAboutMaps = true;\n            }\n          } // First, validate keys.\n          // We'll get a different iterator later for the main pass.\n\n\n          var _newChildren = iteratorFn.call(newChildrenIterable);\n\n          if (_newChildren) {\n            var knownKeys = null;\n\n            var _step = _newChildren.next();\n\n            for (; !_step.done; _step = _newChildren.next()) {\n              var child = _step.value;\n              knownKeys = warnOnInvalidKey(child, knownKeys);\n            }\n          }\n        }\n        var newChildren = iteratorFn.call(newChildrenIterable);\n        !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;\n        var resultingFirstChild = null;\n        var previousNewFiber = null;\n        var oldFiber = currentFirstChild;\n        var lastPlacedIndex = 0;\n        var newIdx = 0;\n        var nextOldFiber = null;\n        var step = newChildren.next();\n\n        for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n          if (oldFiber.index > newIdx) {\n            nextOldFiber = oldFiber;\n            oldFiber = null;\n          } else {\n            nextOldFiber = oldFiber.sibling;\n          }\n\n          var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n\n          if (newFiber === null) {\n            // TODO: This breaks on empty slots like null children. That's\n            // unfortunate because it triggers the slow path all the time. We need\n            // a better way to communicate whether this was a miss or null,\n            // boolean, undefined, etc.\n            if (!oldFiber) {\n              oldFiber = nextOldFiber;\n            }\n\n            break;\n          }\n\n          if (shouldTrackSideEffects) {\n            if (oldFiber && newFiber.alternate === null) {\n              // We matched the slot, but we didn't reuse the existing fiber, so we\n              // need to delete the existing child.\n              deleteChild(returnFiber, oldFiber);\n            }\n          }\n\n          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n          if (previousNewFiber === null) {\n            // TODO: Move out of the loop. This only happens for the first run.\n            resultingFirstChild = newFiber;\n          } else {\n            // TODO: Defer siblings if we're not at the right index for this slot.\n            // I.e. if we had null values before, then we want to defer this\n            // for each null value. However, we also don't want to call updateSlot\n            // with the previous one.\n            previousNewFiber.sibling = newFiber;\n          }\n\n          previousNewFiber = newFiber;\n          oldFiber = nextOldFiber;\n        }\n\n        if (step.done) {\n          // We've reached the end of the new children. We can delete the rest.\n          deleteRemainingChildren(returnFiber, oldFiber);\n          return resultingFirstChild;\n        }\n\n        if (oldFiber === null) {\n          // If we don't have any more existing children we can choose a fast path\n          // since the rest will all be insertions.\n          for (; !step.done; newIdx++, step = newChildren.next()) {\n            var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n\n            if (_newFiber3 === null) {\n              continue;\n            }\n\n            lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              // TODO: Move out of the loop. This only happens for the first run.\n              resultingFirstChild = _newFiber3;\n            } else {\n              previousNewFiber.sibling = _newFiber3;\n            }\n\n            previousNewFiber = _newFiber3;\n          }\n\n          return resultingFirstChild;\n        } // Add all children to a key map for quick lookups.\n\n\n        var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n        for (; !step.done; newIdx++, step = newChildren.next()) {\n          var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n\n          if (_newFiber4 !== null) {\n            if (shouldTrackSideEffects) {\n              if (_newFiber4.alternate !== null) {\n                // The new fiber is a work in progress, but if there exists a\n                // current, that means that we reused the fiber. We need to delete\n                // it from the child list so that we don't add it to the deletion\n                // list.\n                existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);\n              }\n            }\n\n            lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              resultingFirstChild = _newFiber4;\n            } else {\n              previousNewFiber.sibling = _newFiber4;\n            }\n\n            previousNewFiber = _newFiber4;\n          }\n        }\n\n        if (shouldTrackSideEffects) {\n          // Any existing children that weren't consumed above were deleted. We need\n          // to add them to the deletion list.\n          existingChildren.forEach(function (child) {\n            return deleteChild(returnFiber, child);\n          });\n        }\n\n        return resultingFirstChild;\n      }\n\n      function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n        // There's no need to check for keys on text nodes since we don't have a\n        // way to define them.\n        if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n          // We already have an existing node so let's just update it and delete\n          // the rest.\n          deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n          var existing = useFiber(currentFirstChild, textContent, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        } // The existing first child is not a text node so we need to create one\n        // and delete the existing ones.\n\n\n        deleteRemainingChildren(returnFiber, currentFirstChild);\n        var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n        created['return'] = returnFiber;\n        return created;\n      }\n\n      function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {\n        var key = element.key;\n        var child = currentFirstChild;\n\n        while (child !== null) {\n          // TODO: If key === null and child.key === null, then this only applies to\n          // the first item in the list.\n          if (child.key === key) {\n            if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);\n              existing.ref = coerceRef(child, element);\n              existing['return'] = returnFiber;\n              {\n                existing._debugSource = element._source;\n                existing._debugOwner = element._owner;\n              }\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n\n          child = child.sibling;\n        }\n\n        if (element.type === REACT_FRAGMENT_TYPE) {\n          var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n\n          _created7.ref = coerceRef(currentFirstChild, element);\n          _created7['return'] = returnFiber;\n          return _created7;\n        }\n      }\n\n      function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {\n        var key = call.key;\n        var child = currentFirstChild;\n\n        while (child !== null) {\n          // TODO: If key === null and child.key === null, then this only applies to\n          // the first item in the list.\n          if (child.key === key) {\n            if (child.tag === CallComponent) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, call, expirationTime);\n              existing['return'] = returnFiber;\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n\n          child = child.sibling;\n        }\n\n        var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n        created['return'] = returnFiber;\n        return created;\n      }\n\n      function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {\n        // There's no need to check for keys on yields since they're stateless.\n        var child = currentFirstChild;\n\n        if (child !== null) {\n          if (child.tag === ReturnComponent) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            var existing = useFiber(child, null, expirationTime);\n            existing.type = returnNode.value;\n            existing['return'] = returnFiber;\n            return existing;\n          } else {\n            deleteRemainingChildren(returnFiber, child);\n          }\n        }\n\n        var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n        created.type = returnNode.value;\n        created['return'] = returnFiber;\n        return created;\n      }\n\n      function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n        var key = portal.key;\n        var child = currentFirstChild;\n\n        while (child !== null) {\n          // TODO: If key === null and child.key === null, then this only applies to\n          // the first item in the list.\n          if (child.key === key) {\n            if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, portal.children || [], expirationTime);\n              existing['return'] = returnFiber;\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n\n          child = child.sibling;\n        }\n\n        var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n        created['return'] = returnFiber;\n        return created;\n      } // This API will tag the children with the side-effect of the reconciliation\n      // itself. They will be added to the side-effect list as we pass through the\n      // children and the parent.\n\n\n      function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {\n        // This function is not recursive.\n        // If the top level item is an array, we treat it as a set of children,\n        // not as a fragment. Nested arrays on the other hand will be treated as\n        // fragment nodes. Recursion happens at the normal flow.\n        // Handle top level unkeyed fragments as if they were arrays.\n        // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n        // We treat the ambiguous cases above the same.\n        if (enableReactFragment && typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {\n          newChild = newChild.props.children;\n        } // Handle object types\n\n\n        var isObject = typeof newChild === 'object' && newChild !== null;\n\n        if (isObject) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n\n            case REACT_CALL_TYPE:\n              return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));\n\n            case REACT_RETURN_TYPE:\n              return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));\n\n            case REACT_PORTAL_TYPE:\n              return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n          }\n        }\n\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));\n        }\n\n        if (isArray$1(newChild)) {\n          return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n        }\n\n        if (getIteratorFn(newChild)) {\n          return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n        }\n\n        if (isObject) {\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n\n        if (typeof newChild === 'undefined') {\n          // If the new child is undefined, and the return fiber is a composite\n          // component, throw an error. If Fiber return types are disabled,\n          // we already threw above.\n          switch (returnFiber.tag) {\n            case ClassComponent:\n              {\n                {\n                  var instance = returnFiber.stateNode;\n\n                  if (instance.render._isMockFunction) {\n                    // We allow auto-mocks to proceed as if they're returning null.\n                    break;\n                  }\n                }\n              }\n            // Intentionally fall through to the next case, which handles both\n            // functions and classes\n            // eslint-disable-next-lined no-fallthrough\n\n            case FunctionalComponent:\n              {\n                var Component = returnFiber.type;\n                invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');\n              }\n          }\n        } // Remaining cases are all treated as empty.\n\n\n        return deleteRemainingChildren(returnFiber, currentFirstChild);\n      }\n\n      return reconcileChildFibers;\n    }\n\n    var reconcileChildFibers = ChildReconciler(true, true);\n    var reconcileChildFibersInPlace = ChildReconciler(false, true);\n    var mountChildFibersInPlace = ChildReconciler(false, false);\n\n    function cloneChildFibers(current, workInProgress) {\n      !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;\n\n      if (workInProgress.child === null) {\n        return;\n      }\n\n      var currentChild = workInProgress.child;\n      var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n      workInProgress.child = newChild;\n      newChild['return'] = workInProgress;\n\n      while (currentChild.sibling !== null) {\n        currentChild = currentChild.sibling;\n        newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n        newChild['return'] = workInProgress;\n      }\n\n      newChild.sibling = null;\n    }\n\n    {\n      var warnedAboutStatelessRefs = {};\n    }\n\n    var ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {\n      var shouldSetTextContent = config.shouldSetTextContent,\n          useSyncScheduling = config.useSyncScheduling,\n          shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;\n      var pushHostContext = hostContext.pushHostContext,\n          pushHostContainer = hostContext.pushHostContainer;\n      var enterHydrationState = hydrationContext.enterHydrationState,\n          resetHydrationState = hydrationContext.resetHydrationState,\n          tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;\n\n      var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),\n          adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,\n          constructClassInstance = _ReactFiberClassCompo.constructClassInstance,\n          mountClassInstance = _ReactFiberClassCompo.mountClassInstance,\n          updateClassInstance = _ReactFiberClassCompo.updateClassInstance; // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\n\n\n      function reconcileChildren(current, workInProgress, nextChildren) {\n        reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);\n      }\n\n      function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {\n        if (current === null) {\n          // If this is a fresh new component that hasn't been rendered yet, we\n          // won't update its child set by applying minimal side-effects. Instead,\n          // we will add them all to the child before it gets rendered. That means\n          // we can optimize this reconciliation pass by not tracking side-effects.\n          workInProgress.child = mountChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n        } else if (current.child === workInProgress.child) {\n          // If the current child is the same as the work in progress, it means that\n          // we haven't yet started any work on these children. Therefore, we use\n          // the clone algorithm to create a copy of all the current children.\n          // If we had any progressed work already, that is invalid at this point so\n          // let's throw it out.\n          workInProgress.child = reconcileChildFibers(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n        } else {\n          // If, on the other hand, it is already using a clone, that means we've\n          // already begun some work on this tree and we can continue where we left\n          // off by reconciling against the existing children.\n          workInProgress.child = reconcileChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n        }\n      }\n\n      function updateFragment(current, workInProgress) {\n        var nextChildren = workInProgress.pendingProps;\n\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextChildren === null) {\n            nextChildren = workInProgress.memoizedProps;\n          }\n        } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        reconcileChildren(current, workInProgress, nextChildren);\n        memoizeProps(workInProgress, nextChildren);\n        return workInProgress.child;\n      }\n\n      function markRef(current, workInProgress) {\n        var ref = workInProgress.ref;\n\n        if (ref !== null && (!current || current.ref !== ref)) {\n          // Schedule a Ref effect\n          workInProgress.effectTag |= Ref;\n        }\n      }\n\n      function updateFunctionalComponent(current, workInProgress) {\n        var fn = workInProgress.type;\n        var nextProps = workInProgress.pendingProps;\n        var memoizedProps = workInProgress.memoizedProps;\n\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextProps === null) {\n            nextProps = memoizedProps;\n          }\n        } else {\n          if (nextProps === null || memoizedProps === nextProps) {\n            return bailoutOnAlreadyFinishedWork(current, workInProgress);\n          } // TODO: consider bringing fn.shouldComponentUpdate() back.\n          // It used to be here.\n\n        }\n\n        var unmaskedContext = getUnmaskedContext(workInProgress);\n        var context = getMaskedContext(workInProgress, unmaskedContext);\n        var nextChildren;\n        {\n          ReactCurrentOwner.current = workInProgress;\n          ReactDebugCurrentFiber.setCurrentPhase('render');\n          nextChildren = fn(nextProps, context);\n          ReactDebugCurrentFiber.setCurrentPhase(null);\n        } // React DevTools reads this flag.\n\n        workInProgress.effectTag |= PerformedWork;\n        reconcileChildren(current, workInProgress, nextChildren);\n        memoizeProps(workInProgress, nextProps);\n        return workInProgress.child;\n      }\n\n      function updateClassComponent(current, workInProgress, renderExpirationTime) {\n        // Push context providers early to prevent context stack mismatches.\n        // During mounting we don't know the child context yet as the instance doesn't exist.\n        // We will invalidate the child context in finishClassComponent() right after rendering.\n        var hasContext = pushContextProvider(workInProgress);\n        var shouldUpdate = void 0;\n\n        if (current === null) {\n          if (!workInProgress.stateNode) {\n            // In the initial pass we might need to construct the instance.\n            constructClassInstance(workInProgress, workInProgress.pendingProps);\n            mountClassInstance(workInProgress, renderExpirationTime);\n            shouldUpdate = true;\n          } else {\n            invariant(false, 'Resuming work not yet implemented.'); // In a resume, we'll already have an instance we can reuse.\n            // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);\n          }\n        } else {\n          shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);\n        }\n\n        return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);\n      }\n\n      function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {\n        // Refs should update even if shouldComponentUpdate returns false\n        markRef(current, workInProgress);\n\n        if (!shouldUpdate) {\n          // Context providers should defer to sCU for rendering\n          if (hasContext) {\n            invalidateContextProvider(workInProgress, false);\n          }\n\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        var instance = workInProgress.stateNode; // Rerender\n\n        ReactCurrentOwner.current = workInProgress;\n        var nextChildren = void 0;\n        {\n          ReactDebugCurrentFiber.setCurrentPhase('render');\n          nextChildren = instance.render();\n          ReactDebugCurrentFiber.setCurrentPhase(null);\n        } // React DevTools reads this flag.\n\n        workInProgress.effectTag |= PerformedWork;\n        reconcileChildren(current, workInProgress, nextChildren); // Memoize props and state using the values we just used to render.\n        // TODO: Restructure so we never read values from the instance.\n\n        memoizeState(workInProgress, instance.state);\n        memoizeProps(workInProgress, instance.props); // The context might have changed so we need to recalculate it.\n\n        if (hasContext) {\n          invalidateContextProvider(workInProgress, true);\n        }\n\n        return workInProgress.child;\n      }\n\n      function pushHostRootContext(workInProgress) {\n        var root = workInProgress.stateNode;\n\n        if (root.pendingContext) {\n          pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n        } else if (root.context) {\n          // Should always be set\n          pushTopLevelContextObject(workInProgress, root.context, false);\n        }\n\n        pushHostContainer(workInProgress, root.containerInfo);\n      }\n\n      function updateHostRoot(current, workInProgress, renderExpirationTime) {\n        pushHostRootContext(workInProgress);\n        var updateQueue = workInProgress.updateQueue;\n\n        if (updateQueue !== null) {\n          var prevState = workInProgress.memoizedState;\n          var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);\n\n          if (prevState === state) {\n            // If the state is the same as before, that's a bailout because we had\n            // no work that expires at this time.\n            resetHydrationState();\n            return bailoutOnAlreadyFinishedWork(current, workInProgress);\n          }\n\n          var element = state.element;\n          var root = workInProgress.stateNode;\n\n          if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {\n            // If we don't have any current children this might be the first pass.\n            // We always try to hydrate. If this isn't a hydration pass there won't\n            // be any children to hydrate which is effectively the same thing as\n            // not hydrating.\n            // This is a bit of a hack. We track the host root as a placement to\n            // know that we're currently in a mounting state. That way isMounted\n            // works as expected. We must reset this before committing.\n            // TODO: Delete this when we delete isMounted and findDOMNode.\n            workInProgress.effectTag |= Placement; // Ensure that children mount into this root without tracking\n            // side-effects. This ensures that we don't store Placement effects on\n            // nodes that will be hydrated.\n\n            workInProgress.child = mountChildFibersInPlace(workInProgress, workInProgress.child, element, renderExpirationTime);\n          } else {\n            // Otherwise reset hydration state in case we aborted and resumed another\n            // root.\n            resetHydrationState();\n            reconcileChildren(current, workInProgress, element);\n          }\n\n          memoizeState(workInProgress, state);\n          return workInProgress.child;\n        }\n\n        resetHydrationState(); // If there is no update queue, that's a bailout because the root has no props.\n\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n\n      function updateHostComponent(current, workInProgress, renderExpirationTime) {\n        pushHostContext(workInProgress);\n\n        if (current === null) {\n          tryToClaimNextHydratableInstance(workInProgress);\n        }\n\n        var type = workInProgress.type;\n        var memoizedProps = workInProgress.memoizedProps;\n        var nextProps = workInProgress.pendingProps;\n\n        if (nextProps === null) {\n          nextProps = memoizedProps;\n          !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        }\n\n        var prevProps = current !== null ? current.memoizedProps : null;\n\n        if (hasContextChanged()) {// Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n        } else if (nextProps === null || memoizedProps === nextProps) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        var nextChildren = nextProps.children;\n        var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n        if (isDirectTextChild) {\n          // We special case a direct text child of a host node. This is a common\n          // case. We won't handle it as a reified child. We will instead handle\n          // this in the host environment that also have access to this prop. That\n          // avoids allocating another HostText fiber and traversing it.\n          nextChildren = null;\n        } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n          // If we're switching from a direct text child to a normal child, or to\n          // empty, we need to schedule the text content to be reset.\n          workInProgress.effectTag |= ContentReset;\n        }\n\n        markRef(current, workInProgress); // Check the host config to see if the children are offscreen/hidden.\n\n        if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {\n          // Down-prioritize the children.\n          workInProgress.expirationTime = Never; // Bailout and come back to this fiber later.\n\n          return null;\n        }\n\n        reconcileChildren(current, workInProgress, nextChildren);\n        memoizeProps(workInProgress, nextProps);\n        return workInProgress.child;\n      }\n\n      function updateHostText(current, workInProgress) {\n        if (current === null) {\n          tryToClaimNextHydratableInstance(workInProgress);\n        }\n\n        var nextProps = workInProgress.pendingProps;\n\n        if (nextProps === null) {\n          nextProps = workInProgress.memoizedProps;\n        }\n\n        memoizeProps(workInProgress, nextProps); // Nothing to do here. This is terminal. We'll do the completion step\n        // immediately after.\n\n        return null;\n      }\n\n      function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {\n        !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        var fn = workInProgress.type;\n        var props = workInProgress.pendingProps;\n        var unmaskedContext = getUnmaskedContext(workInProgress);\n        var context = getMaskedContext(workInProgress, unmaskedContext);\n        var value;\n        {\n          if (fn.prototype && typeof fn.prototype.render === 'function') {\n            var componentName = getComponentName(workInProgress);\n            warning(false, \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n          }\n\n          ReactCurrentOwner.current = workInProgress;\n          value = fn(props, context);\n        } // React DevTools reads this flag.\n\n        workInProgress.effectTag |= PerformedWork;\n\n        if (typeof value === 'object' && value !== null && typeof value.render === 'function') {\n          // Proceed under the assumption that this is a class instance\n          workInProgress.tag = ClassComponent; // Push context providers early to prevent context stack mismatches.\n          // During mounting we don't know the child context yet as the instance doesn't exist.\n          // We will invalidate the child context in finishClassComponent() right after rendering.\n\n          var hasContext = pushContextProvider(workInProgress);\n          adoptClassInstance(workInProgress, value);\n          mountClassInstance(workInProgress, renderExpirationTime);\n          return finishClassComponent(current, workInProgress, true, hasContext);\n        } else {\n          // Proceed under the assumption that this is a functional component\n          workInProgress.tag = FunctionalComponent;\n          {\n            var Component = workInProgress.type;\n\n            if (Component) {\n              warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');\n            }\n\n            if (workInProgress.ref !== null) {\n              var info = '';\n              var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n\n              if (ownerName) {\n                info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n              }\n\n              var warningKey = ownerName || workInProgress._debugID || '';\n              var debugSource = workInProgress._debugSource;\n\n              if (debugSource) {\n                warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n              }\n\n              if (!warnedAboutStatelessRefs[warningKey]) {\n                warnedAboutStatelessRefs[warningKey] = true;\n                warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());\n              }\n            }\n          }\n          reconcileChildren(current, workInProgress, value);\n          memoizeProps(workInProgress, props);\n          return workInProgress.child;\n        }\n      }\n\n      function updateCallComponent(current, workInProgress, renderExpirationTime) {\n        var nextCall = workInProgress.pendingProps;\n\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextCall === null) {\n            nextCall = current && current.memoizedProps;\n            !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          }\n        } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {\n          nextCall = workInProgress.memoizedProps; // TODO: When bailing out, we might need to return the stateNode instead\n          // of the child. To check it for work.\n          // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        var nextChildren = nextCall.children; // The following is a fork of reconcileChildrenAtExpirationTime but using\n        // stateNode to store the child.\n\n        if (current === null) {\n          workInProgress.stateNode = mountChildFibersInPlace(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n        } else if (current.child === workInProgress.child) {\n          workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n        } else {\n          workInProgress.stateNode = reconcileChildFibersInPlace(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n        }\n\n        memoizeProps(workInProgress, nextCall); // This doesn't take arbitrary time so we could synchronously just begin\n        // eagerly do the work of workInProgress.child as an optimization.\n\n        return workInProgress.stateNode;\n      }\n\n      function updatePortalComponent(current, workInProgress, renderExpirationTime) {\n        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n        var nextChildren = workInProgress.pendingProps;\n\n        if (hasContextChanged()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextChildren === null) {\n            nextChildren = current && current.memoizedProps;\n            !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          }\n        } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        if (current === null) {\n          // Portals are special because we don't append the children during mount\n          // but at commit. Therefore we need to track insertions which the normal\n          // flow doesn't do during mount. This doesn't happen at the root because\n          // the root always starts with a \"current\" with a null child.\n          // TODO: Consider unifying this with how the root works.\n          workInProgress.child = reconcileChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n          memoizeProps(workInProgress, nextChildren);\n        } else {\n          reconcileChildren(current, workInProgress, nextChildren);\n          memoizeProps(workInProgress, nextChildren);\n        }\n\n        return workInProgress.child;\n      }\n      /*\n      function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n        let child = firstChild;\n        do {\n          // Ensure that the first and last effect of the parent corresponds\n          // to the children's first and last effect.\n          if (!returnFiber.firstEffect) {\n            returnFiber.firstEffect = child.firstEffect;\n          }\n          if (child.lastEffect) {\n            if (returnFiber.lastEffect) {\n              returnFiber.lastEffect.nextEffect = child.firstEffect;\n            }\n            returnFiber.lastEffect = child.lastEffect;\n          }\n        } while (child = child.sibling);\n      }\n      */\n\n\n      function bailoutOnAlreadyFinishedWork(current, workInProgress) {\n        cancelWorkTimer(workInProgress); // TODO: We should ideally be able to bail out early if the children have no\n        // more work to do. However, since we don't have a separation of this\n        // Fiber's priority and its children yet - we don't know without doing lots\n        // of the same work we do anyway. Once we have that separation we can just\n        // bail out here if the children has no more work at this priority level.\n        // if (workInProgress.priorityOfChildren <= priorityLevel) {\n        //   // If there are side-effects in these children that have not yet been\n        //   // committed we need to ensure that they get properly transferred up.\n        //   if (current && current.child !== workInProgress.child) {\n        //     reuseChildrenEffects(workInProgress, child);\n        //   }\n        //   return null;\n        // }\n\n        cloneChildFibers(current, workInProgress);\n        return workInProgress.child;\n      }\n\n      function bailoutOnLowPriority(current, workInProgress) {\n        cancelWorkTimer(workInProgress); // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n        // See PR 8590 discussion for context\n\n        switch (workInProgress.tag) {\n          case HostRoot:\n            pushHostRootContext(workInProgress);\n            break;\n\n          case ClassComponent:\n            pushContextProvider(workInProgress);\n            break;\n\n          case HostPortal:\n            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n            break;\n        } // TODO: What if this is currently in progress?\n        // How can that happen? How is this not being cloned?\n\n\n        return null;\n      } // TODO: Delete memoizeProps/State and move to reconcile/bailout instead\n\n\n      function memoizeProps(workInProgress, nextProps) {\n        workInProgress.memoizedProps = nextProps;\n      }\n\n      function memoizeState(workInProgress, nextState) {\n        workInProgress.memoizedState = nextState; // Don't reset the updateQueue, in case there are pending updates. Resetting\n        // is handled by processUpdateQueue.\n      }\n\n      function beginWork(current, workInProgress, renderExpirationTime) {\n        if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n          return bailoutOnLowPriority(current, workInProgress);\n        }\n\n        switch (workInProgress.tag) {\n          case IndeterminateComponent:\n            return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);\n\n          case FunctionalComponent:\n            return updateFunctionalComponent(current, workInProgress);\n\n          case ClassComponent:\n            return updateClassComponent(current, workInProgress, renderExpirationTime);\n\n          case HostRoot:\n            return updateHostRoot(current, workInProgress, renderExpirationTime);\n\n          case HostComponent:\n            return updateHostComponent(current, workInProgress, renderExpirationTime);\n\n          case HostText:\n            return updateHostText(current, workInProgress);\n\n          case CallHandlerPhase:\n            // This is a restart. Reset the tag to the initial phase.\n            workInProgress.tag = CallComponent;\n          // Intentionally fall through since this is now the same.\n\n          case CallComponent:\n            return updateCallComponent(current, workInProgress, renderExpirationTime);\n\n          case ReturnComponent:\n            // A return component is just a placeholder, we can just run through the\n            // next one immediately.\n            return null;\n\n          case HostPortal:\n            return updatePortalComponent(current, workInProgress, renderExpirationTime);\n\n          case Fragment:\n            return updateFragment(current, workInProgress);\n\n          default:\n            invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n\n      function beginFailedWork(current, workInProgress, renderExpirationTime) {\n        // Push context providers here to avoid a push/pop context mismatch.\n        switch (workInProgress.tag) {\n          case ClassComponent:\n            pushContextProvider(workInProgress);\n            break;\n\n          case HostRoot:\n            pushHostRootContext(workInProgress);\n            break;\n\n          default:\n            invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n        } // Add an error effect so we can handle the error during the commit phase\n\n\n        workInProgress.effectTag |= Err; // This is a weird case where we do \"resume\" work  work that failed on\n        // our first attempt. Because we no longer have a notion of \"progressed\n        // deletions,\" reset the child to the current child to make sure we delete\n        // it again. TODO: Find a better way to handle this, perhaps during a more\n        // general overhaul of error handling.\n\n        if (current === null) {\n          workInProgress.child = null;\n        } else if (workInProgress.child !== current.child) {\n          workInProgress.child = current.child;\n        }\n\n        if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n          return bailoutOnLowPriority(current, workInProgress);\n        } // If we don't bail out, we're going be recomputing our children so we need\n        // to drop our effect list.\n\n\n        workInProgress.firstEffect = null;\n        workInProgress.lastEffect = null; // Unmount the current children as if the component rendered null\n\n        var nextChildren = null;\n        reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);\n\n        if (workInProgress.tag === ClassComponent) {\n          var instance = workInProgress.stateNode;\n          workInProgress.memoizedProps = instance.props;\n          workInProgress.memoizedState = instance.state;\n        }\n\n        return workInProgress.child;\n      }\n\n      return {\n        beginWork: beginWork,\n        beginFailedWork: beginFailedWork\n      };\n    };\n\n    var ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {\n      var createInstance = config.createInstance,\n          createTextInstance = config.createTextInstance,\n          appendInitialChild = config.appendInitialChild,\n          finalizeInitialChildren = config.finalizeInitialChildren,\n          prepareUpdate = config.prepareUpdate,\n          mutation = config.mutation,\n          persistence = config.persistence;\n      var getRootHostContainer = hostContext.getRootHostContainer,\n          popHostContext = hostContext.popHostContext,\n          getHostContext = hostContext.getHostContext,\n          popHostContainer = hostContext.popHostContainer;\n      var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,\n          prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,\n          popHydrationState = hydrationContext.popHydrationState;\n\n      function markUpdate(workInProgress) {\n        // Tag the fiber with an update effect. This turns a Placement into\n        // an UpdateAndPlacement.\n        workInProgress.effectTag |= Update;\n      }\n\n      function markRef(workInProgress) {\n        workInProgress.effectTag |= Ref;\n      }\n\n      function appendAllReturns(returns, workInProgress) {\n        var node = workInProgress.stateNode;\n\n        if (node) {\n          node['return'] = workInProgress;\n        }\n\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {\n            invariant(false, 'A call cannot have host component children.');\n          } else if (node.tag === ReturnComponent) {\n            returns.push(node.type);\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {\n        var call = workInProgress.memoizedProps;\n        !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0; // First step of the call has completed. Now we need to do the second.\n        // TODO: It would be nice to have a multi stage call represented by a\n        // single component, or at least tail call optimize nested ones. Currently\n        // that requires additional fields that we don't want to add to the fiber.\n        // So this requires nested handlers.\n        // Note: This doesn't mutate the alternate node. I don't think it needs to\n        // since this stage is reset for every pass.\n\n        workInProgress.tag = CallHandlerPhase; // Build up the returns.\n        // TODO: Compare this to a generator or opaque helpers like Children.\n\n        var returns = [];\n        appendAllReturns(returns, workInProgress);\n        var fn = call.handler;\n        var props = call.props;\n        var nextChildren = fn(props, returns);\n        var currentFirstChild = current !== null ? current.child : null;\n        workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);\n        return workInProgress.child;\n      }\n\n      function appendAllChildren(parent, workInProgress) {\n        // We only have the top Fiber that was created but we need recurse down its\n        // children to find all the terminal nodes.\n        var node = workInProgress.child;\n\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            appendInitialChild(parent, node.stateNode);\n          } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n\n          if (node === workInProgress) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      var updateHostContainer = void 0;\n      var updateHostComponent = void 0;\n      var updateHostText = void 0;\n\n      if (mutation) {\n        if (enableMutatingReconciler) {\n          // Mutation mode\n          updateHostContainer = function (workInProgress) {// Noop\n          };\n\n          updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n            // TODO: Type this specific to this type of component.\n            workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n            // is a new ref we mark this as an update. All the work is done in commitWork.\n\n            if (updatePayload) {\n              markUpdate(workInProgress);\n            }\n          };\n\n          updateHostText = function (current, workInProgress, oldText, newText) {\n            // If the text differs, mark it as an update. All the work in done in commitWork.\n            if (oldText !== newText) {\n              markUpdate(workInProgress);\n            }\n          };\n        } else {\n          invariant(false, 'Mutating reconciler is disabled.');\n        }\n      } else if (persistence) {\n        if (enablePersistentReconciler) {\n          // Persistent host tree mode\n          var cloneInstance = persistence.cloneInstance,\n              createContainerChildSet = persistence.createContainerChildSet,\n              appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,\n              finalizeContainerChildren = persistence.finalizeContainerChildren; // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n          var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {\n            // We only have the top Fiber that was created but we need recurse down its\n            // children to find all the terminal nodes.\n            var node = workInProgress.child;\n\n            while (node !== null) {\n              if (node.tag === HostComponent || node.tag === HostText) {\n                appendChildToContainerChildSet(containerChildSet, node.stateNode);\n              } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n                // down its children. Instead, we'll get insertions from each child in\n                // the portal directly.\n              } else if (node.child !== null) {\n                node.child['return'] = node;\n                node = node.child;\n                continue;\n              }\n\n              if (node === workInProgress) {\n                return;\n              }\n\n              while (node.sibling === null) {\n                if (node['return'] === null || node['return'] === workInProgress) {\n                  return;\n                }\n\n                node = node['return'];\n              }\n\n              node.sibling['return'] = node['return'];\n              node = node.sibling;\n            }\n          };\n\n          updateHostContainer = function (workInProgress) {\n            var portalOrRoot = workInProgress.stateNode;\n            var childrenUnchanged = workInProgress.firstEffect === null;\n\n            if (childrenUnchanged) {// No changes, just reuse the existing instance.\n            } else {\n              var container = portalOrRoot.containerInfo;\n              var newChildSet = createContainerChildSet(container);\n\n              if (finalizeContainerChildren(container, newChildSet)) {\n                markUpdate(workInProgress);\n              }\n\n              portalOrRoot.pendingChildren = newChildSet; // If children might have changed, we have to add them all to the set.\n\n              appendAllChildrenToContainer(newChildSet, workInProgress); // Schedule an update on the container to swap out the container.\n\n              markUpdate(workInProgress);\n            }\n          };\n\n          updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n            // If there are no effects associated with this node, then none of our children had any updates.\n            // This guarantees that we can reuse all of them.\n            var childrenUnchanged = workInProgress.firstEffect === null;\n            var currentInstance = current.stateNode;\n\n            if (childrenUnchanged && updatePayload === null) {\n              // No changes, just reuse the existing instance.\n              // Note that this might release a previous clone.\n              workInProgress.stateNode = currentInstance;\n            } else {\n              var recyclableInstance = workInProgress.stateNode;\n              var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n\n              if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {\n                markUpdate(workInProgress);\n              }\n\n              workInProgress.stateNode = newInstance;\n\n              if (childrenUnchanged) {\n                // If there are no other effects in this tree, we need to flag this node as having one.\n                // Even though we're not going to use it for anything.\n                // Otherwise parents won't know that there are new children to propagate upwards.\n                markUpdate(workInProgress);\n              } else {\n                // If children might have changed, we have to add them all to the set.\n                appendAllChildren(newInstance, workInProgress);\n              }\n            }\n          };\n\n          updateHostText = function (current, workInProgress, oldText, newText) {\n            if (oldText !== newText) {\n              // If the text content differs, we'll create a new text instance for it.\n              var rootContainerInstance = getRootHostContainer();\n              var currentHostContext = getHostContext();\n              workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n              // This lets the parents know that at least one of their children has changed.\n\n              markUpdate(workInProgress);\n            }\n          };\n        } else {\n          invariant(false, 'Persistent reconciler is disabled.');\n        }\n      } else {\n        if (enableNoopReconciler) {\n          // No host operations\n          updateHostContainer = function (workInProgress) {// Noop\n          };\n\n          updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {// Noop\n          };\n\n          updateHostText = function (current, workInProgress, oldText, newText) {// Noop\n          };\n        } else {\n          invariant(false, 'Noop reconciler is disabled.');\n        }\n      }\n\n      function completeWork(current, workInProgress, renderExpirationTime) {\n        // Get the latest props.\n        var newProps = workInProgress.pendingProps;\n\n        if (newProps === null) {\n          newProps = workInProgress.memoizedProps;\n        } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {\n          // Reset the pending props, unless this was a down-prioritization.\n          workInProgress.pendingProps = null;\n        }\n\n        switch (workInProgress.tag) {\n          case FunctionalComponent:\n            return null;\n\n          case ClassComponent:\n            {\n              // We are leaving this subtree, so pop context if any.\n              popContextProvider(workInProgress);\n              return null;\n            }\n\n          case HostRoot:\n            {\n              popHostContainer(workInProgress);\n              popTopLevelContextObject(workInProgress);\n              var fiberRoot = workInProgress.stateNode;\n\n              if (fiberRoot.pendingContext) {\n                fiberRoot.context = fiberRoot.pendingContext;\n                fiberRoot.pendingContext = null;\n              }\n\n              if (current === null || current.child === null) {\n                // If we hydrated, pop so that we can delete any remaining children\n                // that weren't hydrated.\n                popHydrationState(workInProgress); // This resets the hacky state to fix isMounted before committing.\n                // TODO: Delete this when we delete isMounted and findDOMNode.\n\n                workInProgress.effectTag &= ~Placement;\n              }\n\n              updateHostContainer(workInProgress);\n              return null;\n            }\n\n          case HostComponent:\n            {\n              popHostContext(workInProgress);\n              var rootContainerInstance = getRootHostContainer();\n              var type = workInProgress.type;\n\n              if (current !== null && workInProgress.stateNode != null) {\n                // If we have an alternate, that means this is an update and we need to\n                // schedule a side-effect to do the updates.\n                var oldProps = current.memoizedProps; // If we get updated because one of our children updated, we don't\n                // have newProps so we'll have to reuse them.\n                // TODO: Split the update API as separate for the props vs. children.\n                // Even better would be if children weren't special cased at all tho.\n\n                var instance = workInProgress.stateNode;\n                var currentHostContext = getHostContext();\n                var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n                updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);\n\n                if (current.ref !== workInProgress.ref) {\n                  markRef(workInProgress);\n                }\n              } else {\n                if (!newProps) {\n                  !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0; // This can happen when we abort work.\n\n                  return null;\n                }\n\n                var _currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n                // \"stack\" as the parent. Then append children as we go in beginWork\n                // or completeWork depending on we want to add then top->down or\n                // bottom->up. Top->down is faster in IE11.\n\n\n                var wasHydrated = popHydrationState(workInProgress);\n\n                if (wasHydrated) {\n                  // TODO: Move this and createInstance step into the beginPhase\n                  // to consolidate.\n                  if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {\n                    // If changes to the hydrated node needs to be applied at the\n                    // commit-phase we mark this as such.\n                    markUpdate(workInProgress);\n                  }\n                } else {\n                  var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);\n\n                  appendAllChildren(_instance, workInProgress); // Certain renderers require commit-time effects for initial mount.\n                  // (eg DOM renderer supports auto-focus for certain elements).\n                  // Make sure such renderers get scheduled for later work.\n\n                  if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {\n                    markUpdate(workInProgress);\n                  }\n\n                  workInProgress.stateNode = _instance;\n                }\n\n                if (workInProgress.ref !== null) {\n                  // If there is a ref on a host node we need to schedule a callback\n                  markRef(workInProgress);\n                }\n              }\n\n              return null;\n            }\n\n          case HostText:\n            {\n              var newText = newProps;\n\n              if (current && workInProgress.stateNode != null) {\n                var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n                // to schedule a side-effect to do the updates.\n\n                updateHostText(current, workInProgress, oldText, newText);\n              } else {\n                if (typeof newText !== 'string') {\n                  !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0; // This can happen when we abort work.\n\n                  return null;\n                }\n\n                var _rootContainerInstance = getRootHostContainer();\n\n                var _currentHostContext2 = getHostContext();\n\n                var _wasHydrated = popHydrationState(workInProgress);\n\n                if (_wasHydrated) {\n                  if (prepareToHydrateHostTextInstance(workInProgress)) {\n                    markUpdate(workInProgress);\n                  }\n                } else {\n                  workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);\n                }\n              }\n\n              return null;\n            }\n\n          case CallComponent:\n            return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);\n\n          case CallHandlerPhase:\n            // Reset the tag to now be a first phase call.\n            workInProgress.tag = CallComponent;\n            return null;\n\n          case ReturnComponent:\n            // Does nothing.\n            return null;\n\n          case Fragment:\n            return null;\n\n          case HostPortal:\n            popHostContainer(workInProgress);\n            updateHostContainer(workInProgress);\n            return null;\n          // Error cases\n\n          case IndeterminateComponent:\n            invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');\n          // eslint-disable-next-line no-fallthrough\n\n          default:\n            invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n\n      return {\n        completeWork: completeWork\n      };\n    };\n\n    var invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;\n    var hasCaughtError$1 = ReactErrorUtils.hasCaughtError;\n    var clearCaughtError$1 = ReactErrorUtils.clearCaughtError;\n\n    var ReactFiberCommitWork = function (config, captureError) {\n      var getPublicInstance = config.getPublicInstance,\n          mutation = config.mutation,\n          persistence = config.persistence;\n\n      var callComponentWillUnmountWithTimer = function (current, instance) {\n        startPhaseTimer(current, 'componentWillUnmount');\n        instance.props = current.memoizedProps;\n        instance.state = current.memoizedState;\n        instance.componentWillUnmount();\n        stopPhaseTimer();\n      }; // Capture errors so they don't interrupt unmounting.\n\n\n      function safelyCallComponentWillUnmount(current, instance) {\n        {\n          invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);\n\n          if (hasCaughtError$1()) {\n            var unmountError = clearCaughtError$1();\n            captureError(current, unmountError);\n          }\n        }\n      }\n\n      function safelyDetachRef(current) {\n        var ref = current.ref;\n\n        if (ref !== null) {\n          {\n            invokeGuardedCallback$2(null, ref, null, null);\n\n            if (hasCaughtError$1()) {\n              var refError = clearCaughtError$1();\n              captureError(current, refError);\n            }\n          }\n        }\n      }\n\n      function commitLifeCycles(current, finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent:\n            {\n              var instance = finishedWork.stateNode;\n\n              if (finishedWork.effectTag & Update) {\n                if (current === null) {\n                  startPhaseTimer(finishedWork, 'componentDidMount');\n                  instance.props = finishedWork.memoizedProps;\n                  instance.state = finishedWork.memoizedState;\n                  instance.componentDidMount();\n                  stopPhaseTimer();\n                } else {\n                  var prevProps = current.memoizedProps;\n                  var prevState = current.memoizedState;\n                  startPhaseTimer(finishedWork, 'componentDidUpdate');\n                  instance.props = finishedWork.memoizedProps;\n                  instance.state = finishedWork.memoizedState;\n                  instance.componentDidUpdate(prevProps, prevState);\n                  stopPhaseTimer();\n                }\n              }\n\n              var updateQueue = finishedWork.updateQueue;\n\n              if (updateQueue !== null) {\n                commitCallbacks(updateQueue, instance);\n              }\n\n              return;\n            }\n\n          case HostRoot:\n            {\n              var _updateQueue = finishedWork.updateQueue;\n\n              if (_updateQueue !== null) {\n                var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;\n\n                commitCallbacks(_updateQueue, _instance);\n              }\n\n              return;\n            }\n\n          case HostComponent:\n            {\n              var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted\n              // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n              // These effects should only be committed when components are first mounted,\n              // aka when there is no current/alternate.\n\n              if (current === null && finishedWork.effectTag & Update) {\n                var type = finishedWork.type;\n                var props = finishedWork.memoizedProps;\n                commitMount(_instance2, type, props, finishedWork);\n              }\n\n              return;\n            }\n\n          case HostText:\n            {\n              // We have no life-cycles associated with text.\n              return;\n            }\n\n          case HostPortal:\n            {\n              // We have no life-cycles associated with portals.\n              return;\n            }\n\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      }\n\n      function commitAttachRef(finishedWork) {\n        var ref = finishedWork.ref;\n\n        if (ref !== null) {\n          var instance = finishedWork.stateNode;\n\n          switch (finishedWork.tag) {\n            case HostComponent:\n              ref(getPublicInstance(instance));\n              break;\n\n            default:\n              ref(instance);\n          }\n        }\n      }\n\n      function commitDetachRef(current) {\n        var currentRef = current.ref;\n\n        if (currentRef !== null) {\n          currentRef(null);\n        }\n      } // User-originating errors (lifecycles and refs) should not interrupt\n      // deletion, so don't let them throw. Host-originating errors should\n      // interrupt deletion, so it's okay\n\n\n      function commitUnmount(current) {\n        if (typeof onCommitUnmount === 'function') {\n          onCommitUnmount(current);\n        }\n\n        switch (current.tag) {\n          case ClassComponent:\n            {\n              safelyDetachRef(current);\n              var instance = current.stateNode;\n\n              if (typeof instance.componentWillUnmount === 'function') {\n                safelyCallComponentWillUnmount(current, instance);\n              }\n\n              return;\n            }\n\n          case HostComponent:\n            {\n              safelyDetachRef(current);\n              return;\n            }\n\n          case CallComponent:\n            {\n              commitNestedUnmounts(current.stateNode);\n              return;\n            }\n\n          case HostPortal:\n            {\n              // TODO: this is recursive.\n              // We are also not using this parent because\n              // the portal will get pushed immediately.\n              if (enableMutatingReconciler && mutation) {\n                unmountHostComponents(current);\n              } else if (enablePersistentReconciler && persistence) {\n                emptyPortalContainer(current);\n              }\n\n              return;\n            }\n        }\n      }\n\n      function commitNestedUnmounts(root) {\n        // While we're inside a removed host node we don't want to call\n        // removeChild on the inner nodes because they're removed by the top\n        // call anyway. We also want to call componentWillUnmount on all\n        // composites before this host node is removed from the tree. Therefore\n        var node = root;\n\n        while (true) {\n          commitUnmount(node); // Visit children because they may contain more composite or host nodes.\n          // Skip portals because commitUnmount() currently visits them recursively.\n\n          if (node.child !== null && ( // If we use mutation we drill down into portals using commitUnmount above.\n          // If we don't use mutation we drill down into portals here instead.\n          !mutation || node.tag !== HostPortal)) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n\n          if (node === root) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === root) {\n              return;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      function detachFiber(current) {\n        // Cut off the return pointers to disconnect it from the tree. Ideally, we\n        // should clear the child pointer of the parent alternate to let this\n        // get GC:ed but we don't know which for sure which parent is the current\n        // one so we'll settle for GC:ing the subtree of this child. This child\n        // itself will be GC:ed when the parent updates the next time.\n        current['return'] = null;\n        current.child = null;\n\n        if (current.alternate) {\n          current.alternate.child = null;\n          current.alternate['return'] = null;\n        }\n      }\n\n      if (!mutation) {\n        var commitContainer = void 0;\n\n        if (persistence) {\n          var replaceContainerChildren = persistence.replaceContainerChildren,\n              createContainerChildSet = persistence.createContainerChildSet;\n\n          var emptyPortalContainer = function (current) {\n            var portal = current.stateNode;\n            var containerInfo = portal.containerInfo;\n            var emptyChildSet = createContainerChildSet(containerInfo);\n            replaceContainerChildren(containerInfo, emptyChildSet);\n          };\n\n          commitContainer = function (finishedWork) {\n            switch (finishedWork.tag) {\n              case ClassComponent:\n                {\n                  return;\n                }\n\n              case HostComponent:\n                {\n                  return;\n                }\n\n              case HostText:\n                {\n                  return;\n                }\n\n              case HostRoot:\n              case HostPortal:\n                {\n                  var portalOrRoot = finishedWork.stateNode;\n                  var containerInfo = portalOrRoot.containerInfo,\n                      _pendingChildren = portalOrRoot.pendingChildren;\n                  replaceContainerChildren(containerInfo, _pendingChildren);\n                  return;\n                }\n\n              default:\n                {\n                  invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n                }\n            }\n          };\n        } else {\n          commitContainer = function (finishedWork) {// Noop\n          };\n        }\n\n        if (enablePersistentReconciler || enableNoopReconciler) {\n          return {\n            commitResetTextContent: function (finishedWork) {},\n            commitPlacement: function (finishedWork) {},\n            commitDeletion: function (current) {\n              // Detach refs and call componentWillUnmount() on the whole subtree.\n              commitNestedUnmounts(current);\n              detachFiber(current);\n            },\n            commitWork: function (current, finishedWork) {\n              commitContainer(finishedWork);\n            },\n            commitLifeCycles: commitLifeCycles,\n            commitAttachRef: commitAttachRef,\n            commitDetachRef: commitDetachRef\n          };\n        } else if (persistence) {\n          invariant(false, 'Persistent reconciler is disabled.');\n        } else {\n          invariant(false, 'Noop reconciler is disabled.');\n        }\n      }\n\n      var commitMount = mutation.commitMount,\n          commitUpdate = mutation.commitUpdate,\n          resetTextContent = mutation.resetTextContent,\n          commitTextUpdate = mutation.commitTextUpdate,\n          appendChild = mutation.appendChild,\n          appendChildToContainer = mutation.appendChildToContainer,\n          insertBefore = mutation.insertBefore,\n          insertInContainerBefore = mutation.insertInContainerBefore,\n          removeChild = mutation.removeChild,\n          removeChildFromContainer = mutation.removeChildFromContainer;\n\n      function getHostParentFiber(fiber) {\n        var parent = fiber['return'];\n\n        while (parent !== null) {\n          if (isHostParent(parent)) {\n            return parent;\n          }\n\n          parent = parent['return'];\n        }\n\n        invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');\n      }\n\n      function isHostParent(fiber) {\n        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n      }\n\n      function getHostSibling(fiber) {\n        // We're going to search forward into the tree until we find a sibling host\n        // node. Unfortunately, if multiple insertions are done in a row we have to\n        // search past them. This leads to exponential search for the next sibling.\n        var node = fiber;\n\n        siblings: while (true) {\n          // If we didn't find anything, let's try the next sibling.\n          while (node.sibling === null) {\n            if (node['return'] === null || isHostParent(node['return'])) {\n              // If we pop out of the root or hit the parent the fiber we are the\n              // last sibling.\n              return null;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n\n          while (node.tag !== HostComponent && node.tag !== HostText) {\n            // If it is not host node and, we might have a host node inside it.\n            // Try to search down until we find one.\n            if (node.effectTag & Placement) {\n              // If we don't have a child, try the siblings instead.\n              continue siblings;\n            } // If we don't have a child, try the siblings instead.\n            // We also skip portals because they are not part of this host tree.\n\n\n            if (node.child === null || node.tag === HostPortal) {\n              continue siblings;\n            } else {\n              node.child['return'] = node;\n              node = node.child;\n            }\n          } // Check if this host node is stable or about to be placed.\n\n\n          if (!(node.effectTag & Placement)) {\n            // Found it!\n            return node.stateNode;\n          }\n        }\n      }\n\n      function commitPlacement(finishedWork) {\n        // Recursively insert all host nodes into the parent.\n        var parentFiber = getHostParentFiber(finishedWork);\n        var parent = void 0;\n        var isContainer = void 0;\n\n        switch (parentFiber.tag) {\n          case HostComponent:\n            parent = parentFiber.stateNode;\n            isContainer = false;\n            break;\n\n          case HostRoot:\n            parent = parentFiber.stateNode.containerInfo;\n            isContainer = true;\n            break;\n\n          case HostPortal:\n            parent = parentFiber.stateNode.containerInfo;\n            isContainer = true;\n            break;\n\n          default:\n            invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');\n        }\n\n        if (parentFiber.effectTag & ContentReset) {\n          // Reset the text content of the parent before doing any insertions\n          resetTextContent(parent); // Clear ContentReset from the effect tag\n\n          parentFiber.effectTag &= ~ContentReset;\n        }\n\n        var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need recurse down its\n        // children to find all the terminal nodes.\n\n        var node = finishedWork;\n\n        while (true) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            if (before) {\n              if (isContainer) {\n                insertInContainerBefore(parent, node.stateNode, before);\n              } else {\n                insertBefore(parent, node.stateNode, before);\n              }\n            } else {\n              if (isContainer) {\n                appendChildToContainer(parent, node.stateNode);\n              } else {\n                appendChild(parent, node.stateNode);\n              }\n            }\n          } else if (node.tag === HostPortal) {// If the insertion itself is a portal, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n\n          if (node === finishedWork) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === finishedWork) {\n              return;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      function unmountHostComponents(current) {\n        // We only have the top Fiber that was inserted but we need recurse down its\n        var node = current; // Each iteration, currentParent is populated with node's host parent if not\n        // currentParentIsValid.\n\n        var currentParentIsValid = false;\n        var currentParent = void 0;\n        var currentParentIsContainer = void 0;\n\n        while (true) {\n          if (!currentParentIsValid) {\n            var parent = node['return'];\n\n            findParent: while (true) {\n              !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n              switch (parent.tag) {\n                case HostComponent:\n                  currentParent = parent.stateNode;\n                  currentParentIsContainer = false;\n                  break findParent;\n\n                case HostRoot:\n                  currentParent = parent.stateNode.containerInfo;\n                  currentParentIsContainer = true;\n                  break findParent;\n\n                case HostPortal:\n                  currentParent = parent.stateNode.containerInfo;\n                  currentParentIsContainer = true;\n                  break findParent;\n              }\n\n              parent = parent['return'];\n            }\n\n            currentParentIsValid = true;\n          }\n\n          if (node.tag === HostComponent || node.tag === HostText) {\n            commitNestedUnmounts(node); // After all the children have unmounted, it is now safe to remove the\n            // node from the tree.\n\n            if (currentParentIsContainer) {\n              removeChildFromContainer(currentParent, node.stateNode);\n            } else {\n              removeChild(currentParent, node.stateNode);\n            } // Don't visit children because we already visited them.\n\n          } else if (node.tag === HostPortal) {\n            // When we go into a portal, it becomes the parent to remove from.\n            // We will reassign it back when we pop the portal on the way up.\n            currentParent = node.stateNode.containerInfo; // Visit children because portals might contain host components.\n\n            if (node.child !== null) {\n              node.child['return'] = node;\n              node = node.child;\n              continue;\n            }\n          } else {\n            commitUnmount(node); // Visit children because we may find more host components below.\n\n            if (node.child !== null) {\n              node.child['return'] = node;\n              node = node.child;\n              continue;\n            }\n          }\n\n          if (node === current) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === current) {\n              return;\n            }\n\n            node = node['return'];\n\n            if (node.tag === HostPortal) {\n              // When we go out of the portal, we need to restore the parent.\n              // Since we don't keep a stack of them, we will search for it.\n              currentParentIsValid = false;\n            }\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      function commitDeletion(current) {\n        // Recursively delete all host nodes from the parent.\n        // Detach refs and call componentWillUnmount() on the whole subtree.\n        unmountHostComponents(current);\n        detachFiber(current);\n      }\n\n      function commitWork(current, finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent:\n            {\n              return;\n            }\n\n          case HostComponent:\n            {\n              var instance = finishedWork.stateNode;\n\n              if (instance != null) {\n                // Commit the work prepared earlier.\n                var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                // as the newProps. The updatePayload will contain the real change in\n                // this case.\n\n                var oldProps = current !== null ? current.memoizedProps : newProps;\n                var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\n\n                var updatePayload = finishedWork.updateQueue;\n                finishedWork.updateQueue = null;\n\n                if (updatePayload !== null) {\n                  commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n                }\n              }\n\n              return;\n            }\n\n          case HostText:\n            {\n              !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              var textInstance = finishedWork.stateNode;\n              var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n              // as the newProps. The updatePayload will contain the real change in\n              // this case.\n\n              var oldText = current !== null ? current.memoizedProps : newText;\n              commitTextUpdate(textInstance, oldText, newText);\n              return;\n            }\n\n          case HostRoot:\n            {\n              return;\n            }\n\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      }\n\n      function commitResetTextContent(current) {\n        resetTextContent(current.stateNode);\n      }\n\n      if (enableMutatingReconciler) {\n        return {\n          commitResetTextContent: commitResetTextContent,\n          commitPlacement: commitPlacement,\n          commitDeletion: commitDeletion,\n          commitWork: commitWork,\n          commitLifeCycles: commitLifeCycles,\n          commitAttachRef: commitAttachRef,\n          commitDetachRef: commitDetachRef\n        };\n      } else {\n        invariant(false, 'Mutating reconciler is disabled.');\n      }\n    };\n\n    var NO_CONTEXT = {};\n\n    var ReactFiberHostContext = function (config) {\n      var getChildHostContext = config.getChildHostContext,\n          getRootHostContext = config.getRootHostContext;\n      var contextStackCursor = createCursor(NO_CONTEXT);\n      var contextFiberStackCursor = createCursor(NO_CONTEXT);\n      var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\n      function requiredContext(c) {\n        !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        return c;\n      }\n\n      function getRootHostContainer() {\n        var rootInstance = requiredContext(rootInstanceStackCursor.current);\n        return rootInstance;\n      }\n\n      function pushHostContainer(fiber, nextRootInstance) {\n        // Push current root instance onto the stack;\n        // This allows us to reset root when portals are popped.\n        push(rootInstanceStackCursor, nextRootInstance, fiber);\n        var nextRootContext = getRootHostContext(nextRootInstance); // Track the context and the Fiber that provided it.\n        // This enables us to pop only Fibers that provide unique contexts.\n\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor, nextRootContext, fiber);\n      }\n\n      function popHostContainer(fiber) {\n        pop(contextStackCursor, fiber);\n        pop(contextFiberStackCursor, fiber);\n        pop(rootInstanceStackCursor, fiber);\n      }\n\n      function getHostContext() {\n        var context = requiredContext(contextStackCursor.current);\n        return context;\n      }\n\n      function pushHostContext(fiber) {\n        var rootInstance = requiredContext(rootInstanceStackCursor.current);\n        var context = requiredContext(contextStackCursor.current);\n        var nextContext = getChildHostContext(context, fiber.type, rootInstance); // Don't push this Fiber's context unless it's unique.\n\n        if (context === nextContext) {\n          return;\n        } // Track the context and the Fiber that provided it.\n        // This enables us to pop only Fibers that provide unique contexts.\n\n\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor, nextContext, fiber);\n      }\n\n      function popHostContext(fiber) {\n        // Do not pop unless this Fiber provided the current context.\n        // pushHostContext() only pushes Fibers that provide unique contexts.\n        if (contextFiberStackCursor.current !== fiber) {\n          return;\n        }\n\n        pop(contextStackCursor, fiber);\n        pop(contextFiberStackCursor, fiber);\n      }\n\n      function resetHostContainer() {\n        contextStackCursor.current = NO_CONTEXT;\n        rootInstanceStackCursor.current = NO_CONTEXT;\n      }\n\n      return {\n        getHostContext: getHostContext,\n        getRootHostContainer: getRootHostContainer,\n        popHostContainer: popHostContainer,\n        popHostContext: popHostContext,\n        pushHostContainer: pushHostContainer,\n        pushHostContext: pushHostContext,\n        resetHostContainer: resetHostContainer\n      };\n    };\n\n    var ReactFiberHydrationContext = function (config) {\n      var shouldSetTextContent = config.shouldSetTextContent,\n          hydration = config.hydration; // If this doesn't have hydration mode.\n\n      if (!hydration) {\n        return {\n          enterHydrationState: function () {\n            return false;\n          },\n          resetHydrationState: function () {},\n          tryToClaimNextHydratableInstance: function () {},\n          prepareToHydrateHostInstance: function () {\n            invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n          },\n          prepareToHydrateHostTextInstance: function () {\n            invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n          },\n          popHydrationState: function (fiber) {\n            return false;\n          }\n        };\n      }\n\n      var canHydrateInstance = hydration.canHydrateInstance,\n          canHydrateTextInstance = hydration.canHydrateTextInstance,\n          getNextHydratableSibling = hydration.getNextHydratableSibling,\n          getFirstHydratableChild = hydration.getFirstHydratableChild,\n          hydrateInstance = hydration.hydrateInstance,\n          hydrateTextInstance = hydration.hydrateTextInstance,\n          didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,\n          didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,\n          didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,\n          didNotHydrateInstance = hydration.didNotHydrateInstance,\n          didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,\n          didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,\n          didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,\n          didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance; // The deepest Fiber on the stack involved in a hydration context.\n      // This may have been an insertion or a hydration.\n\n      var hydrationParentFiber = null;\n      var nextHydratableInstance = null;\n      var isHydrating = false;\n\n      function enterHydrationState(fiber) {\n        var parentInstance = fiber.stateNode.containerInfo;\n        nextHydratableInstance = getFirstHydratableChild(parentInstance);\n        hydrationParentFiber = fiber;\n        isHydrating = true;\n        return true;\n      }\n\n      function deleteHydratableInstance(returnFiber, instance) {\n        {\n          switch (returnFiber.tag) {\n            case HostRoot:\n              didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\n              break;\n\n            case HostComponent:\n              didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n              break;\n          }\n        }\n        var childToDelete = createFiberFromHostInstanceForDeletion();\n        childToDelete.stateNode = instance;\n        childToDelete['return'] = returnFiber;\n        childToDelete.effectTag = Deletion; // This might seem like it belongs on progressedFirstDeletion. However,\n        // these children are not part of the reconciliation list of children.\n        // Even if we abort and rereconcile the children, that will try to hydrate\n        // again and the nodes are still in the host tree so these will be\n        // recreated.\n\n        if (returnFiber.lastEffect !== null) {\n          returnFiber.lastEffect.nextEffect = childToDelete;\n          returnFiber.lastEffect = childToDelete;\n        } else {\n          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n        }\n      }\n\n      function insertNonHydratedInstance(returnFiber, fiber) {\n        fiber.effectTag |= Placement;\n        {\n          switch (returnFiber.tag) {\n            case HostRoot:\n              {\n                var parentContainer = returnFiber.stateNode.containerInfo;\n\n                switch (fiber.tag) {\n                  case HostComponent:\n                    var type = fiber.type;\n                    var props = fiber.pendingProps;\n                    didNotFindHydratableContainerInstance(parentContainer, type, props);\n                    break;\n\n                  case HostText:\n                    var text = fiber.pendingProps;\n                    didNotFindHydratableContainerTextInstance(parentContainer, text);\n                    break;\n                }\n\n                break;\n              }\n\n            case HostComponent:\n              {\n                var parentType = returnFiber.type;\n                var parentProps = returnFiber.memoizedProps;\n                var parentInstance = returnFiber.stateNode;\n\n                switch (fiber.tag) {\n                  case HostComponent:\n                    var _type = fiber.type;\n                    var _props = fiber.pendingProps;\n                    didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n                    break;\n\n                  case HostText:\n                    var _text = fiber.pendingProps;\n                    didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n                    break;\n                }\n\n                break;\n              }\n\n            default:\n              return;\n          }\n        }\n      }\n\n      function tryHydrate(fiber, nextInstance) {\n        switch (fiber.tag) {\n          case HostComponent:\n            {\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              var instance = canHydrateInstance(nextInstance, type, props);\n\n              if (instance !== null) {\n                fiber.stateNode = instance;\n                return true;\n              }\n\n              return false;\n            }\n\n          case HostText:\n            {\n              var text = fiber.pendingProps;\n              var textInstance = canHydrateTextInstance(nextInstance, text);\n\n              if (textInstance !== null) {\n                fiber.stateNode = textInstance;\n                return true;\n              }\n\n              return false;\n            }\n\n          default:\n            return false;\n        }\n      }\n\n      function tryToClaimNextHydratableInstance(fiber) {\n        if (!isHydrating) {\n          return;\n        }\n\n        var nextInstance = nextHydratableInstance;\n\n        if (!nextInstance) {\n          // Nothing to hydrate. Make it an insertion.\n          insertNonHydratedInstance(hydrationParentFiber, fiber);\n          isHydrating = false;\n          hydrationParentFiber = fiber;\n          return;\n        }\n\n        if (!tryHydrate(fiber, nextInstance)) {\n          // If we can't hydrate this instance let's try the next one.\n          // We use this as a heuristic. It's based on intuition and not data so it\n          // might be flawed or unnecessary.\n          nextInstance = getNextHydratableSibling(nextInstance);\n\n          if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n            // Nothing to hydrate. Make it an insertion.\n            insertNonHydratedInstance(hydrationParentFiber, fiber);\n            isHydrating = false;\n            hydrationParentFiber = fiber;\n            return;\n          } // We matched the next one, we'll now assume that the first one was\n          // superfluous and we'll delete it. Since we can't eagerly delete it\n          // we'll have to schedule a deletion. To do that, this node needs a dummy\n          // fiber associated with it.\n\n\n          deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);\n        }\n\n        hydrationParentFiber = fiber;\n        nextHydratableInstance = getFirstHydratableChild(nextInstance);\n      }\n\n      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n        var instance = fiber.stateNode;\n        var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber); // TODO: Type this specific to this type of component.\n\n        fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n        // is a new ref we mark this as an update.\n\n        if (updatePayload !== null) {\n          return true;\n        }\n\n        return false;\n      }\n\n      function prepareToHydrateHostTextInstance(fiber) {\n        var textInstance = fiber.stateNode;\n        var textContent = fiber.memoizedProps;\n        var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n        {\n          if (shouldUpdate) {\n            // We assume that prepareToHydrateHostTextInstance is called in a context where the\n            // hydration parent is the parent host component of this host text.\n            var returnFiber = hydrationParentFiber;\n\n            if (returnFiber !== null) {\n              switch (returnFiber.tag) {\n                case HostRoot:\n                  {\n                    var parentContainer = returnFiber.stateNode.containerInfo;\n                    didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n                    break;\n                  }\n\n                case HostComponent:\n                  {\n                    var parentType = returnFiber.type;\n                    var parentProps = returnFiber.memoizedProps;\n                    var parentInstance = returnFiber.stateNode;\n                    didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n                    break;\n                  }\n              }\n            }\n          }\n        }\n        return shouldUpdate;\n      }\n\n      function popToNextHostParent(fiber) {\n        var parent = fiber['return'];\n\n        while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {\n          parent = parent['return'];\n        }\n\n        hydrationParentFiber = parent;\n      }\n\n      function popHydrationState(fiber) {\n        if (fiber !== hydrationParentFiber) {\n          // We're deeper than the current hydration context, inside an inserted\n          // tree.\n          return false;\n        }\n\n        if (!isHydrating) {\n          // If we're not currently hydrating but we're in a hydration context, then\n          // we were an insertion and now need to pop up reenter hydration of our\n          // siblings.\n          popToNextHostParent(fiber);\n          isHydrating = true;\n          return false;\n        }\n\n        var type = fiber.type; // If we have any remaining hydratable nodes, we need to delete them now.\n        // We only do this deeper than head and body since they tend to have random\n        // other nodes in them. We also ignore components with pure text content in\n        // side of them.\n        // TODO: Better heuristic.\n\n        if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n          var nextInstance = nextHydratableInstance;\n\n          while (nextInstance) {\n            deleteHydratableInstance(fiber, nextInstance);\n            nextInstance = getNextHydratableSibling(nextInstance);\n          }\n        }\n\n        popToNextHostParent(fiber);\n        nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n        return true;\n      }\n\n      function resetHydrationState() {\n        hydrationParentFiber = null;\n        nextHydratableInstance = null;\n        isHydrating = false;\n      }\n\n      return {\n        enterHydrationState: enterHydrationState,\n        resetHydrationState: resetHydrationState,\n        tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,\n        prepareToHydrateHostInstance: prepareToHydrateHostInstance,\n        prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,\n        popHydrationState: popHydrationState\n      };\n    }; // This lets us hook into Fiber to debug what it's doing.\n    // See https://github.com/facebook/react/pull/8033.\n    // This is not part of the public API, not even for React DevTools.\n    // You may only inject a debugTool if you work on React Fiber itself.\n\n\n    var ReactFiberInstrumentation = {\n      debugTool: null\n    };\n    var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\n    var defaultShowDialog = function (capturedError) {\n      return true;\n    };\n\n    var showDialog = defaultShowDialog;\n\n    function logCapturedError(capturedError) {\n      var logError = showDialog(capturedError); // Allow injected showDialog() to prevent default console.error logging.\n      // This enables renderers like ReactNative to better manage redbox behavior.\n\n      if (logError === false) {\n        return;\n      }\n\n      {\n        var componentName = capturedError.componentName,\n            componentStack = capturedError.componentStack,\n            errorBoundaryName = capturedError.errorBoundaryName,\n            errorBoundaryFound = capturedError.errorBoundaryFound,\n            willRetry = capturedError.willRetry;\n        var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';\n        var errorBoundaryMessage = void 0; // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n\n        if (errorBoundaryFound && errorBoundaryName) {\n          if (willRetry) {\n            errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');\n          } else {\n            errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';\n          }\n        } else {\n          errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';\n        }\n\n        var combinedMessage = '' + componentNameMessage + componentStack + '\\n\\n' + ('' + errorBoundaryMessage); // In development, we provide our own message with just the component stack.\n        // We don't include the original error message and JS stack because the browser\n        // has already printed it. Even if the application swallows the error, it is still\n        // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n\n        console.error(combinedMessage);\n      }\n    }\n\n    var invokeGuardedCallback$1 = ReactErrorUtils.invokeGuardedCallback;\n    var hasCaughtError = ReactErrorUtils.hasCaughtError;\n    var clearCaughtError = ReactErrorUtils.clearCaughtError;\n    {\n      var didWarnAboutStateTransition = false;\n      var didWarnSetStateChildContext = false;\n      var didWarnStateUpdateForUnmountedComponent = {};\n\n      var warnAboutUpdateOnUnmounted = function (fiber) {\n        var componentName = getComponentName(fiber) || 'ReactClass';\n\n        if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n          return;\n        }\n\n        warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\\n\\nPlease ' + 'check the code for the %s component.', componentName);\n        didWarnStateUpdateForUnmountedComponent[componentName] = true;\n      };\n\n      var warnAboutInvalidUpdates = function (instance) {\n        switch (ReactDebugCurrentFiber.phase) {\n          case 'getChildContext':\n            if (didWarnSetStateChildContext) {\n              return;\n            }\n\n            warning(false, 'setState(...): Cannot call setState() inside getChildContext()');\n            didWarnSetStateChildContext = true;\n            break;\n\n          case 'render':\n            if (didWarnAboutStateTransition) {\n              return;\n            }\n\n            warning(false, 'Cannot update during an existing state transition (such as within ' + \"`render` or another component's constructor). Render methods should \" + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');\n            didWarnAboutStateTransition = true;\n            break;\n        }\n      };\n    }\n\n    var ReactFiberScheduler = function (config) {\n      var hostContext = ReactFiberHostContext(config);\n      var hydrationContext = ReactFiberHydrationContext(config);\n      var popHostContainer = hostContext.popHostContainer,\n          popHostContext = hostContext.popHostContext,\n          resetHostContainer = hostContext.resetHostContainer;\n\n      var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),\n          beginWork = _ReactFiberBeginWork.beginWork,\n          beginFailedWork = _ReactFiberBeginWork.beginFailedWork;\n\n      var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),\n          completeWork = _ReactFiberCompleteWo.completeWork;\n\n      var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),\n          commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,\n          commitPlacement = _ReactFiberCommitWork.commitPlacement,\n          commitDeletion = _ReactFiberCommitWork.commitDeletion,\n          commitWork = _ReactFiberCommitWork.commitWork,\n          commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,\n          commitAttachRef = _ReactFiberCommitWork.commitAttachRef,\n          commitDetachRef = _ReactFiberCommitWork.commitDetachRef;\n\n      var now = config.now,\n          scheduleDeferredCallback = config.scheduleDeferredCallback,\n          useSyncScheduling = config.useSyncScheduling,\n          prepareForCommit = config.prepareForCommit,\n          resetAfterCommit = config.resetAfterCommit; // Represents the current time in ms.\n\n      var startTime = now();\n      var mostRecentCurrentTime = msToExpirationTime(0); // Represents the expiration time that incoming updates should use. (If this\n      // is NoWork, use the default strategy: async updates in async mode, sync\n      // updates in sync mode.)\n\n      var expirationContext = NoWork;\n      var isWorking = false; // The next work in progress fiber that we're currently working on.\n\n      var nextUnitOfWork = null;\n      var nextRoot = null; // The time at which we're currently rendering work.\n\n      var nextRenderExpirationTime = NoWork; // The next fiber with an effect that we're currently committing.\n\n      var nextEffect = null; // Keep track of which fibers have captured an error that need to be handled.\n      // Work is removed from this collection after componentDidCatch is called.\n\n      var capturedErrors = null; // Keep track of which fibers have failed during the current batch of work.\n      // This is a different set than capturedErrors, because it is not reset until\n      // the end of the batch. This is needed to propagate errors correctly if a\n      // subtree fails more than once.\n\n      var failedBoundaries = null; // Error boundaries that captured an error during the current commit.\n\n      var commitPhaseBoundaries = null;\n      var firstUncaughtError = null;\n      var didFatal = false;\n      var isCommitting = false;\n      var isUnmounting = false; // Used for performance tracking.\n\n      var interruptedBy = null;\n\n      function resetContextStack() {\n        // Reset the stack\n        reset$1(); // Reset the cursors\n\n        resetContext();\n        resetHostContainer();\n      }\n\n      function commitAllHostEffects() {\n        while (nextEffect !== null) {\n          {\n            ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n          }\n          recordEffect();\n          var effectTag = nextEffect.effectTag;\n\n          if (effectTag & ContentReset) {\n            commitResetTextContent(nextEffect);\n          }\n\n          if (effectTag & Ref) {\n            var current = nextEffect.alternate;\n\n            if (current !== null) {\n              commitDetachRef(current);\n            }\n          } // The following switch statement is only concerned about placement,\n          // updates, and deletions. To avoid needing to add a case for every\n          // possible bitmap value, we remove the secondary effects from the\n          // effect tag and switch on that value.\n\n\n          var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);\n\n          switch (primaryEffectTag) {\n            case Placement:\n              {\n                commitPlacement(nextEffect); // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n                // any life-cycles like componentDidMount gets called.\n                // TODO: findDOMNode doesn't rely on this any more but isMounted\n                // does and isMounted is deprecated anyway so we should be able\n                // to kill this.\n\n                nextEffect.effectTag &= ~Placement;\n                break;\n              }\n\n            case PlacementAndUpdate:\n              {\n                // Placement\n                commitPlacement(nextEffect); // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n                // any life-cycles like componentDidMount gets called.\n\n                nextEffect.effectTag &= ~Placement; // Update\n\n                var _current = nextEffect.alternate;\n                commitWork(_current, nextEffect);\n                break;\n              }\n\n            case Update:\n              {\n                var _current2 = nextEffect.alternate;\n                commitWork(_current2, nextEffect);\n                break;\n              }\n\n            case Deletion:\n              {\n                isUnmounting = true;\n                commitDeletion(nextEffect);\n                isUnmounting = false;\n                break;\n              }\n          }\n\n          nextEffect = nextEffect.nextEffect;\n        }\n\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n      }\n\n      function commitAllLifeCycles() {\n        while (nextEffect !== null) {\n          var effectTag = nextEffect.effectTag;\n\n          if (effectTag & (Update | Callback)) {\n            recordEffect();\n            var current = nextEffect.alternate;\n            commitLifeCycles(current, nextEffect);\n          }\n\n          if (effectTag & Ref) {\n            recordEffect();\n            commitAttachRef(nextEffect);\n          }\n\n          if (effectTag & Err) {\n            recordEffect();\n            commitErrorHandling(nextEffect);\n          }\n\n          var next = nextEffect.nextEffect; // Ensure that we clean these up so that we don't accidentally keep them.\n          // I'm not actually sure this matters because we can't reset firstEffect\n          // and lastEffect since they're on every node, not just the effectful\n          // ones. So we have to clean everything as we reuse nodes anyway.\n\n          nextEffect.nextEffect = null; // Ensure that we reset the effectTag here so that we can rely on effect\n          // tags to reason about the current life-cycle.\n\n          nextEffect = next;\n        }\n      }\n\n      function commitRoot(finishedWork) {\n        // We keep track of this so that captureError can collect any boundaries\n        // that capture an error during the commit phase. The reason these aren't\n        // local to this function is because errors that occur during cWU are\n        // captured elsewhere, to prevent the unmount from being interrupted.\n        isWorking = true;\n        isCommitting = true;\n        startCommitTimer();\n        var root = finishedWork.stateNode;\n        !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        root.isReadyForCommit = false; // Reset this to null before calling lifecycles\n\n        ReactCurrentOwner.current = null;\n        var firstEffect = void 0;\n\n        if (finishedWork.effectTag > PerformedWork) {\n          // A fiber's effect list consists only of its children, not itself. So if\n          // the root has an effect, we need to add it to the end of the list. The\n          // resulting list is the set that would belong to the root's parent, if\n          // it had one; that is, all the effects in the tree including the root.\n          if (finishedWork.lastEffect !== null) {\n            finishedWork.lastEffect.nextEffect = finishedWork;\n            firstEffect = finishedWork.firstEffect;\n          } else {\n            firstEffect = finishedWork;\n          }\n        } else {\n          // There is no effect on the root.\n          firstEffect = finishedWork.firstEffect;\n        }\n\n        prepareForCommit(); // Commit all the side-effects within a tree. We'll do this in two passes.\n        // The first pass performs all the host insertions, updates, deletions and\n        // ref unmounts.\n\n        nextEffect = firstEffect;\n        startCommitHostEffectsTimer();\n\n        while (nextEffect !== null) {\n          var didError = false;\n\n          var _error = void 0;\n\n          {\n            invokeGuardedCallback$1(null, commitAllHostEffects, null);\n\n            if (hasCaughtError()) {\n              didError = true;\n              _error = clearCaughtError();\n            }\n          }\n\n          if (didError) {\n            !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            captureError(nextEffect, _error); // Clean-up\n\n            if (nextEffect !== null) {\n              nextEffect = nextEffect.nextEffect;\n            }\n          }\n        }\n\n        stopCommitHostEffectsTimer();\n        resetAfterCommit(); // The work-in-progress tree is now the current tree. This must come after\n        // the first pass of the commit phase, so that the previous tree is still\n        // current during componentWillUnmount, but before the second pass, so that\n        // the finished work is current during componentDidMount/Update.\n\n        root.current = finishedWork; // In the second pass we'll perform all life-cycles and ref callbacks.\n        // Life-cycles happen as a separate pass so that all placements, updates,\n        // and deletions in the entire tree have already been invoked.\n        // This pass also triggers any renderer-specific initial effects.\n\n        nextEffect = firstEffect;\n        startCommitLifeCyclesTimer();\n\n        while (nextEffect !== null) {\n          var _didError = false;\n\n          var _error2 = void 0;\n\n          {\n            invokeGuardedCallback$1(null, commitAllLifeCycles, null);\n\n            if (hasCaughtError()) {\n              _didError = true;\n              _error2 = clearCaughtError();\n            }\n          }\n\n          if (_didError) {\n            !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            captureError(nextEffect, _error2);\n\n            if (nextEffect !== null) {\n              nextEffect = nextEffect.nextEffect;\n            }\n          }\n        }\n\n        isCommitting = false;\n        isWorking = false;\n        stopCommitLifeCyclesTimer();\n        stopCommitTimer();\n\n        if (typeof onCommitRoot === 'function') {\n          onCommitRoot(finishedWork.stateNode);\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n        } // If we caught any errors during this commit, schedule their boundaries\n        // to update.\n\n\n        if (commitPhaseBoundaries) {\n          commitPhaseBoundaries.forEach(scheduleErrorRecovery);\n          commitPhaseBoundaries = null;\n        }\n\n        if (firstUncaughtError !== null) {\n          var _error3 = firstUncaughtError;\n          firstUncaughtError = null;\n          onUncaughtError(_error3);\n        }\n\n        var remainingTime = root.current.expirationTime;\n\n        if (remainingTime === NoWork) {\n          capturedErrors = null;\n          failedBoundaries = null;\n        }\n\n        return remainingTime;\n      }\n\n      function resetExpirationTime(workInProgress, renderTime) {\n        if (renderTime !== Never && workInProgress.expirationTime === Never) {\n          // The children of this component are hidden. Don't bubble their\n          // expiration times.\n          return;\n        } // Check for pending updates.\n\n\n        var newExpirationTime = getUpdateExpirationTime(workInProgress); // TODO: Calls need to visit stateNode\n        // Bubble up the earliest expiration time.\n\n        var child = workInProgress.child;\n\n        while (child !== null) {\n          if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {\n            newExpirationTime = child.expirationTime;\n          }\n\n          child = child.sibling;\n        }\n\n        workInProgress.expirationTime = newExpirationTime;\n      }\n\n      function completeUnitOfWork(workInProgress) {\n        while (true) {\n          // The current, flushed, state of this fiber is the alternate.\n          // Ideally nothing should rely on this, but relying on it here\n          // means that we don't need an additional field on the work in\n          // progress.\n          var current = workInProgress.alternate;\n          {\n            ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n          }\n          var next = completeWork(current, workInProgress, nextRenderExpirationTime);\n          {\n            ReactDebugCurrentFiber.resetCurrentFiber();\n          }\n          var returnFiber = workInProgress['return'];\n          var siblingFiber = workInProgress.sibling;\n          resetExpirationTime(workInProgress, nextRenderExpirationTime);\n\n          if (next !== null) {\n            stopWorkTimer(workInProgress);\n\n            if (true && ReactFiberInstrumentation_1.debugTool) {\n              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n            } // If completing this work spawned new work, do that next. We'll come\n            // back here again.\n\n\n            return next;\n          }\n\n          if (returnFiber !== null) {\n            // Append all the effects of the subtree and this fiber onto the effect\n            // list of the parent. The completion order of the children affects the\n            // side-effect order.\n            if (returnFiber.firstEffect === null) {\n              returnFiber.firstEffect = workInProgress.firstEffect;\n            }\n\n            if (workInProgress.lastEffect !== null) {\n              if (returnFiber.lastEffect !== null) {\n                returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n              }\n\n              returnFiber.lastEffect = workInProgress.lastEffect;\n            } // If this fiber had side-effects, we append it AFTER the children's\n            // side-effects. We can perform certain side-effects earlier if\n            // needed, by doing multiple passes over the effect list. We don't want\n            // to schedule our own side-effect on our own list because if end up\n            // reusing children we'll schedule this effect onto itself since we're\n            // at the end.\n\n\n            var effectTag = workInProgress.effectTag; // Skip both NoWork and PerformedWork tags when creating the effect list.\n            // PerformedWork effect is read by React DevTools but shouldn't be committed.\n\n            if (effectTag > PerformedWork) {\n              if (returnFiber.lastEffect !== null) {\n                returnFiber.lastEffect.nextEffect = workInProgress;\n              } else {\n                returnFiber.firstEffect = workInProgress;\n              }\n\n              returnFiber.lastEffect = workInProgress;\n            }\n          }\n\n          stopWorkTimer(workInProgress);\n\n          if (true && ReactFiberInstrumentation_1.debugTool) {\n            ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n          }\n\n          if (siblingFiber !== null) {\n            // If there is more work to do in this returnFiber, do that next.\n            return siblingFiber;\n          } else if (returnFiber !== null) {\n            // If there's no more work in this returnFiber. Complete the returnFiber.\n            workInProgress = returnFiber;\n            continue;\n          } else {\n            // We've reached the root.\n            var root = workInProgress.stateNode;\n            root.isReadyForCommit = true;\n            return null;\n          }\n        } // Without this explicit null return Flow complains of invalid return type\n        // TODO Remove the above while(true) loop\n        // eslint-disable-next-line no-unreachable\n\n\n        return null;\n      }\n\n      function performUnitOfWork(workInProgress) {\n        // The current, flushed, state of this fiber is the alternate.\n        // Ideally nothing should rely on this, but relying on it here\n        // means that we don't need an additional field on the work in\n        // progress.\n        var current = workInProgress.alternate; // See if beginning this work spawns more work.\n\n        startWorkTimer(workInProgress);\n        {\n          ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n        }\n        var next = beginWork(current, workInProgress, nextRenderExpirationTime);\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n        }\n\n        if (next === null) {\n          // If this doesn't spawn new work, complete the current work.\n          next = completeUnitOfWork(workInProgress);\n        }\n\n        ReactCurrentOwner.current = null;\n        return next;\n      }\n\n      function performFailedUnitOfWork(workInProgress) {\n        // The current, flushed, state of this fiber is the alternate.\n        // Ideally nothing should rely on this, but relying on it here\n        // means that we don't need an additional field on the work in\n        // progress.\n        var current = workInProgress.alternate; // See if beginning this work spawns more work.\n\n        startWorkTimer(workInProgress);\n        {\n          ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n        }\n        var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n        }\n\n        if (next === null) {\n          // If this doesn't spawn new work, complete the current work.\n          next = completeUnitOfWork(workInProgress);\n        }\n\n        ReactCurrentOwner.current = null;\n        return next;\n      }\n\n      function workLoop(expirationTime) {\n        if (capturedErrors !== null) {\n          // If there are unhandled errors, switch to the slow work loop.\n          // TODO: How to avoid this check in the fast path? Maybe the renderer\n          // could keep track of which roots have unhandled errors and call a\n          // forked version of renderRoot.\n          slowWorkLoopThatChecksForFailedWork(expirationTime);\n          return;\n        }\n\n        if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n          return;\n        }\n\n        if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n          // Flush all expired work.\n          while (nextUnitOfWork !== null) {\n            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n          }\n        } else {\n          // Flush asynchronous work until the deadline runs out of time.\n          while (nextUnitOfWork !== null && !shouldYield()) {\n            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n          }\n        }\n      }\n\n      function slowWorkLoopThatChecksForFailedWork(expirationTime) {\n        if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n          return;\n        }\n\n        if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n          // Flush all expired work.\n          while (nextUnitOfWork !== null) {\n            if (hasCapturedError(nextUnitOfWork)) {\n              // Use a forked version of performUnitOfWork\n              nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n            } else {\n              nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n            }\n          }\n        } else {\n          // Flush asynchronous work until the deadline runs out of time.\n          while (nextUnitOfWork !== null && !shouldYield()) {\n            if (hasCapturedError(nextUnitOfWork)) {\n              // Use a forked version of performUnitOfWork\n              nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n            } else {\n              nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n            }\n          }\n        }\n      }\n\n      function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {\n        // We're going to restart the error boundary that captured the error.\n        // Conceptually, we're unwinding the stack. We need to unwind the\n        // context stack, too.\n        unwindContexts(failedWork, boundary); // Restart the error boundary using a forked version of\n        // performUnitOfWork that deletes the boundary's children. The entire\n        // failed subree will be unmounted. During the commit phase, a special\n        // lifecycle method is called on the error boundary, which triggers\n        // a re-render.\n\n        nextUnitOfWork = performFailedUnitOfWork(boundary); // Continue working.\n\n        workLoop(expirationTime);\n      }\n\n      function renderRoot(root, expirationTime) {\n        !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        isWorking = true; // We're about to mutate the work-in-progress tree. If the root was pending\n        // commit, it no longer is: we'll need to complete it again.\n\n        root.isReadyForCommit = false; // Check if we're starting from a fresh stack, or if we're resuming from\n        // previously yielded work.\n\n        if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {\n          // Reset the stack and start working from the root.\n          resetContextStack();\n          nextRoot = root;\n          nextRenderExpirationTime = expirationTime;\n          nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);\n        }\n\n        startWorkLoopTimer(nextUnitOfWork);\n        var didError = false;\n        var error = null;\n        {\n          invokeGuardedCallback$1(null, workLoop, null, expirationTime);\n\n          if (hasCaughtError()) {\n            didError = true;\n            error = clearCaughtError();\n          }\n        } // An error was thrown during the render phase.\n\n        while (didError) {\n          if (didFatal) {\n            // This was a fatal error. Don't attempt to recover from it.\n            firstUncaughtError = error;\n            break;\n          }\n\n          var failedWork = nextUnitOfWork;\n\n          if (failedWork === null) {\n            // An error was thrown but there's no current unit of work. This can\n            // happen during the commit phase if there's a bug in the renderer.\n            didFatal = true;\n            continue;\n          } // \"Capture\" the error by finding the nearest boundary. If there is no\n          // error boundary, we use the root.\n\n\n          var boundary = captureError(failedWork, error);\n          !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n          if (didFatal) {\n            // The error we just captured was a fatal error. This happens\n            // when the error propagates to the root more than once.\n            continue;\n          }\n\n          didError = false;\n          error = null;\n          {\n            invokeGuardedCallback$1(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);\n\n            if (hasCaughtError()) {\n              didError = true;\n              error = clearCaughtError();\n              continue;\n            }\n          } // We're finished working. Exit the error loop.\n\n          break;\n        }\n\n        var uncaughtError = firstUncaughtError; // We're done performing work. Time to clean up.\n\n        stopWorkLoopTimer(interruptedBy);\n        interruptedBy = null;\n        isWorking = false;\n        didFatal = false;\n        firstUncaughtError = null;\n\n        if (uncaughtError !== null) {\n          onUncaughtError(uncaughtError);\n        }\n\n        return root.isReadyForCommit ? root.current.alternate : null;\n      } // Returns the boundary that captured the error, or null if the error is ignored\n\n\n      function captureError(failedWork, error) {\n        // It is no longer valid because we exited the user code.\n        ReactCurrentOwner.current = null;\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        } // Search for the nearest error boundary.\n\n        var boundary = null; // Passed to logCapturedError()\n\n        var errorBoundaryFound = false;\n        var willRetry = false;\n        var errorBoundaryName = null; // Host containers are a special case. If the failed work itself is a host\n        // container, then it acts as its own boundary. In all other cases, we\n        // ignore the work itself and only search through the parents.\n\n        if (failedWork.tag === HostRoot) {\n          boundary = failedWork;\n\n          if (isFailedBoundary(failedWork)) {\n            // If this root already failed, there must have been an error when\n            // attempting to unmount it. This is a worst-case scenario and\n            // should only be possible if there's a bug in the renderer.\n            didFatal = true;\n          }\n        } else {\n          var node = failedWork['return'];\n\n          while (node !== null && boundary === null) {\n            if (node.tag === ClassComponent) {\n              var instance = node.stateNode;\n\n              if (typeof instance.componentDidCatch === 'function') {\n                errorBoundaryFound = true;\n                errorBoundaryName = getComponentName(node); // Found an error boundary!\n\n                boundary = node;\n                willRetry = true;\n              }\n            } else if (node.tag === HostRoot) {\n              // Treat the root like a no-op error boundary\n              boundary = node;\n            }\n\n            if (isFailedBoundary(node)) {\n              // This boundary is already in a failed state.\n              // If we're currently unmounting, that means this error was\n              // thrown while unmounting a failed subtree. We should ignore\n              // the error.\n              if (isUnmounting) {\n                return null;\n              } // If we're in the commit phase, we should check to see if\n              // this boundary already captured an error during this commit.\n              // This case exists because multiple errors can be thrown during\n              // a single commit without interruption.\n\n\n              if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {\n                // If so, we should ignore this error.\n                return null;\n              } // The error should propagate to the next boundary - we keep looking.\n\n\n              boundary = null;\n              willRetry = false;\n            }\n\n            node = node['return'];\n          }\n        }\n\n        if (boundary !== null) {\n          // Add to the collection of failed boundaries. This lets us know that\n          // subsequent errors in this subtree should propagate to the next boundary.\n          if (failedBoundaries === null) {\n            failedBoundaries = new Set();\n          }\n\n          failedBoundaries.add(boundary); // This method is unsafe outside of the begin and complete phases.\n          // We might be in the commit phase when an error is captured.\n          // The risk is that the return path from this Fiber may not be accurate.\n          // That risk is acceptable given the benefit of providing users more context.\n\n          var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);\n\n          var _componentName = getComponentName(failedWork); // Add to the collection of captured errors. This is stored as a global\n          // map of errors and their component stack location keyed by the boundaries\n          // that capture them. We mostly use this Map as a Set; it's a Map only to\n          // avoid adding a field to Fiber to store the error.\n\n\n          if (capturedErrors === null) {\n            capturedErrors = new Map();\n          }\n\n          var capturedError = {\n            componentName: _componentName,\n            componentStack: _componentStack,\n            error: error,\n            errorBoundary: errorBoundaryFound ? boundary.stateNode : null,\n            errorBoundaryFound: errorBoundaryFound,\n            errorBoundaryName: errorBoundaryName,\n            willRetry: willRetry\n          };\n          capturedErrors.set(boundary, capturedError);\n\n          try {\n            logCapturedError(capturedError);\n          } catch (e) {\n            // Prevent cycle if logCapturedError() throws.\n            // A cycle may still occur if logCapturedError renders a component that throws.\n            console.error(e);\n          } // If we're in the commit phase, defer scheduling an update on the\n          // boundary until after the commit is complete\n\n\n          if (isCommitting) {\n            if (commitPhaseBoundaries === null) {\n              commitPhaseBoundaries = new Set();\n            }\n\n            commitPhaseBoundaries.add(boundary);\n          } else {\n            // Otherwise, schedule an update now.\n            // TODO: Is this actually necessary during the render phase? Is it\n            // possible to unwind and continue rendering at the same priority,\n            // without corrupting internal state?\n            scheduleErrorRecovery(boundary);\n          }\n\n          return boundary;\n        } else if (firstUncaughtError === null) {\n          // If no boundary is found, we'll need to throw the error\n          firstUncaughtError = error;\n        }\n\n        return null;\n      }\n\n      function hasCapturedError(fiber) {\n        // TODO: capturedErrors should store the boundary instance, to avoid needing\n        // to check the alternate.\n        return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));\n      }\n\n      function isFailedBoundary(fiber) {\n        // TODO: failedBoundaries should store the boundary instance, to avoid\n        // needing to check the alternate.\n        return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));\n      }\n\n      function commitErrorHandling(effectfulFiber) {\n        var capturedError = void 0;\n\n        if (capturedErrors !== null) {\n          capturedError = capturedErrors.get(effectfulFiber);\n          capturedErrors['delete'](effectfulFiber);\n\n          if (capturedError == null) {\n            if (effectfulFiber.alternate !== null) {\n              effectfulFiber = effectfulFiber.alternate;\n              capturedError = capturedErrors.get(effectfulFiber);\n              capturedErrors['delete'](effectfulFiber);\n            }\n          }\n        }\n\n        !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n        switch (effectfulFiber.tag) {\n          case ClassComponent:\n            var instance = effectfulFiber.stateNode;\n            var info = {\n              componentStack: capturedError.componentStack\n            }; // Allow the boundary to handle the error, usually by scheduling\n            // an update to itself\n\n            instance.componentDidCatch(capturedError.error, info);\n            return;\n\n          case HostRoot:\n            if (firstUncaughtError === null) {\n              firstUncaughtError = capturedError.error;\n            }\n\n            return;\n\n          default:\n            invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n\n      function unwindContexts(from, to) {\n        var node = from;\n\n        while (node !== null) {\n          switch (node.tag) {\n            case ClassComponent:\n              popContextProvider(node);\n              break;\n\n            case HostComponent:\n              popHostContext(node);\n              break;\n\n            case HostRoot:\n              popHostContainer(node);\n              break;\n\n            case HostPortal:\n              popHostContainer(node);\n              break;\n          }\n\n          if (node === to || node.alternate === to) {\n            stopFailedWorkTimer(node);\n            break;\n          } else {\n            stopWorkTimer(node);\n          }\n\n          node = node['return'];\n        }\n      }\n\n      function computeAsyncExpiration() {\n        // Given the current clock time, returns an expiration time. We use rounding\n        // to batch like updates together.\n        // Should complete within ~1000ms. 1200ms max.\n        var currentTime = recalculateCurrentTime();\n        var expirationMs = 1000;\n        var bucketSizeMs = 200;\n        return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n      }\n\n      function computeExpirationForFiber(fiber) {\n        var expirationTime = void 0;\n\n        if (expirationContext !== NoWork) {\n          // An explicit expiration context was set;\n          expirationTime = expirationContext;\n        } else if (isWorking) {\n          if (isCommitting) {\n            // Updates that occur during the commit phase should have sync priority\n            // by default.\n            expirationTime = Sync;\n          } else {\n            // Updates during the render phase should expire at the same time as\n            // the work that is being rendered.\n            expirationTime = nextRenderExpirationTime;\n          }\n        } else {\n          // No explicit expiration context was set, and we're not currently\n          // performing work. Calculate a new expiration time.\n          if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {\n            // This is a sync update\n            expirationTime = Sync;\n          } else {\n            // This is an async update\n            expirationTime = computeAsyncExpiration();\n          }\n        }\n\n        return expirationTime;\n      }\n\n      function scheduleWork(fiber, expirationTime) {\n        return scheduleWorkImpl(fiber, expirationTime, false);\n      }\n\n      function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {\n        recordScheduleUpdate();\n        {\n          if (!isErrorRecovery && fiber.tag === ClassComponent) {\n            var instance = fiber.stateNode;\n            warnAboutInvalidUpdates(instance);\n          }\n        }\n        var node = fiber;\n\n        while (node !== null) {\n          // Walk the parent path to the root and update each node's\n          // expiration time.\n          if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {\n            node.expirationTime = expirationTime;\n          }\n\n          if (node.alternate !== null) {\n            if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {\n              node.alternate.expirationTime = expirationTime;\n            }\n          }\n\n          if (node['return'] === null) {\n            if (node.tag === HostRoot) {\n              var root = node.stateNode;\n\n              if (!isWorking && root === nextRoot && expirationTime <= nextRenderExpirationTime) {\n                // Restart the root from the top.\n                if (nextUnitOfWork !== null) {\n                  // This is an interruption. (Used for performance tracking.)\n                  interruptedBy = fiber;\n                }\n\n                nextRoot = null;\n                nextUnitOfWork = null;\n                nextRenderExpirationTime = NoWork;\n              }\n\n              requestWork(root, expirationTime);\n            } else {\n              {\n                if (!isErrorRecovery && fiber.tag === ClassComponent) {\n                  warnAboutUpdateOnUnmounted(fiber);\n                }\n              }\n              return;\n            }\n          }\n\n          node = node['return'];\n        }\n      }\n\n      function scheduleErrorRecovery(fiber) {\n        scheduleWorkImpl(fiber, Sync, true);\n      }\n\n      function recalculateCurrentTime() {\n        // Subtract initial time so it fits inside 32bits\n        var ms = now() - startTime;\n        mostRecentCurrentTime = msToExpirationTime(ms);\n        return mostRecentCurrentTime;\n      }\n\n      function deferredUpdates(fn) {\n        var previousExpirationContext = expirationContext;\n        expirationContext = computeAsyncExpiration();\n\n        try {\n          return fn();\n        } finally {\n          expirationContext = previousExpirationContext;\n        }\n      }\n\n      function syncUpdates(fn) {\n        var previousExpirationContext = expirationContext;\n        expirationContext = Sync;\n\n        try {\n          return fn();\n        } finally {\n          expirationContext = previousExpirationContext;\n        }\n      } // TODO: Everything below this is written as if it has been lifted to the\n      // renderers. I'll do this in a follow-up.\n      // Linked-list of roots\n\n\n      var firstScheduledRoot = null;\n      var lastScheduledRoot = null;\n      var isCallbackScheduled = false;\n      var isRendering = false;\n      var nextFlushedRoot = null;\n      var nextFlushedExpirationTime = NoWork;\n      var deadlineDidExpire = false;\n      var hasUnhandledError = false;\n      var unhandledError = null;\n      var deadline = null;\n      var isBatchingUpdates = false;\n      var isUnbatchingUpdates = false; // Use these to prevent an infinite loop of nested updates\n\n      var NESTED_UPDATE_LIMIT = 1000;\n      var nestedUpdateCount = 0;\n      var timeHeuristicForUnitOfWork = 1; // requestWork is called by the scheduler whenever a root receives an update.\n      // It's up to the renderer to call renderRoot at some point in the future.\n\n      function requestWork(root, expirationTime) {\n        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n          invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');\n        } // Add the root to the schedule.\n        // Check if this root is already part of the schedule.\n\n\n        if (root.nextScheduledRoot === null) {\n          // This root is not already scheduled. Add it.\n          root.remainingExpirationTime = expirationTime;\n\n          if (lastScheduledRoot === null) {\n            firstScheduledRoot = lastScheduledRoot = root;\n            root.nextScheduledRoot = root;\n          } else {\n            lastScheduledRoot.nextScheduledRoot = root;\n            lastScheduledRoot = root;\n            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n          }\n        } else {\n          // This root is already scheduled, but its priority may have increased.\n          var remainingExpirationTime = root.remainingExpirationTime;\n\n          if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {\n            // Update the priority.\n            root.remainingExpirationTime = expirationTime;\n          }\n        }\n\n        if (isRendering) {\n          // Prevent reentrancy. Remaining work will be scheduled at the end of\n          // the currently rendering batch.\n          return;\n        }\n\n        if (isBatchingUpdates) {\n          // Flush work at the end of the batch.\n          if (isUnbatchingUpdates) {\n            // ...unless we're inside unbatchedUpdates, in which case we should\n            // flush it now.\n            performWorkOnRoot(root, Sync);\n          }\n\n          return;\n        } // TODO: Get rid of Sync and use current time?\n\n\n        if (expirationTime === Sync) {\n          performWork(Sync, null);\n        } else if (!isCallbackScheduled) {\n          isCallbackScheduled = true;\n          startRequestCallbackTimer();\n          scheduleDeferredCallback(performAsyncWork);\n        }\n      }\n\n      function findHighestPriorityRoot() {\n        var highestPriorityWork = NoWork;\n        var highestPriorityRoot = null;\n\n        if (lastScheduledRoot !== null) {\n          var previousScheduledRoot = lastScheduledRoot;\n          var root = firstScheduledRoot;\n\n          while (root !== null) {\n            var remainingExpirationTime = root.remainingExpirationTime;\n\n            if (remainingExpirationTime === NoWork) {\n              // This root no longer has work. Remove it from the scheduler.\n              // TODO: This check is redudant, but Flow is confused by the branch\n              // below where we set lastScheduledRoot to null, even though we break\n              // from the loop right after.\n              !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n              if (root === root.nextScheduledRoot) {\n                // This is the only root in the list.\n                root.nextScheduledRoot = null;\n                firstScheduledRoot = lastScheduledRoot = null;\n                break;\n              } else if (root === firstScheduledRoot) {\n                // This is the first root in the list.\n                var next = root.nextScheduledRoot;\n                firstScheduledRoot = next;\n                lastScheduledRoot.nextScheduledRoot = next;\n                root.nextScheduledRoot = null;\n              } else if (root === lastScheduledRoot) {\n                // This is the last root in the list.\n                lastScheduledRoot = previousScheduledRoot;\n                lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n                root.nextScheduledRoot = null;\n                break;\n              } else {\n                previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n                root.nextScheduledRoot = null;\n              }\n\n              root = previousScheduledRoot.nextScheduledRoot;\n            } else {\n              if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {\n                // Update the priority, if it's higher\n                highestPriorityWork = remainingExpirationTime;\n                highestPriorityRoot = root;\n              }\n\n              if (root === lastScheduledRoot) {\n                break;\n              }\n\n              previousScheduledRoot = root;\n              root = root.nextScheduledRoot;\n            }\n          }\n        } // If the next root is the same as the previous root, this is a nested\n        // update. To prevent an infinite loop, increment the nested update count.\n\n\n        var previousFlushedRoot = nextFlushedRoot;\n\n        if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {\n          nestedUpdateCount++;\n        } else {\n          // Reset whenever we switch roots.\n          nestedUpdateCount = 0;\n        }\n\n        nextFlushedRoot = highestPriorityRoot;\n        nextFlushedExpirationTime = highestPriorityWork;\n      }\n\n      function performAsyncWork(dl) {\n        performWork(NoWork, dl);\n      }\n\n      function performWork(minExpirationTime, dl) {\n        deadline = dl; // Keep working on roots until there's no more work, or until the we reach\n        // the deadline.\n\n        findHighestPriorityRoot();\n\n        if (enableUserTimingAPI && deadline !== null) {\n          var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();\n          stopRequestCallbackTimer(didExpire);\n        }\n\n        while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {\n          performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime); // Find the next highest priority work.\n\n          findHighestPriorityRoot();\n        } // We're done flushing work. Either we ran out of time in this callback,\n        // or there's no more work left with sufficient priority.\n        // If we're inside a callback, set this to false since we just completed it.\n\n\n        if (deadline !== null) {\n          isCallbackScheduled = false;\n        } // If there's work left over, schedule a new callback.\n\n\n        if (nextFlushedRoot !== null && !isCallbackScheduled) {\n          isCallbackScheduled = true;\n          startRequestCallbackTimer();\n          scheduleDeferredCallback(performAsyncWork);\n        } // Clean-up.\n\n\n        deadline = null;\n        deadlineDidExpire = false;\n        nestedUpdateCount = 0;\n\n        if (hasUnhandledError) {\n          var _error4 = unhandledError;\n          unhandledError = null;\n          hasUnhandledError = false;\n          throw _error4;\n        }\n      }\n\n      function performWorkOnRoot(root, expirationTime) {\n        !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        isRendering = true; // Check if this is async work or sync/expired work.\n        // TODO: Pass current time as argument to renderRoot, commitRoot\n\n        if (expirationTime <= recalculateCurrentTime()) {\n          // Flush sync work.\n          var finishedWork = root.finishedWork;\n\n          if (finishedWork !== null) {\n            // This root is already complete. We can commit it.\n            root.finishedWork = null;\n            root.remainingExpirationTime = commitRoot(finishedWork);\n          } else {\n            root.finishedWork = null;\n            finishedWork = renderRoot(root, expirationTime);\n\n            if (finishedWork !== null) {\n              // We've completed the root. Commit it.\n              root.remainingExpirationTime = commitRoot(finishedWork);\n            }\n          }\n        } else {\n          // Flush async work.\n          var _finishedWork = root.finishedWork;\n\n          if (_finishedWork !== null) {\n            // This root is already complete. We can commit it.\n            root.finishedWork = null;\n            root.remainingExpirationTime = commitRoot(_finishedWork);\n          } else {\n            root.finishedWork = null;\n            _finishedWork = renderRoot(root, expirationTime);\n\n            if (_finishedWork !== null) {\n              // We've completed the root. Check the deadline one more time\n              // before committing.\n              if (!shouldYield()) {\n                // Still time left. Commit the root.\n                root.remainingExpirationTime = commitRoot(_finishedWork);\n              } else {\n                // There's no time left. Mark this root as complete. We'll come\n                // back and commit it later.\n                root.finishedWork = _finishedWork;\n              }\n            }\n          }\n        }\n\n        isRendering = false;\n      } // When working on async work, the reconciler asks the renderer if it should\n      // yield execution. For DOM, we implement this with requestIdleCallback.\n\n\n      function shouldYield() {\n        if (deadline === null) {\n          return false;\n        }\n\n        if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n          return false;\n        }\n\n        deadlineDidExpire = true;\n        return true;\n      } // TODO: Not happy about this hook. Conceptually, renderRoot should return a\n      // tuple of (isReadyForCommit, didError, error)\n\n\n      function onUncaughtError(error) {\n        !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0; // Unschedule this root so we don't work on it again until there's\n        // another update.\n\n        nextFlushedRoot.remainingExpirationTime = NoWork;\n\n        if (!hasUnhandledError) {\n          hasUnhandledError = true;\n          unhandledError = error;\n        }\n      } // TODO: Batching should be implemented at the renderer level, not inside\n      // the reconciler.\n\n\n      function batchedUpdates(fn, a) {\n        var previousIsBatchingUpdates = isBatchingUpdates;\n        isBatchingUpdates = true;\n\n        try {\n          return fn(a);\n        } finally {\n          isBatchingUpdates = previousIsBatchingUpdates;\n\n          if (!isBatchingUpdates && !isRendering) {\n            performWork(Sync, null);\n          }\n        }\n      } // TODO: Batching should be implemented at the renderer level, not inside\n      // the reconciler.\n\n\n      function unbatchedUpdates(fn) {\n        if (isBatchingUpdates && !isUnbatchingUpdates) {\n          isUnbatchingUpdates = true;\n\n          try {\n            return fn();\n          } finally {\n            isUnbatchingUpdates = false;\n          }\n        }\n\n        return fn();\n      } // TODO: Batching should be implemented at the renderer level, not within\n      // the reconciler.\n\n\n      function flushSync(fn) {\n        var previousIsBatchingUpdates = isBatchingUpdates;\n        isBatchingUpdates = true;\n\n        try {\n          return syncUpdates(fn);\n        } finally {\n          isBatchingUpdates = previousIsBatchingUpdates;\n          !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;\n          performWork(Sync, null);\n        }\n      }\n\n      return {\n        computeAsyncExpiration: computeAsyncExpiration,\n        computeExpirationForFiber: computeExpirationForFiber,\n        scheduleWork: scheduleWork,\n        batchedUpdates: batchedUpdates,\n        unbatchedUpdates: unbatchedUpdates,\n        flushSync: flushSync,\n        deferredUpdates: deferredUpdates\n      };\n    };\n\n    {\n      var didWarnAboutNestedUpdates = false;\n    } // 0 is PROD, 1 is DEV.\n    // Might add PROFILE later.\n\n    function getContextForSubtree(parentComponent) {\n      if (!parentComponent) {\n        return emptyObject;\n      }\n\n      var fiber = get(parentComponent);\n      var parentContext = findCurrentUnmaskedContext(fiber);\n      return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;\n    }\n\n    var ReactFiberReconciler$1 = function (config) {\n      var getPublicInstance = config.getPublicInstance;\n\n      var _ReactFiberScheduler = ReactFiberScheduler(config),\n          computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,\n          computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,\n          scheduleWork = _ReactFiberScheduler.scheduleWork,\n          batchedUpdates = _ReactFiberScheduler.batchedUpdates,\n          unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,\n          flushSync = _ReactFiberScheduler.flushSync,\n          deferredUpdates = _ReactFiberScheduler.deferredUpdates;\n\n      function scheduleTopLevelUpdate(current, element, callback) {\n        {\n          if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {\n            didWarnAboutNestedUpdates = true;\n            warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');\n          }\n        }\n        callback = callback === undefined ? null : callback;\n        {\n          warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n        }\n        var expirationTime = void 0; // Check if the top-level element is an async wrapper component. If so,\n        // treat updates to the root as async. This is a bit weird but lets us\n        // avoid a separate `renderAsync` API.\n\n        if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {\n          expirationTime = computeAsyncExpiration();\n        } else {\n          expirationTime = computeExpirationForFiber(current);\n        }\n\n        var update = {\n          expirationTime: expirationTime,\n          partialState: {\n            element: element\n          },\n          callback: callback,\n          isReplace: false,\n          isForced: false,\n          nextCallback: null,\n          next: null\n        };\n        insertUpdateIntoFiber(current, update);\n        scheduleWork(current, expirationTime);\n      }\n\n      function findHostInstance(fiber) {\n        var hostFiber = findCurrentHostFiber(fiber);\n\n        if (hostFiber === null) {\n          return null;\n        }\n\n        return hostFiber.stateNode;\n      }\n\n      return {\n        createContainer: function (containerInfo, hydrate) {\n          return createFiberRoot(containerInfo, hydrate);\n        },\n        updateContainer: function (element, container, parentComponent, callback) {\n          // TODO: If this is a nested container, this won't be the root.\n          var current = container.current;\n          {\n            if (ReactFiberInstrumentation_1.debugTool) {\n              if (current.alternate === null) {\n                ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n              } else if (element === null) {\n                ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n              } else {\n                ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n              }\n            }\n          }\n          var context = getContextForSubtree(parentComponent);\n\n          if (container.context === null) {\n            container.context = context;\n          } else {\n            container.pendingContext = context;\n          }\n\n          scheduleTopLevelUpdate(current, element, callback);\n        },\n        batchedUpdates: batchedUpdates,\n        unbatchedUpdates: unbatchedUpdates,\n        deferredUpdates: deferredUpdates,\n        flushSync: flushSync,\n        getPublicRootInstance: function (container) {\n          var containerFiber = container.current;\n\n          if (!containerFiber.child) {\n            return null;\n          }\n\n          switch (containerFiber.child.tag) {\n            case HostComponent:\n              return getPublicInstance(containerFiber.child.stateNode);\n\n            default:\n              return containerFiber.child.stateNode;\n          }\n        },\n        findHostInstance: findHostInstance,\n        findHostInstanceWithNoPortals: function (fiber) {\n          var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n\n          if (hostFiber === null) {\n            return null;\n          }\n\n          return hostFiber.stateNode;\n        },\n        injectIntoDevTools: function (devToolsConfig) {\n          var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n          return injectInternals(_assign({}, devToolsConfig, {\n            findHostInstanceByFiber: function (fiber) {\n              return findHostInstance(fiber);\n            },\n            findFiberByHostInstance: function (instance) {\n              if (!findFiberByHostInstance) {\n                // Might not be implemented by the renderer.\n                return null;\n              }\n\n              return findFiberByHostInstance(instance);\n            }\n          }));\n        }\n      };\n    };\n\n    var ReactFiberReconciler$2 = Object.freeze({\n      default: ReactFiberReconciler$1\n    });\n    var ReactFiberReconciler$3 = ReactFiberReconciler$2 && ReactFiberReconciler$1 || ReactFiberReconciler$2; // TODO: bundle Flow types with the package.\n    // TODO: decide on the top-level export form.\n    // This is hacky but makes it work with both Rollup and Jest.\n\n    var reactReconciler = ReactFiberReconciler$3['default'] ? ReactFiberReconciler$3['default'] : ReactFiberReconciler$3; // TODO: this is special because it gets imported during build.\n\n    var ReactVersion = '16.1.1'; // a requestAnimationFrame, storing the time for the start of the frame, then\n    // scheduling a postMessage which gets scheduled after paint. Within the\n    // postMessage handler do as much work as possible until time + frame rate.\n    // By separating the idle call into a separate event tick we ensure that\n    // layout, paint and other browser work is counted against the available time.\n    // The frame rate is dynamically adjusted.\n\n    {\n      if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== 'function') {\n        warning(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');\n      }\n    }\n    var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n    var now = void 0;\n\n    if (hasNativePerformanceNow) {\n      now = function () {\n        return performance.now();\n      };\n    } else {\n      now = function () {\n        return Date.now();\n      };\n    } // TODO: There's no way to cancel, because Fiber doesn't atm.\n\n\n    var rIC = void 0;\n\n    if (!ExecutionEnvironment.canUseDOM) {\n      rIC = function (frameCallback) {\n        setTimeout(function () {\n          frameCallback({\n            timeRemaining: function () {\n              return Infinity;\n            }\n          });\n        });\n        return 0;\n      };\n    } else if (typeof requestIdleCallback !== 'function') {\n      // Polyfill requestIdleCallback.\n      var scheduledRICCallback = null;\n      var isIdleScheduled = false;\n      var isAnimationFrameScheduled = false;\n      var frameDeadline = 0; // We start out assuming that we run at 30fps but then the heuristic tracking\n      // will adjust this value to a faster fps if we get more frequent animation\n      // frames.\n\n      var previousFrameTime = 33;\n      var activeFrameTime = 33;\n      var frameDeadlineObject;\n\n      if (hasNativePerformanceNow) {\n        frameDeadlineObject = {\n          timeRemaining: function () {\n            // We assume that if we have a performance timer that the rAF callback\n            // gets a performance timer value. Not sure if this is always true.\n            return frameDeadline - performance.now();\n          }\n        };\n      } else {\n        frameDeadlineObject = {\n          timeRemaining: function () {\n            // Fallback to Date.now()\n            return frameDeadline - Date.now();\n          }\n        };\n      } // We use the postMessage trick to defer idle work until after the repaint.\n\n\n      var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n\n      var idleTick = function (event) {\n        if (event.source !== window || event.data !== messageKey) {\n          return;\n        }\n\n        isIdleScheduled = false;\n        var callback = scheduledRICCallback;\n        scheduledRICCallback = null;\n\n        if (callback !== null) {\n          callback(frameDeadlineObject);\n        }\n      }; // Assumes that we have addEventListener in this environment. Might need\n      // something better for old IE.\n\n\n      window.addEventListener('message', idleTick, false);\n\n      var animationTick = function (rafTime) {\n        isAnimationFrameScheduled = false;\n        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n\n        if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n          if (nextFrameTime < 8) {\n            // Defensive coding. We don't support higher frame rates than 120hz.\n            // If we get lower than that, it is probably a bug.\n            nextFrameTime = 8;\n          } // If one frame goes long, then the next one can be short to catch up.\n          // If two frames are short in a row, then that's an indication that we\n          // actually have a higher frame rate than what we're currently optimizing.\n          // We adjust our heuristic dynamically accordingly. For example, if we're\n          // running on 120hz display or 90hz VR display.\n          // Take the max of the two in case one of them was an anomaly due to\n          // missed frame deadlines.\n\n\n          activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n        } else {\n          previousFrameTime = nextFrameTime;\n        }\n\n        frameDeadline = rafTime + activeFrameTime;\n\n        if (!isIdleScheduled) {\n          isIdleScheduled = true;\n          window.postMessage(messageKey, '*');\n        }\n      };\n\n      rIC = function (callback) {\n        // This assumes that we only schedule one callback at a time because that's\n        // how Fiber uses it.\n        scheduledRICCallback = callback;\n\n        if (!isAnimationFrameScheduled) {\n          // If rAF didn't already schedule one, we need to schedule a frame.\n          // TODO: If this rAF doesn't materialize because the browser throttles, we\n          // might want to still have setTimeout trigger rIC as a backup to ensure\n          // that we keep performing work.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrame(animationTick);\n        }\n\n        return 0;\n      };\n    } else {\n      rIC = requestIdleCallback;\n    }\n    /**\n     * Forked from fbjs/warning:\n     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n     *\n     * Only change is we use console.warn instead of console.error,\n     * and do nothing when 'console' is not supported.\n     * This really simplifies the code.\n     * ---\n     * Similar to invariant but only logs a warning if the condition is not met.\n     * This can be used to log issues in development environments in critical\n     * paths. Removing the logging code for production environments will keep the\n     * same logic and follow the same code paths.\n     */\n\n\n    var lowPriorityWarning = function () {};\n\n    {\n      var printWarning = function (format) {\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        var argIndex = 0;\n        var message = 'Warning: ' + format.replace(/%s/g, function () {\n          return args[argIndex++];\n        });\n\n        if (typeof console !== 'undefined') {\n          console.warn(message);\n        }\n\n        try {\n          // --- Welcome to debugging React ---\n          // This error was thrown as a convenience so that you can use this stack\n          // to find the callsite that caused this warning to fire.\n          throw new Error(message);\n        } catch (x) {}\n      };\n\n      lowPriorityWarning = function (condition, format) {\n        if (format === undefined) {\n          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n        }\n\n        if (!condition) {\n          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n            args[_key2 - 2] = arguments[_key2];\n          }\n\n          printWarning.apply(undefined, [format].concat(args));\n        }\n      };\n    }\n    var lowPriorityWarning$1 = lowPriorityWarning; // isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.\n    // TODO: Find a better place for this.\n\n    var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');\n    var illegalAttributeNameCache = {};\n    var validatedAttributeNameCache = {};\n\n    function isAttributeNameSafe(attributeName) {\n      if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {\n        return true;\n      }\n\n      if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {\n        return false;\n      }\n\n      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n        validatedAttributeNameCache[attributeName] = true;\n        return true;\n      }\n\n      illegalAttributeNameCache[attributeName] = true;\n      {\n        warning(false, 'Invalid attribute name: `%s`', attributeName);\n      }\n      return false;\n    } // shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.\n    // TODO: Find a better place for this.\n\n\n    function shouldIgnoreValue(propertyInfo, value) {\n      return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;\n    }\n    /**\n     * Operations for dealing with DOM properties.\n     */\n\n    /**\n     * Get the value for a property on a node. Only used in DEV for SSR validation.\n     * The \"expected\" argument is used as a hint of what the expected value is.\n     * Some properties have multiple equivalent values.\n     */\n\n\n    function getValueForProperty(node, name, expected) {\n      {\n        var propertyInfo = getPropertyInfo(name);\n\n        if (propertyInfo) {\n          var mutationMethod = propertyInfo.mutationMethod;\n\n          if (mutationMethod || propertyInfo.mustUseProperty) {\n            return node[propertyInfo.propertyName];\n          } else {\n            var attributeName = propertyInfo.attributeName;\n            var stringValue = null;\n\n            if (propertyInfo.hasOverloadedBooleanValue) {\n              if (node.hasAttribute(attributeName)) {\n                var value = node.getAttribute(attributeName);\n\n                if (value === '') {\n                  return true;\n                }\n\n                if (shouldIgnoreValue(propertyInfo, expected)) {\n                  return value;\n                }\n\n                if (value === '' + expected) {\n                  return expected;\n                }\n\n                return value;\n              }\n            } else if (node.hasAttribute(attributeName)) {\n              if (shouldIgnoreValue(propertyInfo, expected)) {\n                // We had an attribute but shouldn't have had one, so read it\n                // for the error message.\n                return node.getAttribute(attributeName);\n              }\n\n              if (propertyInfo.hasBooleanValue) {\n                // If this was a boolean, it doesn't matter what the value is\n                // the fact that we have it is the same as the expected.\n                return expected;\n              } // Even if this property uses a namespace we use getAttribute\n              // because we assume its namespaced name is the same as our config.\n              // To use getAttributeNS we need the local name which we don't have\n              // in our config atm.\n\n\n              stringValue = node.getAttribute(attributeName);\n            }\n\n            if (shouldIgnoreValue(propertyInfo, expected)) {\n              return stringValue === null ? expected : stringValue;\n            } else if (stringValue === '' + expected) {\n              return expected;\n            } else {\n              return stringValue;\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n     * The third argument is used as a hint of what the expected value is. Some\n     * attributes have multiple equivalent values.\n     */\n\n\n    function getValueForAttribute(node, name, expected) {\n      {\n        if (!isAttributeNameSafe(name)) {\n          return;\n        }\n\n        if (!node.hasAttribute(name)) {\n          return expected === undefined ? undefined : null;\n        }\n\n        var value = node.getAttribute(name);\n\n        if (value === '' + expected) {\n          return expected;\n        }\n\n        return value;\n      }\n    }\n    /**\n     * Sets the value for a property on a node.\n     *\n     * @param {DOMElement} node\n     * @param {string} name\n     * @param {*} value\n     */\n\n\n    function setValueForProperty(node, name, value) {\n      var propertyInfo = getPropertyInfo(name);\n\n      if (propertyInfo && shouldSetAttribute(name, value)) {\n        var mutationMethod = propertyInfo.mutationMethod;\n\n        if (mutationMethod) {\n          mutationMethod(node, value);\n        } else if (shouldIgnoreValue(propertyInfo, value)) {\n          deleteValueForProperty(node, name);\n          return;\n        } else if (propertyInfo.mustUseProperty) {\n          // Contrary to `setAttribute`, object properties are properly\n          // `toString`ed by IE8/9.\n          node[propertyInfo.propertyName] = value;\n        } else {\n          var attributeName = propertyInfo.attributeName;\n          var namespace = propertyInfo.attributeNamespace; // `setAttribute` with objects becomes only `[object]` in IE8/9,\n          // ('' + value) makes it output the correct toString()-value.\n\n          if (namespace) {\n            node.setAttributeNS(namespace, attributeName, '' + value);\n          } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {\n            node.setAttribute(attributeName, '');\n          } else {\n            node.setAttribute(attributeName, '' + value);\n          }\n        }\n      } else {\n        setValueForAttribute(node, name, shouldSetAttribute(name, value) ? value : null);\n        return;\n      }\n\n      {}\n    }\n\n    function setValueForAttribute(node, name, value) {\n      if (!isAttributeNameSafe(name)) {\n        return;\n      }\n\n      if (value == null) {\n        node.removeAttribute(name);\n      } else {\n        node.setAttribute(name, '' + value);\n      }\n\n      {}\n    }\n    /**\n     * Deletes an attributes from a node.\n     *\n     * @param {DOMElement} node\n     * @param {string} name\n     */\n\n\n    function deleteValueForAttribute(node, name) {\n      node.removeAttribute(name);\n    }\n    /**\n     * Deletes the value for a property on a node.\n     *\n     * @param {DOMElement} node\n     * @param {string} name\n     */\n\n\n    function deleteValueForProperty(node, name) {\n      var propertyInfo = getPropertyInfo(name);\n\n      if (propertyInfo) {\n        var mutationMethod = propertyInfo.mutationMethod;\n\n        if (mutationMethod) {\n          mutationMethod(node, undefined);\n        } else if (propertyInfo.mustUseProperty) {\n          var propName = propertyInfo.propertyName;\n\n          if (propertyInfo.hasBooleanValue) {\n            node[propName] = false;\n          } else {\n            node[propName] = '';\n          }\n        } else {\n          node.removeAttribute(propertyInfo.attributeName);\n        }\n      } else {\n        node.removeAttribute(name);\n      }\n    }\n\n    var ReactControlledValuePropTypes = {\n      checkPropTypes: null\n    };\n    {\n      var hasReadOnlyValue = {\n        button: true,\n        checkbox: true,\n        image: true,\n        hidden: true,\n        radio: true,\n        reset: true,\n        submit: true\n      };\n      var propTypes = {\n        value: function (props, propName, componentName) {\n          if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {\n            return null;\n          }\n\n          return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n        },\n        checked: function (props, propName, componentName) {\n          if (!props[propName] || props.onChange || props.readOnly || props.disabled) {\n            return null;\n          }\n\n          return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n        }\n      };\n      /**\n       * Provide a linked `value` attribute for controlled forms. You should not use\n       * this outside of the ReactDOM controlled form components.\n       */\n\n      ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {\n        checkPropTypes(propTypes, props, 'prop', tagName, getStack);\n      };\n    } // TODO: direct imports like some-package/src/* are bad. Fix me.\n\n    var getCurrentFiberOwnerName$2 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\n    var getCurrentFiberStackAddendum$3 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n    var didWarnValueDefaultValue = false;\n    var didWarnCheckedDefaultChecked = false;\n    var didWarnControlledToUncontrolled = false;\n    var didWarnUncontrolledToControlled = false;\n\n    function isControlled(props) {\n      var usesChecked = props.type === 'checkbox' || props.type === 'radio';\n      return usesChecked ? props.checked != null : props.value != null;\n    }\n    /**\n     * Implements an <input> host component that allows setting these optional\n     * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n     *\n     * If `checked` or `value` are not supplied (or null/undefined), user actions\n     * that affect the checked state or value will trigger updates to the element.\n     *\n     * If they are supplied (and not null/undefined), the rendered element will not\n     * trigger updates to the element. Instead, the props must change in order for\n     * the rendered element to be updated.\n     *\n     * The rendered element will be initialized as unchecked (or `defaultChecked`)\n     * with an empty value (or `defaultValue`).\n     *\n     * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n     */\n\n\n    function getHostProps(element, props) {\n      var node = element;\n      var value = props.value;\n      var checked = props.checked;\n\n      var hostProps = _assign({\n        // Make sure we set .type before any other properties (setting .value\n        // before .type means .value is lost in IE11 and below)\n        type: undefined,\n        // Make sure we set .step before .value (setting .value before .step\n        // means .value is rounded on mount, based upon step precision)\n        step: undefined,\n        // Make sure we set .min & .max before .value (to ensure proper order\n        // in corner cases such as min or max deriving from value, e.g. Issue #7170)\n        min: undefined,\n        max: undefined\n      }, props, {\n        defaultChecked: undefined,\n        defaultValue: undefined,\n        value: value != null ? value : node._wrapperState.initialValue,\n        checked: checked != null ? checked : node._wrapperState.initialChecked\n      });\n\n      return hostProps;\n    }\n\n    function initWrapperState(element, props) {\n      {\n        ReactControlledValuePropTypes.checkPropTypes('input', props, getCurrentFiberStackAddendum$3);\n\n        if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {\n          warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);\n          didWarnCheckedDefaultChecked = true;\n        }\n\n        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {\n          warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);\n          didWarnValueDefaultValue = true;\n        }\n      }\n      var defaultValue = props.defaultValue;\n      var node = element;\n      node._wrapperState = {\n        initialChecked: props.checked != null ? props.checked : props.defaultChecked,\n        initialValue: props.value != null ? props.value : defaultValue,\n        controlled: isControlled(props)\n      };\n    }\n\n    function updateWrapper(element, props) {\n      var node = element;\n      {\n        var controlled = isControlled(props);\n\n        if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {\n          warning(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());\n          didWarnUncontrolledToControlled = true;\n        }\n\n        if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {\n          warning(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());\n          didWarnControlledToUncontrolled = true;\n        }\n      }\n      var checked = props.checked;\n\n      if (checked != null) {\n        setValueForProperty(node, 'checked', checked || false);\n      }\n\n      var value = props.value;\n\n      if (value != null) {\n        if (value === 0 && node.value === '') {\n          node.value = '0'; // Note: IE9 reports a number inputs as 'text', so check props instead.\n        } else if (props.type === 'number') {\n          // Simulate `input.valueAsNumber`. IE9 does not support it\n          var valueAsNumber = parseFloat(node.value) || 0;\n\n          if ( // eslint-disable-next-line\n          value != valueAsNumber || // eslint-disable-next-line\n          value == valueAsNumber && node.value != value) {\n            // Cast `value` to a string to ensure the value is set correctly. While\n            // browsers typically do this as necessary, jsdom doesn't.\n            node.value = '' + value;\n          }\n        } else if (node.value !== '' + value) {\n          // Cast `value` to a string to ensure the value is set correctly. While\n          // browsers typically do this as necessary, jsdom doesn't.\n          node.value = '' + value;\n        }\n      } else {\n        if (props.value == null && props.defaultValue != null) {\n          // In Chrome, assigning defaultValue to certain input types triggers input validation.\n          // For number inputs, the display value loses trailing decimal points. For email inputs,\n          // Chrome raises \"The specified value <x> is not a valid email address\".\n          //\n          // Here we check to see if the defaultValue has actually changed, avoiding these problems\n          // when the user is inputting text\n          //\n          // https://github.com/facebook/react/issues/7253\n          if (node.defaultValue !== '' + props.defaultValue) {\n            node.defaultValue = '' + props.defaultValue;\n          }\n        }\n\n        if (props.checked == null && props.defaultChecked != null) {\n          node.defaultChecked = !!props.defaultChecked;\n        }\n      }\n    }\n\n    function postMountWrapper(element, props) {\n      var node = element; // Detach value from defaultValue. We won't do anything if we're working on\n      // submit or reset inputs as those values & defaultValues are linked. They\n      // are not resetable nodes so this operation doesn't matter and actually\n      // removes browser-default values (eg \"Submit Query\") when no value is\n      // provided.\n\n      switch (props.type) {\n        case 'submit':\n        case 'reset':\n          break;\n\n        case 'color':\n        case 'date':\n        case 'datetime':\n        case 'datetime-local':\n        case 'month':\n        case 'time':\n        case 'week':\n          // This fixes the no-show issue on iOS Safari and Android Chrome:\n          // https://github.com/facebook/react/issues/7233\n          node.value = '';\n          node.value = node.defaultValue;\n          break;\n\n        default:\n          node.value = node.value;\n          break;\n      } // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n      // this is needed to work around a chrome bug where setting defaultChecked\n      // will sometimes influence the value of checked (even after detachment).\n      // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n      // We need to temporarily unset name to avoid disrupting radio button groups.\n\n\n      var name = node.name;\n\n      if (name !== '') {\n        node.name = '';\n      }\n\n      node.defaultChecked = !node.defaultChecked;\n      node.defaultChecked = !node.defaultChecked;\n\n      if (name !== '') {\n        node.name = name;\n      }\n    }\n\n    function restoreControlledState$1(element, props) {\n      var node = element;\n      updateWrapper(node, props);\n      updateNamedCousins(node, props);\n    }\n\n    function updateNamedCousins(rootNode, props) {\n      var name = props.name;\n\n      if (props.type === 'radio' && name != null) {\n        var queryRoot = rootNode;\n\n        while (queryRoot.parentNode) {\n          queryRoot = queryRoot.parentNode;\n        } // If `rootNode.form` was non-null, then we could try `form.elements`,\n        // but that sometimes behaves strangely in IE8. We could also try using\n        // `form.getElementsByName`, but that will only return direct children\n        // and won't include inputs that use the HTML5 `form=` attribute. Since\n        // the input might not even be in a form. It might not even be in the\n        // document. Let's just use the local `querySelectorAll` to ensure we don't\n        // miss anything.\n\n\n        var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]');\n\n        for (var i = 0; i < group.length; i++) {\n          var otherNode = group[i];\n\n          if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n            continue;\n          } // This will throw if radio buttons rendered by different copies of React\n          // and the same name are rendered into the same form (same as #1939).\n          // That's probably okay; we don't support it just as we don't support\n          // mixing React radio buttons with non-React ones.\n\n\n          var otherProps = getFiberCurrentPropsFromNode$1(otherNode);\n          !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0; // If this is a controlled radio button group, forcing the input that\n          // was previously checked to update will cause it to be come re-checked\n          // as appropriate.\n\n          updateWrapper(otherNode, otherProps);\n        }\n      }\n    }\n\n    function flattenChildren(children) {\n      var content = ''; // Flatten children and warn if they aren't strings or numbers;\n      // invalid types are ignored.\n      // We can silently skip them because invalid DOM nesting warning\n      // catches these cases in Fiber.\n\n      React.Children.forEach(children, function (child) {\n        if (child == null) {\n          return;\n        }\n\n        if (typeof child === 'string' || typeof child === 'number') {\n          content += child;\n        }\n      });\n      return content;\n    }\n    /**\n     * Implements an <option> host component that warns when `selected` is set.\n     */\n\n\n    function validateProps(element, props) {\n      // TODO (yungsters): Remove support for `selected` in <option>.\n      {\n        warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');\n      }\n    }\n\n    function postMountWrapper$1(element, props) {\n      // value=\"\" should make a value attribute (#6219)\n      if (props.value != null) {\n        element.setAttribute('value', props.value);\n      }\n    }\n\n    function getHostProps$1(element, props) {\n      var hostProps = _assign({\n        children: undefined\n      }, props);\n\n      var content = flattenChildren(props.children);\n\n      if (content) {\n        hostProps.children = content;\n      }\n\n      return hostProps;\n    } // TODO: direct imports like some-package/src/* are bad. Fix me.\n\n\n    var getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\n    var getCurrentFiberStackAddendum$4 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n    {\n      var didWarnValueDefaultValue$1 = false;\n    }\n\n    function getDeclarationErrorAddendum() {\n      var ownerName = getCurrentFiberOwnerName$3();\n\n      if (ownerName) {\n        return '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n\n      return '';\n    }\n\n    var valuePropNames = ['value', 'defaultValue'];\n    /**\n     * Validation function for `value` and `defaultValue`.\n     */\n\n    function checkSelectPropTypes(props) {\n      ReactControlledValuePropTypes.checkPropTypes('select', props, getCurrentFiberStackAddendum$4);\n\n      for (var i = 0; i < valuePropNames.length; i++) {\n        var propName = valuePropNames[i];\n\n        if (props[propName] == null) {\n          continue;\n        }\n\n        var isArray = Array.isArray(props[propName]);\n\n        if (props.multiple && !isArray) {\n          warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());\n        } else if (!props.multiple && isArray) {\n          warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());\n        }\n      }\n    }\n\n    function updateOptions(node, multiple, propValue, setDefaultSelected) {\n      var options = node.options;\n\n      if (multiple) {\n        var selectedValues = propValue;\n        var selectedValue = {};\n\n        for (var i = 0; i < selectedValues.length; i++) {\n          // Prefix to avoid chaos with special keys.\n          selectedValue['$' + selectedValues[i]] = true;\n        }\n\n        for (var _i = 0; _i < options.length; _i++) {\n          var selected = selectedValue.hasOwnProperty('$' + options[_i].value);\n\n          if (options[_i].selected !== selected) {\n            options[_i].selected = selected;\n          }\n\n          if (selected && setDefaultSelected) {\n            options[_i].defaultSelected = true;\n          }\n        }\n      } else {\n        // Do not set `select.value` as exact behavior isn't consistent across all\n        // browsers for all cases.\n        var _selectedValue = '' + propValue;\n\n        var defaultSelected = null;\n\n        for (var _i2 = 0; _i2 < options.length; _i2++) {\n          if (options[_i2].value === _selectedValue) {\n            options[_i2].selected = true;\n\n            if (setDefaultSelected) {\n              options[_i2].defaultSelected = true;\n            }\n\n            return;\n          }\n\n          if (defaultSelected === null && !options[_i2].disabled) {\n            defaultSelected = options[_i2];\n          }\n        }\n\n        if (defaultSelected !== null) {\n          defaultSelected.selected = true;\n        }\n      }\n    }\n    /**\n     * Implements a <select> host component that allows optionally setting the\n     * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n     * stringable. If `multiple` is true, the prop must be an array of stringables.\n     *\n     * If `value` is not supplied (or null/undefined), user actions that change the\n     * selected option will trigger updates to the rendered options.\n     *\n     * If it is supplied (and not null/undefined), the rendered options will not\n     * update in response to user actions. Instead, the `value` prop must change in\n     * order for the rendered options to update.\n     *\n     * If `defaultValue` is provided, any options with the supplied values will be\n     * selected.\n     */\n\n\n    function getHostProps$2(element, props) {\n      return _assign({}, props, {\n        value: undefined\n      });\n    }\n\n    function initWrapperState$1(element, props) {\n      var node = element;\n      {\n        checkSelectPropTypes(props);\n      }\n      var value = props.value;\n      node._wrapperState = {\n        initialValue: value != null ? value : props.defaultValue,\n        wasMultiple: !!props.multiple\n      };\n      {\n        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {\n          warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n          didWarnValueDefaultValue$1 = true;\n        }\n      }\n    }\n\n    function postMountWrapper$2(element, props) {\n      var node = element;\n      node.multiple = !!props.multiple;\n      var value = props.value;\n\n      if (value != null) {\n        updateOptions(node, !!props.multiple, value, false);\n      } else if (props.defaultValue != null) {\n        updateOptions(node, !!props.multiple, props.defaultValue, true);\n      }\n    }\n\n    function postUpdateWrapper(element, props) {\n      var node = element; // After the initial mount, we control selected-ness manually so don't pass\n      // this value down\n\n      node._wrapperState.initialValue = undefined;\n      var wasMultiple = node._wrapperState.wasMultiple;\n      node._wrapperState.wasMultiple = !!props.multiple;\n      var value = props.value;\n\n      if (value != null) {\n        updateOptions(node, !!props.multiple, value, false);\n      } else if (wasMultiple !== !!props.multiple) {\n        // For simplicity, reapply `defaultValue` if `multiple` is toggled.\n        if (props.defaultValue != null) {\n          updateOptions(node, !!props.multiple, props.defaultValue, true);\n        } else {\n          // Revert the select back to its default unselected state.\n          updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);\n        }\n      }\n    }\n\n    function restoreControlledState$2(element, props) {\n      var node = element;\n      var value = props.value;\n\n      if (value != null) {\n        updateOptions(node, !!props.multiple, value, false);\n      }\n    } // TODO: direct imports like some-package/src/* are bad. Fix me.\n\n\n    var getCurrentFiberStackAddendum$5 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n    var didWarnValDefaultVal = false;\n    /**\n     * Implements a <textarea> host component that allows setting `value`, and\n     * `defaultValue`. This differs from the traditional DOM API because value is\n     * usually set as PCDATA children.\n     *\n     * If `value` is not supplied (or null/undefined), user actions that affect the\n     * value will trigger updates to the element.\n     *\n     * If `value` is supplied (and not null/undefined), the rendered element will\n     * not trigger updates to the element. Instead, the `value` prop must change in\n     * order for the rendered element to be updated.\n     *\n     * The rendered element will be initialized with an empty value, the prop\n     * `defaultValue` if specified, or the children content (deprecated).\n     */\n\n    function getHostProps$3(element, props) {\n      var node = element;\n      !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0; // Always set children to the same thing. In IE9, the selection range will\n      // get reset if `textContent` is mutated.  We could add a check in setTextContent\n      // to only set the value if/when the value differs from the node value (which would\n      // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n      // solution. The value can be a boolean or object so that's why it's forced\n      // to be a string.\n\n      var hostProps = _assign({}, props, {\n        value: undefined,\n        defaultValue: undefined,\n        children: '' + node._wrapperState.initialValue\n      });\n\n      return hostProps;\n    }\n\n    function initWrapperState$2(element, props) {\n      var node = element;\n      {\n        ReactControlledValuePropTypes.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$5);\n\n        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {\n          warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n          didWarnValDefaultVal = true;\n        }\n      }\n      var value = props.value;\n      var initialValue = value; // Only bother fetching default value if we're going to use it\n\n      if (value == null) {\n        var defaultValue = props.defaultValue; // TODO (yungsters): Remove support for children content in <textarea>.\n\n        var children = props.children;\n\n        if (children != null) {\n          {\n            warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');\n          }\n          !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;\n\n          if (Array.isArray(children)) {\n            !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;\n            children = children[0];\n          }\n\n          defaultValue = '' + children;\n        }\n\n        if (defaultValue == null) {\n          defaultValue = '';\n        }\n\n        initialValue = defaultValue;\n      }\n\n      node._wrapperState = {\n        initialValue: '' + initialValue\n      };\n    }\n\n    function updateWrapper$1(element, props) {\n      var node = element;\n      var value = props.value;\n\n      if (value != null) {\n        // Cast `value` to a string to ensure the value is set correctly. While\n        // browsers typically do this as necessary, jsdom doesn't.\n        var newValue = '' + value; // To avoid side effects (such as losing text selection), only set value if changed\n\n        if (newValue !== node.value) {\n          node.value = newValue;\n        }\n\n        if (props.defaultValue == null) {\n          node.defaultValue = newValue;\n        }\n      }\n\n      if (props.defaultValue != null) {\n        node.defaultValue = props.defaultValue;\n      }\n    }\n\n    function postMountWrapper$3(element, props) {\n      var node = element; // This is in postMount because we need access to the DOM node, which is not\n      // available until after the component has mounted.\n\n      var textContent = node.textContent; // Only set node.value if textContent is equal to the expected\n      // initial value. In IE10/IE11 there is a bug where the placeholder attribute\n      // will populate textContent as well.\n      // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\n\n      if (textContent === node._wrapperState.initialValue) {\n        node.value = textContent;\n      }\n    }\n\n    function restoreControlledState$3(element, props) {\n      // DOM component is still mounted; update\n      updateWrapper$1(element, props);\n    }\n\n    var HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';\n    var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    var Namespaces = {\n      html: HTML_NAMESPACE$1,\n      mathml: MATH_NAMESPACE,\n      svg: SVG_NAMESPACE\n    }; // Assumes there is no parent namespace.\n\n    function getIntrinsicNamespace(type) {\n      switch (type) {\n        case 'svg':\n          return SVG_NAMESPACE;\n\n        case 'math':\n          return MATH_NAMESPACE;\n\n        default:\n          return HTML_NAMESPACE$1;\n      }\n    }\n\n    function getChildNamespace(parentNamespace, type) {\n      if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {\n        // No (or default) parent namespace: potential entry point.\n        return getIntrinsicNamespace(type);\n      }\n\n      if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {\n        // We're leaving SVG.\n        return HTML_NAMESPACE$1;\n      } // By default, pass namespace below.\n\n\n      return parentNamespace;\n    }\n    /* globals MSApp */\n\n    /**\n     * Create a function which has 'unsafe' privileges (required by windows8 apps)\n     */\n\n\n    var createMicrosoftUnsafeLocalFunction = function (func) {\n      if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {\n        return function (arg0, arg1, arg2, arg3) {\n          MSApp.execUnsafeLocalFunction(function () {\n            return func(arg0, arg1, arg2, arg3);\n          });\n        };\n      } else {\n        return func;\n      }\n    }; // SVG temp container for IE lacking innerHTML\n\n\n    var reusableSVGContainer = void 0;\n    /**\n     * Set the innerHTML property of a node\n     *\n     * @param {DOMElement} node\n     * @param {string} html\n     * @internal\n     */\n\n    var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {\n      // IE does not have innerHTML for SVG nodes, so instead we inject the\n      // new markup in a temp node and then move the child nodes across into\n      // the target node\n      if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {\n        reusableSVGContainer = reusableSVGContainer || document.createElement('div');\n        reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';\n        var svgNode = reusableSVGContainer.firstChild;\n\n        while (node.firstChild) {\n          node.removeChild(node.firstChild);\n        }\n\n        while (svgNode.firstChild) {\n          node.appendChild(svgNode.firstChild);\n        }\n      } else {\n        node.innerHTML = html;\n      }\n    }); // code copied and modified from escape-html\n\n    /**\n     * Module variables.\n     * @private\n     */\n\n    var matchHtmlRegExp = /[\"'&<>]/;\n    /**\n     * Escape special characters in the given string of html.\n     *\n     * @param  {string} string The string to escape for inserting into HTML\n     * @return {string}\n     * @public\n     */\n\n    function escapeHtml(string) {\n      var str = '' + string;\n      var match = matchHtmlRegExp.exec(str);\n\n      if (!match) {\n        return str;\n      }\n\n      var escape;\n      var html = '';\n      var index = 0;\n      var lastIndex = 0;\n\n      for (index = match.index; index < str.length; index++) {\n        switch (str.charCodeAt(index)) {\n          case 34:\n            // \"\n            escape = '&quot;';\n            break;\n\n          case 38:\n            // &\n            escape = '&amp;';\n            break;\n\n          case 39:\n            // '\n            escape = '&#x27;'; // modified from escape-html; used to be '&#39'\n\n            break;\n\n          case 60:\n            // <\n            escape = '&lt;';\n            break;\n\n          case 62:\n            // >\n            escape = '&gt;';\n            break;\n\n          default:\n            continue;\n        }\n\n        if (lastIndex !== index) {\n          html += str.substring(lastIndex, index);\n        }\n\n        lastIndex = index + 1;\n        html += escape;\n      }\n\n      return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\n    } // end code copied and modified from escape-html\n\n    /**\n     * Escapes text to prevent scripting attacks.\n     *\n     * @param {*} text Text value to escape.\n     * @return {string} An escaped string.\n     */\n\n\n    function escapeTextContentForBrowser(text) {\n      if (typeof text === 'boolean' || typeof text === 'number') {\n        // this shortcircuit helps perf for types that we know will never have\n        // special characters, especially given that this function is used often\n        // for numeric dom ids.\n        return '' + text;\n      }\n\n      return escapeHtml(text);\n    }\n    /**\n     * Set the textContent property of a node, ensuring that whitespace is preserved\n     * even in IE8. innerText is a poor substitute for textContent and, among many\n     * issues, inserts <br> instead of the literal newline chars. innerHTML behaves\n     * as it should.\n     *\n     * @param {DOMElement} node\n     * @param {string} text\n     * @internal\n     */\n\n\n    var setTextContent = function (node, text) {\n      if (text) {\n        var firstChild = node.firstChild;\n\n        if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {\n          firstChild.nodeValue = text;\n          return;\n        }\n      }\n\n      node.textContent = text;\n    };\n\n    if (ExecutionEnvironment.canUseDOM) {\n      if (!('textContent' in document.documentElement)) {\n        setTextContent = function (node, text) {\n          if (node.nodeType === TEXT_NODE) {\n            node.nodeValue = text;\n            return;\n          }\n\n          setInnerHTML(node, escapeTextContentForBrowser(text));\n        };\n      }\n    }\n\n    var setTextContent$1 = setTextContent;\n    /**\n     * CSS properties which accept numbers but are not in units of \"px\".\n     */\n\n    var isUnitlessNumber = {\n      animationIterationCount: true,\n      borderImageOutset: true,\n      borderImageSlice: true,\n      borderImageWidth: true,\n      boxFlex: true,\n      boxFlexGroup: true,\n      boxOrdinalGroup: true,\n      columnCount: true,\n      columns: true,\n      flex: true,\n      flexGrow: true,\n      flexPositive: true,\n      flexShrink: true,\n      flexNegative: true,\n      flexOrder: true,\n      gridRow: true,\n      gridRowEnd: true,\n      gridRowSpan: true,\n      gridRowStart: true,\n      gridColumn: true,\n      gridColumnEnd: true,\n      gridColumnSpan: true,\n      gridColumnStart: true,\n      fontWeight: true,\n      lineClamp: true,\n      lineHeight: true,\n      opacity: true,\n      order: true,\n      orphans: true,\n      tabSize: true,\n      widows: true,\n      zIndex: true,\n      zoom: true,\n      // SVG-related properties\n      fillOpacity: true,\n      floodOpacity: true,\n      stopOpacity: true,\n      strokeDasharray: true,\n      strokeDashoffset: true,\n      strokeMiterlimit: true,\n      strokeOpacity: true,\n      strokeWidth: true\n    };\n    /**\n     * @param {string} prefix vendor-specific prefix, eg: Webkit\n     * @param {string} key style name, eg: transitionDuration\n     * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n     * WebkitTransitionDuration\n     */\n\n    function prefixKey(prefix, key) {\n      return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n    }\n    /**\n     * Support style names that may come passed in prefixed by adding permutations\n     * of vendor prefixes.\n     */\n\n\n    var prefixes = ['Webkit', 'ms', 'Moz', 'O']; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n    // infinite loop, because it iterates over the newly added props too.\n\n    Object.keys(isUnitlessNumber).forEach(function (prop) {\n      prefixes.forEach(function (prefix) {\n        isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n      });\n    });\n    /**\n     * Convert a value into the proper css writable value. The style name `name`\n     * should be logical (no hyphens), as specified\n     * in `CSSProperty.isUnitlessNumber`.\n     *\n     * @param {string} name CSS property name such as `topMargin`.\n     * @param {*} value CSS property value such as `10px`.\n     * @return {string} Normalized style value with dimensions applied.\n     */\n\n    function dangerousStyleValue(name, value, isCustomProperty) {\n      // Note that we've removed escapeTextForBrowser() calls here since the\n      // whole string will be escaped when the attribute is injected into\n      // the markup. If you provide unsafe user data here they can inject\n      // arbitrary CSS which may be problematic (I couldn't repro this):\n      // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n      // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n      // This is not an XSS hole but instead a potential CSS injection issue\n      // which has lead to a greater discussion about how we're going to\n      // trust URLs moving forward. See #2115901\n      var isEmpty = value == null || typeof value === 'boolean' || value === '';\n\n      if (isEmpty) {\n        return '';\n      }\n\n      if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {\n        return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n      }\n\n      return ('' + value).trim();\n    }\n\n    var warnValidStyle = emptyFunction$1;\n    {\n      // 'msTransform' is correct, but the other prefixes should be capitalized\n      var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/; // style values shouldn't contain a semicolon\n\n      var badStyleValueWithSemicolonPattern = /;\\s*$/;\n      var warnedStyleNames = {};\n      var warnedStyleValues = {};\n      var warnedForNaNValue = false;\n      var warnedForInfinityValue = false;\n\n      var warnHyphenatedStyleName = function (name, getStack) {\n        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n          return;\n        }\n\n        warnedStyleNames[name] = true;\n        warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), getStack());\n      };\n\n      var warnBadVendoredStyleName = function (name, getStack) {\n        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n          return;\n        }\n\n        warnedStyleNames[name] = true;\n        warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), getStack());\n      };\n\n      var warnStyleValueWithSemicolon = function (name, value, getStack) {\n        if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n          return;\n        }\n\n        warnedStyleValues[value] = true;\n        warning(false, \"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.%s', name, value.replace(badStyleValueWithSemicolonPattern, ''), getStack());\n      };\n\n      var warnStyleValueIsNaN = function (name, value, getStack) {\n        if (warnedForNaNValue) {\n          return;\n        }\n\n        warnedForNaNValue = true;\n        warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, getStack());\n      };\n\n      var warnStyleValueIsInfinity = function (name, value, getStack) {\n        if (warnedForInfinityValue) {\n          return;\n        }\n\n        warnedForInfinityValue = true;\n        warning(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, getStack());\n      };\n\n      warnValidStyle = function (name, value, getStack) {\n        if (name.indexOf('-') > -1) {\n          warnHyphenatedStyleName(name, getStack);\n        } else if (badVendoredStyleNamePattern.test(name)) {\n          warnBadVendoredStyleName(name, getStack);\n        } else if (badStyleValueWithSemicolonPattern.test(value)) {\n          warnStyleValueWithSemicolon(name, value, getStack);\n        }\n\n        if (typeof value === 'number') {\n          if (isNaN(value)) {\n            warnStyleValueIsNaN(name, value, getStack);\n          } else if (!isFinite(value)) {\n            warnStyleValueIsInfinity(name, value, getStack);\n          }\n        }\n      };\n    }\n    var warnValidStyle$1 = warnValidStyle;\n    /**\n     * Operations for dealing with CSS properties.\n     */\n\n    /**\n     * This creates a string that is expected to be equivalent to the style\n     * attribute generated by server-side rendering. It by-passes warnings and\n     * security checks so it's not safe to use this value for anything other than\n     * comparison. It is only used in DEV for SSR validation.\n     */\n\n    function createDangerousStringForStyles(styles) {\n      {\n        var serialized = '';\n        var delimiter = '';\n\n        for (var styleName in styles) {\n          if (!styles.hasOwnProperty(styleName)) {\n            continue;\n          }\n\n          var styleValue = styles[styleName];\n\n          if (styleValue != null) {\n            var isCustomProperty = styleName.indexOf('--') === 0;\n            serialized += delimiter + hyphenateStyleName(styleName) + ':';\n            serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);\n            delimiter = ';';\n          }\n        }\n\n        return serialized || null;\n      }\n    }\n    /**\n     * Sets the value for multiple styles on a node.  If a value is specified as\n     * '' (empty string), the corresponding style property will be unset.\n     *\n     * @param {DOMElement} node\n     * @param {object} styles\n     */\n\n\n    function setValueForStyles(node, styles, getStack) {\n      var style = node.style;\n\n      for (var styleName in styles) {\n        if (!styles.hasOwnProperty(styleName)) {\n          continue;\n        }\n\n        var isCustomProperty = styleName.indexOf('--') === 0;\n        {\n          if (!isCustomProperty) {\n            warnValidStyle$1(styleName, styles[styleName], getStack);\n          }\n        }\n        var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\n\n        if (styleName === 'float') {\n          styleName = 'cssFloat';\n        }\n\n        if (isCustomProperty) {\n          style.setProperty(styleName, styleValue);\n        } else {\n          style[styleName] = styleValue;\n        }\n      }\n    } // For HTML, certain tags should omit their close tag. We keep a whitelist for\n    // those special-case tags.\n\n\n    var omittedCloseTags = {\n      area: true,\n      base: true,\n      br: true,\n      col: true,\n      embed: true,\n      hr: true,\n      img: true,\n      input: true,\n      keygen: true,\n      link: true,\n      meta: true,\n      param: true,\n      source: true,\n      track: true,\n      wbr: true\n    }; // For HTML, certain tags cannot have children. This has the same purpose as\n    // `omittedCloseTags` except that `menuitem` should still have its closing tag.\n\n    var voidElementTags = _assign({\n      menuitem: true\n    }, omittedCloseTags);\n\n    var HTML$1 = '__html';\n\n    function assertValidProps(tag, props, getStack) {\n      if (!props) {\n        return;\n      } // Note the use of `==` which checks for null or undefined.\n\n\n      if (voidElementTags[tag]) {\n        !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getStack()) : void 0;\n      }\n\n      if (props.dangerouslySetInnerHTML != null) {\n        !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;\n        !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;\n      }\n\n      {\n        warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.%s', getStack());\n      }\n      !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \\'em\\'}} when using JSX.%s', getStack()) : void 0;\n    }\n\n    function isCustomComponent(tagName, props) {\n      if (tagName.indexOf('-') === -1) {\n        return typeof props.is === 'string';\n      }\n\n      switch (tagName) {\n        // These are reserved SVG and MathML elements.\n        // We don't mind this whitelist too much because we expect it to never grow.\n        // The alternative is to track the namespace in a few places which is convoluted.\n        // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n        case 'annotation-xml':\n        case 'color-profile':\n        case 'font-face':\n        case 'font-face-src':\n        case 'font-face-uri':\n        case 'font-face-format':\n        case 'font-face-name':\n        case 'missing-glyph':\n          return false;\n\n        default:\n          return true;\n      }\n    }\n\n    var ariaProperties = {\n      'aria-current': 0,\n      // state\n      'aria-details': 0,\n      'aria-disabled': 0,\n      // state\n      'aria-hidden': 0,\n      // state\n      'aria-invalid': 0,\n      // state\n      'aria-keyshortcuts': 0,\n      'aria-label': 0,\n      'aria-roledescription': 0,\n      // Widget Attributes\n      'aria-autocomplete': 0,\n      'aria-checked': 0,\n      'aria-expanded': 0,\n      'aria-haspopup': 0,\n      'aria-level': 0,\n      'aria-modal': 0,\n      'aria-multiline': 0,\n      'aria-multiselectable': 0,\n      'aria-orientation': 0,\n      'aria-placeholder': 0,\n      'aria-pressed': 0,\n      'aria-readonly': 0,\n      'aria-required': 0,\n      'aria-selected': 0,\n      'aria-sort': 0,\n      'aria-valuemax': 0,\n      'aria-valuemin': 0,\n      'aria-valuenow': 0,\n      'aria-valuetext': 0,\n      // Live Region Attributes\n      'aria-atomic': 0,\n      'aria-busy': 0,\n      'aria-live': 0,\n      'aria-relevant': 0,\n      // Drag-and-Drop Attributes\n      'aria-dropeffect': 0,\n      'aria-grabbed': 0,\n      // Relationship Attributes\n      'aria-activedescendant': 0,\n      'aria-colcount': 0,\n      'aria-colindex': 0,\n      'aria-colspan': 0,\n      'aria-controls': 0,\n      'aria-describedby': 0,\n      'aria-errormessage': 0,\n      'aria-flowto': 0,\n      'aria-labelledby': 0,\n      'aria-owns': 0,\n      'aria-posinset': 0,\n      'aria-rowcount': 0,\n      'aria-rowindex': 0,\n      'aria-rowspan': 0,\n      'aria-setsize': 0\n    };\n    var warnedProperties = {};\n    var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\n    var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    function getStackAddendum() {\n      var stack = ReactDebugCurrentFrame.getStackAddendum();\n      return stack != null ? stack : '';\n    }\n\n    function validateProperty(tagName, name) {\n      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n        return true;\n      }\n\n      if (rARIACamel.test(name)) {\n        var ariaName = 'aria-' + name.slice(4).toLowerCase();\n        var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n        // DOM properties, then it is an invalid aria-* attribute.\n\n        if (correctName == null) {\n          warning(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum());\n          warnedProperties[name] = true;\n          return true;\n        } // aria-* attributes should be lowercase; suggest the lowercase version.\n\n\n        if (name !== correctName) {\n          warning(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum());\n          warnedProperties[name] = true;\n          return true;\n        }\n      }\n\n      if (rARIA.test(name)) {\n        var lowerCasedName = name.toLowerCase();\n        var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n        // DOM properties, then it is an invalid aria-* attribute.\n\n        if (standardName == null) {\n          warnedProperties[name] = true;\n          return false;\n        } // aria-* attributes should be lowercase; suggest the lowercase version.\n\n\n        if (name !== standardName) {\n          warning(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum());\n          warnedProperties[name] = true;\n          return true;\n        }\n      }\n\n      return true;\n    }\n\n    function warnInvalidARIAProps(type, props) {\n      var invalidProps = [];\n\n      for (var key in props) {\n        var isValid = validateProperty(type, key);\n\n        if (!isValid) {\n          invalidProps.push(key);\n        }\n      }\n\n      var unknownPropString = invalidProps.map(function (prop) {\n        return '`' + prop + '`';\n      }).join(', ');\n\n      if (invalidProps.length === 1) {\n        warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());\n      } else if (invalidProps.length > 1) {\n        warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());\n      }\n    }\n\n    function validateProperties(type, props) {\n      if (isCustomComponent(type, props)) {\n        return;\n      }\n\n      warnInvalidARIAProps(type, props);\n    }\n\n    var didWarnValueNull = false;\n\n    function getStackAddendum$1() {\n      var stack = ReactDebugCurrentFrame.getStackAddendum();\n      return stack != null ? stack : '';\n    }\n\n    function validateProperties$1(type, props) {\n      if (type !== 'input' && type !== 'textarea' && type !== 'select') {\n        return;\n      }\n\n      if (props != null && props.value === null && !didWarnValueNull) {\n        didWarnValueNull = true;\n\n        if (type === 'select' && props.multiple) {\n          warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.%s', type, getStackAddendum$1());\n        } else {\n          warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1());\n        }\n      }\n    } // When adding attributes to the HTML or SVG whitelist, be sure to\n    // also add them to this module to ensure casing and incorrect name\n    // warnings.\n\n\n    var possibleStandardNames = {\n      // HTML\n      accept: 'accept',\n      acceptcharset: 'acceptCharset',\n      'accept-charset': 'acceptCharset',\n      accesskey: 'accessKey',\n      action: 'action',\n      allowfullscreen: 'allowFullScreen',\n      alt: 'alt',\n      as: 'as',\n      async: 'async',\n      autocapitalize: 'autoCapitalize',\n      autocomplete: 'autoComplete',\n      autocorrect: 'autoCorrect',\n      autofocus: 'autoFocus',\n      autoplay: 'autoPlay',\n      autosave: 'autoSave',\n      capture: 'capture',\n      cellpadding: 'cellPadding',\n      cellspacing: 'cellSpacing',\n      challenge: 'challenge',\n      charset: 'charSet',\n      checked: 'checked',\n      children: 'children',\n      cite: 'cite',\n      'class': 'className',\n      classid: 'classID',\n      classname: 'className',\n      cols: 'cols',\n      colspan: 'colSpan',\n      content: 'content',\n      contenteditable: 'contentEditable',\n      contextmenu: 'contextMenu',\n      controls: 'controls',\n      controlslist: 'controlsList',\n      coords: 'coords',\n      crossorigin: 'crossOrigin',\n      dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',\n      data: 'data',\n      datetime: 'dateTime',\n      'default': 'default',\n      defaultchecked: 'defaultChecked',\n      defaultvalue: 'defaultValue',\n      defer: 'defer',\n      dir: 'dir',\n      disabled: 'disabled',\n      download: 'download',\n      draggable: 'draggable',\n      enctype: 'encType',\n      'for': 'htmlFor',\n      form: 'form',\n      formmethod: 'formMethod',\n      formaction: 'formAction',\n      formenctype: 'formEncType',\n      formnovalidate: 'formNoValidate',\n      formtarget: 'formTarget',\n      frameborder: 'frameBorder',\n      headers: 'headers',\n      height: 'height',\n      hidden: 'hidden',\n      high: 'high',\n      href: 'href',\n      hreflang: 'hrefLang',\n      htmlfor: 'htmlFor',\n      httpequiv: 'httpEquiv',\n      'http-equiv': 'httpEquiv',\n      icon: 'icon',\n      id: 'id',\n      innerhtml: 'innerHTML',\n      inputmode: 'inputMode',\n      integrity: 'integrity',\n      is: 'is',\n      itemid: 'itemID',\n      itemprop: 'itemProp',\n      itemref: 'itemRef',\n      itemscope: 'itemScope',\n      itemtype: 'itemType',\n      keyparams: 'keyParams',\n      keytype: 'keyType',\n      kind: 'kind',\n      label: 'label',\n      lang: 'lang',\n      list: 'list',\n      loop: 'loop',\n      low: 'low',\n      manifest: 'manifest',\n      marginwidth: 'marginWidth',\n      marginheight: 'marginHeight',\n      max: 'max',\n      maxlength: 'maxLength',\n      media: 'media',\n      mediagroup: 'mediaGroup',\n      method: 'method',\n      min: 'min',\n      minlength: 'minLength',\n      multiple: 'multiple',\n      muted: 'muted',\n      name: 'name',\n      nonce: 'nonce',\n      novalidate: 'noValidate',\n      open: 'open',\n      optimum: 'optimum',\n      pattern: 'pattern',\n      placeholder: 'placeholder',\n      playsinline: 'playsInline',\n      poster: 'poster',\n      preload: 'preload',\n      profile: 'profile',\n      radiogroup: 'radioGroup',\n      readonly: 'readOnly',\n      referrerpolicy: 'referrerPolicy',\n      rel: 'rel',\n      required: 'required',\n      reversed: 'reversed',\n      role: 'role',\n      rows: 'rows',\n      rowspan: 'rowSpan',\n      sandbox: 'sandbox',\n      scope: 'scope',\n      scoped: 'scoped',\n      scrolling: 'scrolling',\n      seamless: 'seamless',\n      selected: 'selected',\n      shape: 'shape',\n      size: 'size',\n      sizes: 'sizes',\n      span: 'span',\n      spellcheck: 'spellCheck',\n      src: 'src',\n      srcdoc: 'srcDoc',\n      srclang: 'srcLang',\n      srcset: 'srcSet',\n      start: 'start',\n      step: 'step',\n      style: 'style',\n      summary: 'summary',\n      tabindex: 'tabIndex',\n      target: 'target',\n      title: 'title',\n      type: 'type',\n      usemap: 'useMap',\n      value: 'value',\n      width: 'width',\n      wmode: 'wmode',\n      wrap: 'wrap',\n      // SVG\n      about: 'about',\n      accentheight: 'accentHeight',\n      'accent-height': 'accentHeight',\n      accumulate: 'accumulate',\n      additive: 'additive',\n      alignmentbaseline: 'alignmentBaseline',\n      'alignment-baseline': 'alignmentBaseline',\n      allowreorder: 'allowReorder',\n      alphabetic: 'alphabetic',\n      amplitude: 'amplitude',\n      arabicform: 'arabicForm',\n      'arabic-form': 'arabicForm',\n      ascent: 'ascent',\n      attributename: 'attributeName',\n      attributetype: 'attributeType',\n      autoreverse: 'autoReverse',\n      azimuth: 'azimuth',\n      basefrequency: 'baseFrequency',\n      baselineshift: 'baselineShift',\n      'baseline-shift': 'baselineShift',\n      baseprofile: 'baseProfile',\n      bbox: 'bbox',\n      begin: 'begin',\n      bias: 'bias',\n      by: 'by',\n      calcmode: 'calcMode',\n      capheight: 'capHeight',\n      'cap-height': 'capHeight',\n      clip: 'clip',\n      clippath: 'clipPath',\n      'clip-path': 'clipPath',\n      clippathunits: 'clipPathUnits',\n      cliprule: 'clipRule',\n      'clip-rule': 'clipRule',\n      color: 'color',\n      colorinterpolation: 'colorInterpolation',\n      'color-interpolation': 'colorInterpolation',\n      colorinterpolationfilters: 'colorInterpolationFilters',\n      'color-interpolation-filters': 'colorInterpolationFilters',\n      colorprofile: 'colorProfile',\n      'color-profile': 'colorProfile',\n      colorrendering: 'colorRendering',\n      'color-rendering': 'colorRendering',\n      contentscripttype: 'contentScriptType',\n      contentstyletype: 'contentStyleType',\n      cursor: 'cursor',\n      cx: 'cx',\n      cy: 'cy',\n      d: 'd',\n      datatype: 'datatype',\n      decelerate: 'decelerate',\n      descent: 'descent',\n      diffuseconstant: 'diffuseConstant',\n      direction: 'direction',\n      display: 'display',\n      divisor: 'divisor',\n      dominantbaseline: 'dominantBaseline',\n      'dominant-baseline': 'dominantBaseline',\n      dur: 'dur',\n      dx: 'dx',\n      dy: 'dy',\n      edgemode: 'edgeMode',\n      elevation: 'elevation',\n      enablebackground: 'enableBackground',\n      'enable-background': 'enableBackground',\n      end: 'end',\n      exponent: 'exponent',\n      externalresourcesrequired: 'externalResourcesRequired',\n      fill: 'fill',\n      fillopacity: 'fillOpacity',\n      'fill-opacity': 'fillOpacity',\n      fillrule: 'fillRule',\n      'fill-rule': 'fillRule',\n      filter: 'filter',\n      filterres: 'filterRes',\n      filterunits: 'filterUnits',\n      floodopacity: 'floodOpacity',\n      'flood-opacity': 'floodOpacity',\n      floodcolor: 'floodColor',\n      'flood-color': 'floodColor',\n      focusable: 'focusable',\n      fontfamily: 'fontFamily',\n      'font-family': 'fontFamily',\n      fontsize: 'fontSize',\n      'font-size': 'fontSize',\n      fontsizeadjust: 'fontSizeAdjust',\n      'font-size-adjust': 'fontSizeAdjust',\n      fontstretch: 'fontStretch',\n      'font-stretch': 'fontStretch',\n      fontstyle: 'fontStyle',\n      'font-style': 'fontStyle',\n      fontvariant: 'fontVariant',\n      'font-variant': 'fontVariant',\n      fontweight: 'fontWeight',\n      'font-weight': 'fontWeight',\n      format: 'format',\n      from: 'from',\n      fx: 'fx',\n      fy: 'fy',\n      g1: 'g1',\n      g2: 'g2',\n      glyphname: 'glyphName',\n      'glyph-name': 'glyphName',\n      glyphorientationhorizontal: 'glyphOrientationHorizontal',\n      'glyph-orientation-horizontal': 'glyphOrientationHorizontal',\n      glyphorientationvertical: 'glyphOrientationVertical',\n      'glyph-orientation-vertical': 'glyphOrientationVertical',\n      glyphref: 'glyphRef',\n      gradienttransform: 'gradientTransform',\n      gradientunits: 'gradientUnits',\n      hanging: 'hanging',\n      horizadvx: 'horizAdvX',\n      'horiz-adv-x': 'horizAdvX',\n      horizoriginx: 'horizOriginX',\n      'horiz-origin-x': 'horizOriginX',\n      ideographic: 'ideographic',\n      imagerendering: 'imageRendering',\n      'image-rendering': 'imageRendering',\n      in2: 'in2',\n      'in': 'in',\n      inlist: 'inlist',\n      intercept: 'intercept',\n      k1: 'k1',\n      k2: 'k2',\n      k3: 'k3',\n      k4: 'k4',\n      k: 'k',\n      kernelmatrix: 'kernelMatrix',\n      kernelunitlength: 'kernelUnitLength',\n      kerning: 'kerning',\n      keypoints: 'keyPoints',\n      keysplines: 'keySplines',\n      keytimes: 'keyTimes',\n      lengthadjust: 'lengthAdjust',\n      letterspacing: 'letterSpacing',\n      'letter-spacing': 'letterSpacing',\n      lightingcolor: 'lightingColor',\n      'lighting-color': 'lightingColor',\n      limitingconeangle: 'limitingConeAngle',\n      local: 'local',\n      markerend: 'markerEnd',\n      'marker-end': 'markerEnd',\n      markerheight: 'markerHeight',\n      markermid: 'markerMid',\n      'marker-mid': 'markerMid',\n      markerstart: 'markerStart',\n      'marker-start': 'markerStart',\n      markerunits: 'markerUnits',\n      markerwidth: 'markerWidth',\n      mask: 'mask',\n      maskcontentunits: 'maskContentUnits',\n      maskunits: 'maskUnits',\n      mathematical: 'mathematical',\n      mode: 'mode',\n      numoctaves: 'numOctaves',\n      offset: 'offset',\n      opacity: 'opacity',\n      operator: 'operator',\n      order: 'order',\n      orient: 'orient',\n      orientation: 'orientation',\n      origin: 'origin',\n      overflow: 'overflow',\n      overlineposition: 'overlinePosition',\n      'overline-position': 'overlinePosition',\n      overlinethickness: 'overlineThickness',\n      'overline-thickness': 'overlineThickness',\n      paintorder: 'paintOrder',\n      'paint-order': 'paintOrder',\n      panose1: 'panose1',\n      'panose-1': 'panose1',\n      pathlength: 'pathLength',\n      patterncontentunits: 'patternContentUnits',\n      patterntransform: 'patternTransform',\n      patternunits: 'patternUnits',\n      pointerevents: 'pointerEvents',\n      'pointer-events': 'pointerEvents',\n      points: 'points',\n      pointsatx: 'pointsAtX',\n      pointsaty: 'pointsAtY',\n      pointsatz: 'pointsAtZ',\n      prefix: 'prefix',\n      preservealpha: 'preserveAlpha',\n      preserveaspectratio: 'preserveAspectRatio',\n      primitiveunits: 'primitiveUnits',\n      property: 'property',\n      r: 'r',\n      radius: 'radius',\n      refx: 'refX',\n      refy: 'refY',\n      renderingintent: 'renderingIntent',\n      'rendering-intent': 'renderingIntent',\n      repeatcount: 'repeatCount',\n      repeatdur: 'repeatDur',\n      requiredextensions: 'requiredExtensions',\n      requiredfeatures: 'requiredFeatures',\n      resource: 'resource',\n      restart: 'restart',\n      result: 'result',\n      results: 'results',\n      rotate: 'rotate',\n      rx: 'rx',\n      ry: 'ry',\n      scale: 'scale',\n      security: 'security',\n      seed: 'seed',\n      shaperendering: 'shapeRendering',\n      'shape-rendering': 'shapeRendering',\n      slope: 'slope',\n      spacing: 'spacing',\n      specularconstant: 'specularConstant',\n      specularexponent: 'specularExponent',\n      speed: 'speed',\n      spreadmethod: 'spreadMethod',\n      startoffset: 'startOffset',\n      stddeviation: 'stdDeviation',\n      stemh: 'stemh',\n      stemv: 'stemv',\n      stitchtiles: 'stitchTiles',\n      stopcolor: 'stopColor',\n      'stop-color': 'stopColor',\n      stopopacity: 'stopOpacity',\n      'stop-opacity': 'stopOpacity',\n      strikethroughposition: 'strikethroughPosition',\n      'strikethrough-position': 'strikethroughPosition',\n      strikethroughthickness: 'strikethroughThickness',\n      'strikethrough-thickness': 'strikethroughThickness',\n      string: 'string',\n      stroke: 'stroke',\n      strokedasharray: 'strokeDasharray',\n      'stroke-dasharray': 'strokeDasharray',\n      strokedashoffset: 'strokeDashoffset',\n      'stroke-dashoffset': 'strokeDashoffset',\n      strokelinecap: 'strokeLinecap',\n      'stroke-linecap': 'strokeLinecap',\n      strokelinejoin: 'strokeLinejoin',\n      'stroke-linejoin': 'strokeLinejoin',\n      strokemiterlimit: 'strokeMiterlimit',\n      'stroke-miterlimit': 'strokeMiterlimit',\n      strokewidth: 'strokeWidth',\n      'stroke-width': 'strokeWidth',\n      strokeopacity: 'strokeOpacity',\n      'stroke-opacity': 'strokeOpacity',\n      suppresscontenteditablewarning: 'suppressContentEditableWarning',\n      suppresshydrationwarning: 'suppressHydrationWarning',\n      surfacescale: 'surfaceScale',\n      systemlanguage: 'systemLanguage',\n      tablevalues: 'tableValues',\n      targetx: 'targetX',\n      targety: 'targetY',\n      textanchor: 'textAnchor',\n      'text-anchor': 'textAnchor',\n      textdecoration: 'textDecoration',\n      'text-decoration': 'textDecoration',\n      textlength: 'textLength',\n      textrendering: 'textRendering',\n      'text-rendering': 'textRendering',\n      to: 'to',\n      transform: 'transform',\n      'typeof': 'typeof',\n      u1: 'u1',\n      u2: 'u2',\n      underlineposition: 'underlinePosition',\n      'underline-position': 'underlinePosition',\n      underlinethickness: 'underlineThickness',\n      'underline-thickness': 'underlineThickness',\n      unicode: 'unicode',\n      unicodebidi: 'unicodeBidi',\n      'unicode-bidi': 'unicodeBidi',\n      unicoderange: 'unicodeRange',\n      'unicode-range': 'unicodeRange',\n      unitsperem: 'unitsPerEm',\n      'units-per-em': 'unitsPerEm',\n      unselectable: 'unselectable',\n      valphabetic: 'vAlphabetic',\n      'v-alphabetic': 'vAlphabetic',\n      values: 'values',\n      vectoreffect: 'vectorEffect',\n      'vector-effect': 'vectorEffect',\n      version: 'version',\n      vertadvy: 'vertAdvY',\n      'vert-adv-y': 'vertAdvY',\n      vertoriginx: 'vertOriginX',\n      'vert-origin-x': 'vertOriginX',\n      vertoriginy: 'vertOriginY',\n      'vert-origin-y': 'vertOriginY',\n      vhanging: 'vHanging',\n      'v-hanging': 'vHanging',\n      videographic: 'vIdeographic',\n      'v-ideographic': 'vIdeographic',\n      viewbox: 'viewBox',\n      viewtarget: 'viewTarget',\n      visibility: 'visibility',\n      vmathematical: 'vMathematical',\n      'v-mathematical': 'vMathematical',\n      vocab: 'vocab',\n      widths: 'widths',\n      wordspacing: 'wordSpacing',\n      'word-spacing': 'wordSpacing',\n      writingmode: 'writingMode',\n      'writing-mode': 'writingMode',\n      x1: 'x1',\n      x2: 'x2',\n      x: 'x',\n      xchannelselector: 'xChannelSelector',\n      xheight: 'xHeight',\n      'x-height': 'xHeight',\n      xlinkactuate: 'xlinkActuate',\n      'xlink:actuate': 'xlinkActuate',\n      xlinkarcrole: 'xlinkArcrole',\n      'xlink:arcrole': 'xlinkArcrole',\n      xlinkhref: 'xlinkHref',\n      'xlink:href': 'xlinkHref',\n      xlinkrole: 'xlinkRole',\n      'xlink:role': 'xlinkRole',\n      xlinkshow: 'xlinkShow',\n      'xlink:show': 'xlinkShow',\n      xlinktitle: 'xlinkTitle',\n      'xlink:title': 'xlinkTitle',\n      xlinktype: 'xlinkType',\n      'xlink:type': 'xlinkType',\n      xmlbase: 'xmlBase',\n      'xml:base': 'xmlBase',\n      xmllang: 'xmlLang',\n      'xml:lang': 'xmlLang',\n      xmlns: 'xmlns',\n      'xml:space': 'xmlSpace',\n      xmlnsxlink: 'xmlnsXlink',\n      'xmlns:xlink': 'xmlnsXlink',\n      xmlspace: 'xmlSpace',\n      y1: 'y1',\n      y2: 'y2',\n      y: 'y',\n      ychannelselector: 'yChannelSelector',\n      z: 'z',\n      zoomandpan: 'zoomAndPan'\n    };\n\n    function getStackAddendum$2() {\n      var stack = ReactDebugCurrentFrame.getStackAddendum();\n      return stack != null ? stack : '';\n    }\n\n    {\n      var warnedProperties$1 = {};\n      var hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n      var EVENT_NAME_REGEX = /^on[A-Z]/;\n      var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\n      var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\n      var validateProperty$1 = function (tagName, name, value) {\n        if (hasOwnProperty$1.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n          return true;\n        }\n\n        if (registrationNameModules.hasOwnProperty(name)) {\n          return true;\n        }\n\n        if (plugins.length === 0 && EVENT_NAME_REGEX.test(name)) {\n          // If no event plugins have been injected, we might be in a server environment.\n          // Don't check events in this case.\n          return true;\n        }\n\n        var lowerCasedName = name.toLowerCase();\n        var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n\n        if (registrationName != null) {\n          warning(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2());\n          warnedProperties$1[name] = true;\n          return true;\n        }\n\n        if (lowerCasedName.indexOf('on') === 0 && lowerCasedName.length > 2) {\n          warning(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2());\n          warnedProperties$1[name] = true;\n          return true;\n        } // Let the ARIA attribute hook validate ARIA attributes\n\n\n        if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\n          return true;\n        }\n\n        if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {\n          warning(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');\n          warnedProperties$1[name] = true;\n          return true;\n        }\n\n        if (lowerCasedName === 'innerhtml') {\n          warning(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');\n          warnedProperties$1[name] = true;\n          return true;\n        }\n\n        if (lowerCasedName === 'aria') {\n          warning(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');\n          warnedProperties$1[name] = true;\n          return true;\n        }\n\n        if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {\n          warning(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2());\n          warnedProperties$1[name] = true;\n          return true;\n        }\n\n        if (typeof value === 'number' && isNaN(value)) {\n          warning(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2());\n          warnedProperties$1[name] = true;\n          return true;\n        }\n\n        var isReserved = isReservedProp(name); // Known attributes should match the casing specified in the property config.\n\n        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n          var standardName = possibleStandardNames[lowerCasedName];\n\n          if (standardName !== name) {\n            warning(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2());\n            warnedProperties$1[name] = true;\n            return true;\n          }\n        } else if (!isReserved && name !== lowerCasedName) {\n          // Unknown attributes should have lowercase casing since that's how they\n          // will be cased anyway with server rendering.\n          warning(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2());\n          warnedProperties$1[name] = true;\n          return true;\n        }\n\n        if (typeof value === 'boolean' && !shouldAttributeAcceptBooleanValue(name)) {\n          if (value) {\n            warning(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.%s', value, name, name, value, name, getStackAddendum$2());\n          } else {\n            warning(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', value, name, name, value, name, name, name, getStackAddendum$2());\n          }\n\n          warnedProperties$1[name] = true;\n          return true;\n        } // Now that we've validated casing, do not validate\n        // data types for reserved props\n\n\n        if (isReserved) {\n          return true;\n        } // Warn when a known attribute is a bad type\n\n\n        if (!shouldSetAttribute(name, value)) {\n          warnedProperties$1[name] = true;\n          return false;\n        }\n\n        return true;\n      };\n    }\n\n    var warnUnknownProperties = function (type, props) {\n      var unknownProps = [];\n\n      for (var key in props) {\n        var isValid = validateProperty$1(type, key, props[key]);\n\n        if (!isValid) {\n          unknownProps.push(key);\n        }\n      }\n\n      var unknownPropString = unknownProps.map(function (prop) {\n        return '`' + prop + '`';\n      }).join(', ');\n\n      if (unknownProps.length === 1) {\n        warning(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());\n      } else if (unknownProps.length > 1) {\n        warning(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());\n      }\n    };\n\n    function validateProperties$2(type, props) {\n      if (isCustomComponent(type, props)) {\n        return;\n      }\n\n      warnUnknownProperties(type, props);\n    } // TODO: direct imports like some-package/src/* are bad. Fix me.\n\n\n    var getCurrentFiberOwnerName$1 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\n    var getCurrentFiberStackAddendum$2 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n    var didWarnInvalidHydration = false;\n    var didWarnShadyDOM = false;\n    var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';\n    var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';\n    var SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';\n    var AUTOFOCUS = 'autoFocus';\n    var CHILDREN = 'children';\n    var STYLE = 'style';\n    var HTML = '__html';\n    var HTML_NAMESPACE = Namespaces.html;\n    var getStack = emptyFunction$1.thatReturns('');\n    {\n      getStack = getCurrentFiberStackAddendum$2;\n      var warnedUnknownTags = {\n        // Chrome is the only major browser not shipping <time>. But as of July\n        // 2017 it intends to ship it due to widespread usage. We intentionally\n        // *don't* warn for <time> even if it's unrecognized by Chrome because\n        // it soon will be, and many apps have been using it anyway.\n        time: true,\n        // There are working polyfills for <dialog>. Let people use it.\n        dialog: true\n      };\n\n      var validatePropertiesInDevelopment = function (type, props) {\n        validateProperties(type, props);\n        validateProperties$1(type, props);\n        validateProperties$2(type, props);\n      }; // HTML parsing normalizes CR and CRLF to LF.\n      // It also can turn \\u0000 into \\uFFFD inside attributes.\n      // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n      // If we have a mismatch, it might be caused by that.\n      // We will still patch up in this case but not fire the warning.\n\n\n      var NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g;\n      var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\n\n      var normalizeMarkupForTextOrAttribute = function (markup) {\n        var markupString = typeof markup === 'string' ? markup : '' + markup;\n        return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');\n      };\n\n      var warnForTextDifference = function (serverText, clientText) {\n        if (didWarnInvalidHydration) {\n          return;\n        }\n\n        var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);\n        var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);\n\n        if (normalizedServerText === normalizedClientText) {\n          return;\n        }\n\n        didWarnInvalidHydration = true;\n        warning(false, 'Text content did not match. Server: \"%s\" Client: \"%s\"', normalizedServerText, normalizedClientText);\n      };\n\n      var warnForPropDifference = function (propName, serverValue, clientValue) {\n        if (didWarnInvalidHydration) {\n          return;\n        }\n\n        var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);\n        var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);\n\n        if (normalizedServerValue === normalizedClientValue) {\n          return;\n        }\n\n        didWarnInvalidHydration = true;\n        warning(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));\n      };\n\n      var warnForExtraAttributes = function (attributeNames) {\n        if (didWarnInvalidHydration) {\n          return;\n        }\n\n        didWarnInvalidHydration = true;\n        var names = [];\n        attributeNames.forEach(function (name) {\n          names.push(name);\n        });\n        warning(false, 'Extra attributes from the server: %s', names);\n      };\n\n      var warnForInvalidEventListener = function (registrationName, listener) {\n        if (listener === false) {\n          warning(false, 'Expected `%s` listener to be a function, instead got `false`.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', registrationName, registrationName, registrationName, getCurrentFiberStackAddendum$2());\n        } else {\n          warning(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum$2());\n        }\n      }; // Parse the HTML and read it back to normalize the HTML string so that it\n      // can be used for comparison.\n\n\n      var normalizeHTML = function (parent, html) {\n        // We could have created a separate document here to avoid\n        // re-initializing custom elements if they exist. But this breaks\n        // how <noscript> is being handled. So we use the same document.\n        // See the discussion in https://github.com/facebook/react/pull/11157.\n        var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);\n        testElement.innerHTML = html;\n        return testElement.innerHTML;\n      };\n    }\n\n    function ensureListeningTo(rootContainerElement, registrationName) {\n      var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;\n      var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;\n      listenTo(registrationName, doc);\n    }\n\n    function getOwnerDocumentFromRootContainer(rootContainerElement) {\n      return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n    } // There are so many media events, it makes sense to just\n    // maintain a list rather than create a `trapBubbledEvent` for each\n\n\n    var mediaEvents = {\n      topAbort: 'abort',\n      topCanPlay: 'canplay',\n      topCanPlayThrough: 'canplaythrough',\n      topDurationChange: 'durationchange',\n      topEmptied: 'emptied',\n      topEncrypted: 'encrypted',\n      topEnded: 'ended',\n      topError: 'error',\n      topLoadedData: 'loadeddata',\n      topLoadedMetadata: 'loadedmetadata',\n      topLoadStart: 'loadstart',\n      topPause: 'pause',\n      topPlay: 'play',\n      topPlaying: 'playing',\n      topProgress: 'progress',\n      topRateChange: 'ratechange',\n      topSeeked: 'seeked',\n      topSeeking: 'seeking',\n      topStalled: 'stalled',\n      topSuspend: 'suspend',\n      topTimeUpdate: 'timeupdate',\n      topVolumeChange: 'volumechange',\n      topWaiting: 'waiting'\n    };\n\n    function trapClickOnNonInteractiveElement(node) {\n      // Mobile Safari does not fire properly bubble click events on\n      // non-interactive elements, which means delegated click listeners do not\n      // fire. The workaround for this bug involves attaching an empty click\n      // listener on the target node.\n      // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n      // Just set it using the onclick property so that we don't have to manage any\n      // bookkeeping for it. Not sure if we need to clear it when the listener is\n      // removed.\n      // TODO: Only do this for the relevant Safaris maybe?\n      node.onclick = emptyFunction$1;\n    }\n\n    function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {\n      for (var propKey in nextProps) {\n        if (!nextProps.hasOwnProperty(propKey)) {\n          continue;\n        }\n\n        var nextProp = nextProps[propKey];\n\n        if (propKey === STYLE) {\n          {\n            if (nextProp) {\n              // Freeze the next style object so that we can assume it won't be\n              // mutated. We have already warned for this in the past.\n              Object.freeze(nextProp);\n            }\n          } // Relies on `updateStylesByID` not mutating `styleUpdates`.\n\n          setValueForStyles(domElement, nextProp, getStack);\n        } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n          var nextHtml = nextProp ? nextProp[HTML] : undefined;\n\n          if (nextHtml != null) {\n            setInnerHTML(domElement, nextHtml);\n          }\n        } else if (propKey === CHILDREN) {\n          if (typeof nextProp === 'string') {\n            // Avoid setting initial textContent when the text is empty. In IE11 setting\n            // textContent on a <textarea> will cause the placeholder to not\n            // show within the <textarea> until it has been focused and blurred again.\n            // https://github.com/facebook/react/issues/6731#issuecomment-254874553\n            var canSetTextContent = tag !== 'textarea' || nextProp !== '';\n\n            if (canSetTextContent) {\n              setTextContent$1(domElement, nextProp);\n            }\n          } else if (typeof nextProp === 'number') {\n            setTextContent$1(domElement, '' + nextProp);\n          }\n        } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {// Noop\n        } else if (propKey === AUTOFOCUS) {// We polyfill it separately on the client during commit.\n          // We blacklist it here rather than in the property list because we emit it in SSR.\n        } else if (registrationNameModules.hasOwnProperty(propKey)) {\n          if (nextProp != null) {\n            if (true && typeof nextProp !== 'function') {\n              warnForInvalidEventListener(propKey, nextProp);\n            }\n\n            ensureListeningTo(rootContainerElement, propKey);\n          }\n        } else if (isCustomComponentTag) {\n          setValueForAttribute(domElement, propKey, nextProp);\n        } else if (nextProp != null) {\n          // If we're updating to null or undefined, we should remove the property\n          // from the DOM node instead of inadvertently setting to a string. This\n          // brings us in line with the same behavior we have on initial render.\n          setValueForProperty(domElement, propKey, nextProp);\n        }\n      }\n    }\n\n    function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {\n      // TODO: Handle wasCustomComponentTag\n      for (var i = 0; i < updatePayload.length; i += 2) {\n        var propKey = updatePayload[i];\n        var propValue = updatePayload[i + 1];\n\n        if (propKey === STYLE) {\n          setValueForStyles(domElement, propValue, getStack);\n        } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n          setInnerHTML(domElement, propValue);\n        } else if (propKey === CHILDREN) {\n          setTextContent$1(domElement, propValue);\n        } else if (isCustomComponentTag) {\n          if (propValue != null) {\n            setValueForAttribute(domElement, propKey, propValue);\n          } else {\n            deleteValueForAttribute(domElement, propKey);\n          }\n        } else if (propValue != null) {\n          setValueForProperty(domElement, propKey, propValue);\n        } else {\n          // If we're updating to null or undefined, we should remove the property\n          // from the DOM node instead of inadvertently setting to a string. This\n          // brings us in line with the same behavior we have on initial render.\n          deleteValueForProperty(domElement, propKey);\n        }\n      }\n    }\n\n    function createElement$1(type, props, rootContainerElement, parentNamespace) {\n      // We create tags in the namespace of their parent container, except HTML\n      var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);\n      var domElement;\n      var namespaceURI = parentNamespace;\n\n      if (namespaceURI === HTML_NAMESPACE) {\n        namespaceURI = getIntrinsicNamespace(type);\n      }\n\n      if (namespaceURI === HTML_NAMESPACE) {\n        {\n          var isCustomComponentTag = isCustomComponent(type, props); // Should this check be gated by parent namespace? Not sure we want to\n          // allow <SVG> or <mATH>.\n\n          warning(isCustomComponentTag || type === type.toLowerCase(), '<%s /> is using uppercase HTML. Always use lowercase HTML tags ' + 'in React.', type);\n        }\n\n        if (type === 'script') {\n          // Create the script via .innerHTML so its \"parser-inserted\" flag is\n          // set to true and it does not execute\n          var div = ownerDocument.createElement('div');\n          div.innerHTML = '<script><' + '/script>'; // eslint-disable-line\n          // This is guaranteed to yield a script element.\n\n          var firstChild = div.firstChild;\n          domElement = div.removeChild(firstChild);\n        } else if (typeof props.is === 'string') {\n          // $FlowIssue `createElement` should be updated for Web Components\n          domElement = ownerDocument.createElement(type, {\n            is: props.is\n          });\n        } else {\n          // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n          // See discussion in https://github.com/facebook/react/pull/6896\n          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\n          domElement = ownerDocument.createElement(type);\n        }\n      } else {\n        domElement = ownerDocument.createElementNS(namespaceURI, type);\n      }\n\n      {\n        if (namespaceURI === HTML_NAMESPACE) {\n          if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {\n            warnedUnknownTags[type] = true;\n            warning(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);\n          }\n        }\n      }\n      return domElement;\n    }\n\n    function createTextNode$1(text, rootContainerElement) {\n      return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);\n    }\n\n    function setInitialProperties$1(domElement, tag, rawProps, rootContainerElement) {\n      var isCustomComponentTag = isCustomComponent(tag, rawProps);\n      {\n        validatePropertiesInDevelopment(tag, rawProps);\n\n        if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n          warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');\n          didWarnShadyDOM = true;\n        }\n      } // TODO: Make sure that we check isMounted before firing any of these events.\n\n      var props;\n\n      switch (tag) {\n        case 'iframe':\n        case 'object':\n          trapBubbledEvent('topLoad', 'load', domElement);\n          props = rawProps;\n          break;\n\n        case 'video':\n        case 'audio':\n          // Create listener for each media event\n          for (var event in mediaEvents) {\n            if (mediaEvents.hasOwnProperty(event)) {\n              trapBubbledEvent(event, mediaEvents[event], domElement);\n            }\n          }\n\n          props = rawProps;\n          break;\n\n        case 'source':\n          trapBubbledEvent('topError', 'error', domElement);\n          props = rawProps;\n          break;\n\n        case 'img':\n        case 'image':\n          trapBubbledEvent('topError', 'error', domElement);\n          trapBubbledEvent('topLoad', 'load', domElement);\n          props = rawProps;\n          break;\n\n        case 'form':\n          trapBubbledEvent('topReset', 'reset', domElement);\n          trapBubbledEvent('topSubmit', 'submit', domElement);\n          props = rawProps;\n          break;\n\n        case 'details':\n          trapBubbledEvent('topToggle', 'toggle', domElement);\n          props = rawProps;\n          break;\n\n        case 'input':\n          initWrapperState(domElement, rawProps);\n          props = getHostProps(domElement, rawProps);\n          trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening\n          // to onChange. Even if there is no listener.\n\n          ensureListeningTo(rootContainerElement, 'onChange');\n          break;\n\n        case 'option':\n          validateProps(domElement, rawProps);\n          props = getHostProps$1(domElement, rawProps);\n          break;\n\n        case 'select':\n          initWrapperState$1(domElement, rawProps);\n          props = getHostProps$2(domElement, rawProps);\n          trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening\n          // to onChange. Even if there is no listener.\n\n          ensureListeningTo(rootContainerElement, 'onChange');\n          break;\n\n        case 'textarea':\n          initWrapperState$2(domElement, rawProps);\n          props = getHostProps$3(domElement, rawProps);\n          trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening\n          // to onChange. Even if there is no listener.\n\n          ensureListeningTo(rootContainerElement, 'onChange');\n          break;\n\n        default:\n          props = rawProps;\n      }\n\n      assertValidProps(tag, props, getStack);\n      setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);\n\n      switch (tag) {\n        case 'input':\n          // TODO: Make sure we check if this is still unmounted or do any clean\n          // up necessary since we never stop tracking anymore.\n          track(domElement);\n          postMountWrapper(domElement, rawProps);\n          break;\n\n        case 'textarea':\n          // TODO: Make sure we check if this is still unmounted or do any clean\n          // up necessary since we never stop tracking anymore.\n          track(domElement);\n          postMountWrapper$3(domElement, rawProps);\n          break;\n\n        case 'option':\n          postMountWrapper$1(domElement, rawProps);\n          break;\n\n        case 'select':\n          postMountWrapper$2(domElement, rawProps);\n          break;\n\n        default:\n          if (typeof props.onClick === 'function') {\n            // TODO: This cast may not be sound for SVG, MathML or custom elements.\n            trapClickOnNonInteractiveElement(domElement);\n          }\n\n          break;\n      }\n    } // Calculate the diff between the two objects.\n\n\n    function diffProperties$1(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {\n      {\n        validatePropertiesInDevelopment(tag, nextRawProps);\n      }\n      var updatePayload = null;\n      var lastProps;\n      var nextProps;\n\n      switch (tag) {\n        case 'input':\n          lastProps = getHostProps(domElement, lastRawProps);\n          nextProps = getHostProps(domElement, nextRawProps);\n          updatePayload = [];\n          break;\n\n        case 'option':\n          lastProps = getHostProps$1(domElement, lastRawProps);\n          nextProps = getHostProps$1(domElement, nextRawProps);\n          updatePayload = [];\n          break;\n\n        case 'select':\n          lastProps = getHostProps$2(domElement, lastRawProps);\n          nextProps = getHostProps$2(domElement, nextRawProps);\n          updatePayload = [];\n          break;\n\n        case 'textarea':\n          lastProps = getHostProps$3(domElement, lastRawProps);\n          nextProps = getHostProps$3(domElement, nextRawProps);\n          updatePayload = [];\n          break;\n\n        default:\n          lastProps = lastRawProps;\n          nextProps = nextRawProps;\n\n          if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {\n            // TODO: This cast may not be sound for SVG, MathML or custom elements.\n            trapClickOnNonInteractiveElement(domElement);\n          }\n\n          break;\n      }\n\n      assertValidProps(tag, nextProps, getStack);\n      var propKey;\n      var styleName;\n      var styleUpdates = null;\n\n      for (propKey in lastProps) {\n        if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {\n          continue;\n        }\n\n        if (propKey === STYLE) {\n          var lastStyle = lastProps[propKey];\n\n          for (styleName in lastStyle) {\n            if (lastStyle.hasOwnProperty(styleName)) {\n              if (!styleUpdates) {\n                styleUpdates = {};\n              }\n\n              styleUpdates[styleName] = '';\n            }\n          }\n        } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {// Noop. This is handled by the clear text mechanism.\n        } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {// Noop\n        } else if (propKey === AUTOFOCUS) {// Noop. It doesn't work on updates anyway.\n        } else if (registrationNameModules.hasOwnProperty(propKey)) {\n          // This is a special case. If any listener updates we need to ensure\n          // that the \"current\" fiber pointer gets updated so we need a commit\n          // to update this element.\n          if (!updatePayload) {\n            updatePayload = [];\n          }\n        } else {\n          // For all other deleted properties we add it to the queue. We use\n          // the whitelist in the commit phase instead.\n          (updatePayload = updatePayload || []).push(propKey, null);\n        }\n      }\n\n      for (propKey in nextProps) {\n        var nextProp = nextProps[propKey];\n        var lastProp = lastProps != null ? lastProps[propKey] : undefined;\n\n        if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {\n          continue;\n        }\n\n        if (propKey === STYLE) {\n          {\n            if (nextProp) {\n              // Freeze the next style object so that we can assume it won't be\n              // mutated. We have already warned for this in the past.\n              Object.freeze(nextProp);\n            }\n          }\n\n          if (lastProp) {\n            // Unset styles on `lastProp` but not on `nextProp`.\n            for (styleName in lastProp) {\n              if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n                if (!styleUpdates) {\n                  styleUpdates = {};\n                }\n\n                styleUpdates[styleName] = '';\n              }\n            } // Update styles that changed since `lastProp`.\n\n\n            for (styleName in nextProp) {\n              if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\n                if (!styleUpdates) {\n                  styleUpdates = {};\n                }\n\n                styleUpdates[styleName] = nextProp[styleName];\n              }\n            }\n          } else {\n            // Relies on `updateStylesByID` not mutating `styleUpdates`.\n            if (!styleUpdates) {\n              if (!updatePayload) {\n                updatePayload = [];\n              }\n\n              updatePayload.push(propKey, styleUpdates);\n            }\n\n            styleUpdates = nextProp;\n          }\n        } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n          var nextHtml = nextProp ? nextProp[HTML] : undefined;\n          var lastHtml = lastProp ? lastProp[HTML] : undefined;\n\n          if (nextHtml != null) {\n            if (lastHtml !== nextHtml) {\n              (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);\n            }\n          } else {// TODO: It might be too late to clear this if we have children\n            // inserted already.\n          }\n        } else if (propKey === CHILDREN) {\n          if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {\n            (updatePayload = updatePayload || []).push(propKey, '' + nextProp);\n          }\n        } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {// Noop\n        } else if (registrationNameModules.hasOwnProperty(propKey)) {\n          if (nextProp != null) {\n            // We eagerly listen to this even though we haven't committed yet.\n            if (true && typeof nextProp !== 'function') {\n              warnForInvalidEventListener(propKey, nextProp);\n            }\n\n            ensureListeningTo(rootContainerElement, propKey);\n          }\n\n          if (!updatePayload && lastProp !== nextProp) {\n            // This is a special case. If any listener updates we need to ensure\n            // that the \"current\" props pointer gets updated so we need a commit\n            // to update this element.\n            updatePayload = [];\n          }\n        } else {\n          // For any other property we always add it to the queue and then we\n          // filter it out using the whitelist during the commit.\n          (updatePayload = updatePayload || []).push(propKey, nextProp);\n        }\n      }\n\n      if (styleUpdates) {\n        (updatePayload = updatePayload || []).push(STYLE, styleUpdates);\n      }\n\n      return updatePayload;\n    } // Apply the diff.\n\n\n    function updateProperties$1(domElement, updatePayload, tag, lastRawProps, nextRawProps) {\n      var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);\n      var isCustomComponentTag = isCustomComponent(tag, nextRawProps); // Apply the diff.\n\n      updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag); // TODO: Ensure that an update gets scheduled if any of the special props\n      // changed.\n\n      switch (tag) {\n        case 'input':\n          // Update the wrapper around inputs *after* updating props. This has to\n          // happen after `updateDOMProperties`. Otherwise HTML5 input validations\n          // raise warnings and prevent the new value from being assigned.\n          updateWrapper(domElement, nextRawProps); // We also check that we haven't missed a value update, such as a\n          // Radio group shifting the checked value to another named radio input.\n\n          updateValueIfChanged(domElement);\n          break;\n\n        case 'textarea':\n          updateWrapper$1(domElement, nextRawProps);\n          break;\n\n        case 'select':\n          // <select> value update needs to occur after <option> children\n          // reconciliation\n          postUpdateWrapper(domElement, nextRawProps);\n          break;\n      }\n    }\n\n    function diffHydratedProperties$1(domElement, tag, rawProps, parentNamespace, rootContainerElement) {\n      {\n        var suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;\n        var isCustomComponentTag = isCustomComponent(tag, rawProps);\n        validatePropertiesInDevelopment(tag, rawProps);\n\n        if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n          warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');\n          didWarnShadyDOM = true;\n        }\n      } // TODO: Make sure that we check isMounted before firing any of these events.\n\n      switch (tag) {\n        case 'iframe':\n        case 'object':\n          trapBubbledEvent('topLoad', 'load', domElement);\n          break;\n\n        case 'video':\n        case 'audio':\n          // Create listener for each media event\n          for (var event in mediaEvents) {\n            if (mediaEvents.hasOwnProperty(event)) {\n              trapBubbledEvent(event, mediaEvents[event], domElement);\n            }\n          }\n\n          break;\n\n        case 'source':\n          trapBubbledEvent('topError', 'error', domElement);\n          break;\n\n        case 'img':\n        case 'image':\n          trapBubbledEvent('topError', 'error', domElement);\n          trapBubbledEvent('topLoad', 'load', domElement);\n          break;\n\n        case 'form':\n          trapBubbledEvent('topReset', 'reset', domElement);\n          trapBubbledEvent('topSubmit', 'submit', domElement);\n          break;\n\n        case 'details':\n          trapBubbledEvent('topToggle', 'toggle', domElement);\n          break;\n\n        case 'input':\n          initWrapperState(domElement, rawProps);\n          trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening\n          // to onChange. Even if there is no listener.\n\n          ensureListeningTo(rootContainerElement, 'onChange');\n          break;\n\n        case 'option':\n          validateProps(domElement, rawProps);\n          break;\n\n        case 'select':\n          initWrapperState$1(domElement, rawProps);\n          trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening\n          // to onChange. Even if there is no listener.\n\n          ensureListeningTo(rootContainerElement, 'onChange');\n          break;\n\n        case 'textarea':\n          initWrapperState$2(domElement, rawProps);\n          trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening\n          // to onChange. Even if there is no listener.\n\n          ensureListeningTo(rootContainerElement, 'onChange');\n          break;\n      }\n\n      assertValidProps(tag, rawProps, getStack);\n      {\n        var extraAttributeNames = new Set();\n        var attributes = domElement.attributes;\n\n        for (var i = 0; i < attributes.length; i++) {\n          var name = attributes[i].name.toLowerCase();\n\n          switch (name) {\n            // Built-in SSR attribute is whitelisted\n            case 'data-reactroot':\n              break;\n            // Controlled attributes are not validated\n            // TODO: Only ignore them on controlled tags.\n\n            case 'value':\n              break;\n\n            case 'checked':\n              break;\n\n            case 'selected':\n              break;\n\n            default:\n              // Intentionally use the original name.\n              // See discussion in https://github.com/facebook/react/pull/10676.\n              extraAttributeNames.add(attributes[i].name);\n          }\n        }\n      }\n      var updatePayload = null;\n\n      for (var propKey in rawProps) {\n        if (!rawProps.hasOwnProperty(propKey)) {\n          continue;\n        }\n\n        var nextProp = rawProps[propKey];\n\n        if (propKey === CHILDREN) {\n          // For text content children we compare against textContent. This\n          // might match additional HTML that is hidden when we read it using\n          // textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n          // satisfies our requirement. Our requirement is not to produce perfect\n          // HTML and attributes. Ideally we should preserve structure but it's\n          // ok not to if the visible content is still enough to indicate what\n          // even listeners these nodes might be wired up to.\n          // TODO: Warn if there is more than a single textNode as a child.\n          // TODO: Should we use domElement.firstChild.nodeValue to compare?\n          if (typeof nextProp === 'string') {\n            if (domElement.textContent !== nextProp) {\n              if (true && !suppressHydrationWarning) {\n                warnForTextDifference(domElement.textContent, nextProp);\n              }\n\n              updatePayload = [CHILDREN, nextProp];\n            }\n          } else if (typeof nextProp === 'number') {\n            if (domElement.textContent !== '' + nextProp) {\n              if (true && !suppressHydrationWarning) {\n                warnForTextDifference(domElement.textContent, nextProp);\n              }\n\n              updatePayload = [CHILDREN, '' + nextProp];\n            }\n          }\n        } else if (registrationNameModules.hasOwnProperty(propKey)) {\n          if (nextProp != null) {\n            if (true && typeof nextProp !== 'function') {\n              warnForInvalidEventListener(propKey, nextProp);\n            }\n\n            ensureListeningTo(rootContainerElement, propKey);\n          }\n        } else {\n          // Validate that the properties correspond to their expected values.\n          var serverValue;\n          var propertyInfo;\n\n          if (suppressHydrationWarning) {// Don't bother comparing. We're ignoring all these warnings.\n          } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 || // Controlled attributes are not validated\n          // TODO: Only ignore them on controlled tags.\n          propKey === 'value' || propKey === 'checked' || propKey === 'selected') {// Noop\n          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n            var rawHtml = nextProp ? nextProp[HTML] || '' : '';\n            var serverHTML = domElement.innerHTML;\n            var expectedHTML = normalizeHTML(domElement, rawHtml);\n\n            if (expectedHTML !== serverHTML) {\n              warnForPropDifference(propKey, serverHTML, expectedHTML);\n            }\n          } else if (propKey === STYLE) {\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames['delete'](propKey);\n            var expectedStyle = createDangerousStringForStyles(nextProp);\n            serverValue = domElement.getAttribute('style');\n\n            if (expectedStyle !== serverValue) {\n              warnForPropDifference(propKey, serverValue, expectedStyle);\n            }\n          } else if (isCustomComponentTag) {\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames['delete'](propKey.toLowerCase());\n            serverValue = getValueForAttribute(domElement, propKey, nextProp);\n\n            if (nextProp !== serverValue) {\n              warnForPropDifference(propKey, serverValue, nextProp);\n            }\n          } else if (shouldSetAttribute(propKey, nextProp)) {\n            if (propertyInfo = getPropertyInfo(propKey)) {\n              // $FlowFixMe - Should be inferred as not undefined.\n              extraAttributeNames['delete'](propertyInfo.attributeName);\n              serverValue = getValueForProperty(domElement, propKey, nextProp);\n            } else {\n              var ownNamespace = parentNamespace;\n\n              if (ownNamespace === HTML_NAMESPACE) {\n                ownNamespace = getIntrinsicNamespace(tag);\n              }\n\n              if (ownNamespace === HTML_NAMESPACE) {\n                // $FlowFixMe - Should be inferred as not undefined.\n                extraAttributeNames['delete'](propKey.toLowerCase());\n              } else {\n                // $FlowFixMe - Should be inferred as not undefined.\n                extraAttributeNames['delete'](propKey);\n              }\n\n              serverValue = getValueForAttribute(domElement, propKey, nextProp);\n            }\n\n            if (nextProp !== serverValue) {\n              warnForPropDifference(propKey, serverValue, nextProp);\n            }\n          }\n        }\n      }\n\n      {\n        // $FlowFixMe - Should be inferred as not undefined.\n        if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {\n          // $FlowFixMe - Should be inferred as not undefined.\n          warnForExtraAttributes(extraAttributeNames);\n        }\n      }\n\n      switch (tag) {\n        case 'input':\n          // TODO: Make sure we check if this is still unmounted or do any clean\n          // up necessary since we never stop tracking anymore.\n          track(domElement);\n          postMountWrapper(domElement, rawProps);\n          break;\n\n        case 'textarea':\n          // TODO: Make sure we check if this is still unmounted or do any clean\n          // up necessary since we never stop tracking anymore.\n          track(domElement);\n          postMountWrapper$3(domElement, rawProps);\n          break;\n\n        case 'select':\n        case 'option':\n          // For input and textarea we current always set the value property at\n          // post mount to force it to diverge from attributes. However, for\n          // option and select we don't quite do the same thing and select\n          // is not resilient to the DOM state changing so we don't do that here.\n          // TODO: Consider not doing this for input and textarea.\n          break;\n\n        default:\n          if (typeof rawProps.onClick === 'function') {\n            // TODO: This cast may not be sound for SVG, MathML or custom elements.\n            trapClickOnNonInteractiveElement(domElement);\n          }\n\n          break;\n      }\n\n      return updatePayload;\n    }\n\n    function diffHydratedText$1(textNode, text) {\n      var isDifferent = textNode.nodeValue !== text;\n      return isDifferent;\n    }\n\n    function warnForUnmatchedText$1(textNode, text) {\n      {\n        warnForTextDifference(textNode.nodeValue, text);\n      }\n    }\n\n    function warnForDeletedHydratableElement$1(parentNode, child) {\n      {\n        if (didWarnInvalidHydration) {\n          return;\n        }\n\n        didWarnInvalidHydration = true;\n        warning(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());\n      }\n    }\n\n    function warnForDeletedHydratableText$1(parentNode, child) {\n      {\n        if (didWarnInvalidHydration) {\n          return;\n        }\n\n        didWarnInvalidHydration = true;\n        warning(false, 'Did not expect server HTML to contain the text node \"%s\" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());\n      }\n    }\n\n    function warnForInsertedHydratedElement$1(parentNode, tag, props) {\n      {\n        if (didWarnInvalidHydration) {\n          return;\n        }\n\n        didWarnInvalidHydration = true;\n        warning(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());\n      }\n    }\n\n    function warnForInsertedHydratedText$1(parentNode, text) {\n      {\n        if (text === '') {\n          // We expect to insert empty text nodes since they're not represented in\n          // the HTML.\n          // TODO: Remove this special case if we can just avoid inserting empty\n          // text nodes.\n          return;\n        }\n\n        if (didWarnInvalidHydration) {\n          return;\n        }\n\n        didWarnInvalidHydration = true;\n        warning(false, 'Expected server HTML to contain a matching text node for \"%s\" in <%s>.', text, parentNode.nodeName.toLowerCase());\n      }\n    }\n\n    function restoreControlledState(domElement, tag, props) {\n      switch (tag) {\n        case 'input':\n          restoreControlledState$1(domElement, props);\n          return;\n\n        case 'textarea':\n          restoreControlledState$3(domElement, props);\n          return;\n\n        case 'select':\n          restoreControlledState$2(domElement, props);\n          return;\n      }\n    }\n\n    var ReactDOMFiberComponent = Object.freeze({\n      createElement: createElement$1,\n      createTextNode: createTextNode$1,\n      setInitialProperties: setInitialProperties$1,\n      diffProperties: diffProperties$1,\n      updateProperties: updateProperties$1,\n      diffHydratedProperties: diffHydratedProperties$1,\n      diffHydratedText: diffHydratedText$1,\n      warnForUnmatchedText: warnForUnmatchedText$1,\n      warnForDeletedHydratableElement: warnForDeletedHydratableElement$1,\n      warnForDeletedHydratableText: warnForDeletedHydratableText$1,\n      warnForInsertedHydratedElement: warnForInsertedHydratedElement$1,\n      warnForInsertedHydratedText: warnForInsertedHydratedText$1,\n      restoreControlledState: restoreControlledState\n    }); // TODO: direct imports like some-package/src/* are bad. Fix me.\n\n    var getCurrentFiberStackAddendum$6 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n    var validateDOMNesting = emptyFunction$1;\n    {\n      // This validation code was written based on the HTML5 parsing spec:\n      // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n      //\n      // Note: this does not catch all invalid nesting, nor does it try to (as it's\n      // not clear what practical benefit doing so provides); instead, we warn only\n      // for cases where the parser will give a parse tree differing from what React\n      // intended. For example, <b><div></div></b> is invalid but we don't warn\n      // because it still parses correctly; we do warn for other cases like nested\n      // <p> tags where the beginning of the second element implicitly closes the\n      // first, causing a confusing mess.\n      // https://html.spec.whatwg.org/multipage/syntax.html#special\n      var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp']; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n\n      var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template', // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n      // TODO: Distinguish by namespace here -- for <title>, including it here\n      // errs on the side of fewer warnings\n      'foreignObject', 'desc', 'title']; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\n\n      var buttonScopeTags = inScopeTags.concat(['button']); // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\n\n      var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n      var emptyAncestorInfo = {\n        current: null,\n        formTag: null,\n        aTagInScope: null,\n        buttonTagInScope: null,\n        nobrTagInScope: null,\n        pTagInButtonScope: null,\n        listItemTagAutoclosing: null,\n        dlItemTagAutoclosing: null\n      };\n\n      var updatedAncestorInfo$1 = function (oldInfo, tag, instance) {\n        var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);\n\n        var info = {\n          tag: tag,\n          instance: instance\n        };\n\n        if (inScopeTags.indexOf(tag) !== -1) {\n          ancestorInfo.aTagInScope = null;\n          ancestorInfo.buttonTagInScope = null;\n          ancestorInfo.nobrTagInScope = null;\n        }\n\n        if (buttonScopeTags.indexOf(tag) !== -1) {\n          ancestorInfo.pTagInButtonScope = null;\n        } // See rules for 'li', 'dd', 'dt' start tags in\n        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n\n\n        if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {\n          ancestorInfo.listItemTagAutoclosing = null;\n          ancestorInfo.dlItemTagAutoclosing = null;\n        }\n\n        ancestorInfo.current = info;\n\n        if (tag === 'form') {\n          ancestorInfo.formTag = info;\n        }\n\n        if (tag === 'a') {\n          ancestorInfo.aTagInScope = info;\n        }\n\n        if (tag === 'button') {\n          ancestorInfo.buttonTagInScope = info;\n        }\n\n        if (tag === 'nobr') {\n          ancestorInfo.nobrTagInScope = info;\n        }\n\n        if (tag === 'p') {\n          ancestorInfo.pTagInButtonScope = info;\n        }\n\n        if (tag === 'li') {\n          ancestorInfo.listItemTagAutoclosing = info;\n        }\n\n        if (tag === 'dd' || tag === 'dt') {\n          ancestorInfo.dlItemTagAutoclosing = info;\n        }\n\n        return ancestorInfo;\n      };\n      /**\n       * Returns whether\n       */\n\n\n      var isTagValidWithParent = function (tag, parentTag) {\n        // First, let's check if we're in an unusual parsing mode...\n        switch (parentTag) {\n          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n          case 'select':\n            return tag === 'option' || tag === 'optgroup' || tag === '#text';\n\n          case 'optgroup':\n            return tag === 'option' || tag === '#text';\n          // Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n          // but\n\n          case 'option':\n            return tag === '#text';\n          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n          // No special behavior since these rules fall back to \"in body\" mode for\n          // all except special table nodes which cause bad parsing behavior anyway.\n          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n\n          case 'tr':\n            return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';\n          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n\n          case 'tbody':\n          case 'thead':\n          case 'tfoot':\n            return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n\n          case 'colgroup':\n            return tag === 'col' || tag === 'template';\n          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n\n          case 'table':\n            return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';\n          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n\n          case 'head':\n            return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';\n          // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n\n          case 'html':\n            return tag === 'head' || tag === 'body';\n\n          case '#document':\n            return tag === 'html';\n        } // Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n        // where the parsing rules cause implicit opens or closes to be added.\n        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n\n\n        switch (tag) {\n          case 'h1':\n          case 'h2':\n          case 'h3':\n          case 'h4':\n          case 'h5':\n          case 'h6':\n            return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';\n\n          case 'rp':\n          case 'rt':\n            return impliedEndTags.indexOf(parentTag) === -1;\n\n          case 'body':\n          case 'caption':\n          case 'col':\n          case 'colgroup':\n          case 'frame':\n          case 'head':\n          case 'html':\n          case 'tbody':\n          case 'td':\n          case 'tfoot':\n          case 'th':\n          case 'thead':\n          case 'tr':\n            // These tags are only valid with a few parents that have special child\n            // parsing rules -- if we're down here, then none of those matched and\n            // so we allow it only if we don't know what the parent is, as all other\n            // cases are invalid.\n            return parentTag == null;\n        }\n\n        return true;\n      };\n      /**\n       * Returns whether\n       */\n\n\n      var findInvalidAncestorForTag = function (tag, ancestorInfo) {\n        switch (tag) {\n          case 'address':\n          case 'article':\n          case 'aside':\n          case 'blockquote':\n          case 'center':\n          case 'details':\n          case 'dialog':\n          case 'dir':\n          case 'div':\n          case 'dl':\n          case 'fieldset':\n          case 'figcaption':\n          case 'figure':\n          case 'footer':\n          case 'header':\n          case 'hgroup':\n          case 'main':\n          case 'menu':\n          case 'nav':\n          case 'ol':\n          case 'p':\n          case 'section':\n          case 'summary':\n          case 'ul':\n          case 'pre':\n          case 'listing':\n          case 'table':\n          case 'hr':\n          case 'xmp':\n          case 'h1':\n          case 'h2':\n          case 'h3':\n          case 'h4':\n          case 'h5':\n          case 'h6':\n            return ancestorInfo.pTagInButtonScope;\n\n          case 'form':\n            return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\n\n          case 'li':\n            return ancestorInfo.listItemTagAutoclosing;\n\n          case 'dd':\n          case 'dt':\n            return ancestorInfo.dlItemTagAutoclosing;\n\n          case 'button':\n            return ancestorInfo.buttonTagInScope;\n\n          case 'a':\n            // Spec says something about storing a list of markers, but it sounds\n            // equivalent to this check.\n            return ancestorInfo.aTagInScope;\n\n          case 'nobr':\n            return ancestorInfo.nobrTagInScope;\n        }\n\n        return null;\n      };\n\n      var didWarn = {};\n\n      validateDOMNesting = function (childTag, childText, ancestorInfo) {\n        ancestorInfo = ancestorInfo || emptyAncestorInfo;\n        var parentInfo = ancestorInfo.current;\n        var parentTag = parentInfo && parentInfo.tag;\n\n        if (childText != null) {\n          warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null');\n          childTag = '#text';\n        }\n\n        var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\n        var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\n        var invalidParentOrAncestor = invalidParent || invalidAncestor;\n\n        if (!invalidParentOrAncestor) {\n          return;\n        }\n\n        var ancestorTag = invalidParentOrAncestor.tag;\n        var addendum = getCurrentFiberStackAddendum$6();\n        var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;\n\n        if (didWarn[warnKey]) {\n          return;\n        }\n\n        didWarn[warnKey] = true;\n        var tagDisplayName = childTag;\n        var whitespaceInfo = '';\n\n        if (childTag === '#text') {\n          if (/\\S/.test(childText)) {\n            tagDisplayName = 'Text nodes';\n          } else {\n            tagDisplayName = 'Whitespace text nodes';\n            whitespaceInfo = \" Make sure you don't have any extra whitespace between tags on \" + 'each line of your source code.';\n          }\n        } else {\n          tagDisplayName = '<' + childTag + '>';\n        }\n\n        if (invalidParent) {\n          var info = '';\n\n          if (ancestorTag === 'table' && childTag === 'tr') {\n            info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';\n          }\n\n          warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);\n        } else {\n          warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);\n        }\n      }; // TODO: turn this into a named export\n\n\n      validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1; // For testing\n\n      validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {\n        ancestorInfo = ancestorInfo || emptyAncestorInfo;\n        var parentInfo = ancestorInfo.current;\n        var parentTag = parentInfo && parentInfo.tag;\n        return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);\n      };\n    }\n    var validateDOMNesting$1 = validateDOMNesting; // TODO: direct imports like some-package/src/* are bad. Fix me.\n\n    var createElement = createElement$1;\n    var createTextNode = createTextNode$1;\n    var setInitialProperties = setInitialProperties$1;\n    var diffProperties = diffProperties$1;\n    var updateProperties = updateProperties$1;\n    var diffHydratedProperties = diffHydratedProperties$1;\n    var diffHydratedText = diffHydratedText$1;\n    var warnForUnmatchedText = warnForUnmatchedText$1;\n    var warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;\n    var warnForDeletedHydratableText = warnForDeletedHydratableText$1;\n    var warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;\n    var warnForInsertedHydratedText = warnForInsertedHydratedText$1;\n    var updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;\n    var precacheFiberNode = precacheFiberNode$1;\n    var updateFiberProps = updateFiberProps$1;\n    {\n      var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n\n      if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {\n        warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');\n      }\n    }\n    injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);\n    var eventsEnabled = null;\n    var selectionInformation = null;\n    /**\n     * True if the supplied DOM node is a valid node element.\n     *\n     * @param {?DOMElement} node The candidate DOM node.\n     * @return {boolean} True if the DOM is a valid DOM node.\n     * @internal\n     */\n\n    function isValidContainer(node) {\n      return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));\n    }\n\n    function getReactRootElementInContainer(container) {\n      if (!container) {\n        return null;\n      }\n\n      if (container.nodeType === DOCUMENT_NODE) {\n        return container.documentElement;\n      } else {\n        return container.firstChild;\n      }\n    }\n\n    function shouldHydrateDueToLegacyHeuristic(container) {\n      var rootElement = getReactRootElementInContainer(container);\n      return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));\n    }\n\n    function shouldAutoFocusHostComponent(type, props) {\n      switch (type) {\n        case 'button':\n        case 'input':\n        case 'select':\n        case 'textarea':\n          return !!props.autoFocus;\n      }\n\n      return false;\n    }\n\n    var DOMRenderer = reactReconciler({\n      getRootHostContext: function (rootContainerInstance) {\n        var type = void 0;\n        var namespace = void 0;\n        var nodeType = rootContainerInstance.nodeType;\n\n        switch (nodeType) {\n          case DOCUMENT_NODE:\n          case DOCUMENT_FRAGMENT_NODE:\n            {\n              type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n              var root = rootContainerInstance.documentElement;\n              namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n              break;\n            }\n\n          default:\n            {\n              var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n              var ownNamespace = container.namespaceURI || null;\n              type = container.tagName;\n              namespace = getChildNamespace(ownNamespace, type);\n              break;\n            }\n        }\n\n        {\n          var validatedTag = type.toLowerCase();\n\n          var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);\n\n          return {\n            namespace: namespace,\n            ancestorInfo: _ancestorInfo\n          };\n        }\n        return namespace;\n      },\n      getChildHostContext: function (parentHostContext, type) {\n        {\n          var parentHostContextDev = parentHostContext;\n\n          var _namespace = getChildNamespace(parentHostContextDev.namespace, type);\n\n          var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);\n\n          return {\n            namespace: _namespace,\n            ancestorInfo: _ancestorInfo2\n          };\n        }\n        var parentNamespace = parentHostContext;\n        return getChildNamespace(parentNamespace, type);\n      },\n      getPublicInstance: function (instance) {\n        return instance;\n      },\n      prepareForCommit: function () {\n        eventsEnabled = isEnabled();\n        selectionInformation = getSelectionInformation();\n        setEnabled(false);\n      },\n      resetAfterCommit: function () {\n        restoreSelection(selectionInformation);\n        selectionInformation = null;\n        setEnabled(eventsEnabled);\n        eventsEnabled = null;\n      },\n      createInstance: function (type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n        var parentNamespace = void 0;\n        {\n          // TODO: take namespace into account when validating.\n          var hostContextDev = hostContext;\n          validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);\n\n          if (typeof props.children === 'string' || typeof props.children === 'number') {\n            var string = '' + props.children;\n            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n            validateDOMNesting$1(null, string, ownAncestorInfo);\n          }\n\n          parentNamespace = hostContextDev.namespace;\n        }\n        var domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n        precacheFiberNode(internalInstanceHandle, domElement);\n        updateFiberProps(domElement, props);\n        return domElement;\n      },\n      appendInitialChild: function (parentInstance, child) {\n        parentInstance.appendChild(child);\n      },\n      finalizeInitialChildren: function (domElement, type, props, rootContainerInstance) {\n        setInitialProperties(domElement, type, props, rootContainerInstance);\n        return shouldAutoFocusHostComponent(type, props);\n      },\n      prepareUpdate: function (domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n        {\n          var hostContextDev = hostContext;\n\n          if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\n            var string = '' + newProps.children;\n            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n            validateDOMNesting$1(null, string, ownAncestorInfo);\n          }\n        }\n        return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);\n      },\n      shouldSetTextContent: function (type, props) {\n        return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';\n      },\n      shouldDeprioritizeSubtree: function (type, props) {\n        return !!props.hidden;\n      },\n      createTextInstance: function (text, rootContainerInstance, hostContext, internalInstanceHandle) {\n        {\n          var hostContextDev = hostContext;\n          validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);\n        }\n        var textNode = createTextNode(text, rootContainerInstance);\n        precacheFiberNode(internalInstanceHandle, textNode);\n        return textNode;\n      },\n      now: now,\n      mutation: {\n        commitMount: function (domElement, type, newProps, internalInstanceHandle) {\n          domElement.focus();\n        },\n        commitUpdate: function (domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n          // Update the props handle so that we know which props are the ones with\n          // with current event handlers.\n          updateFiberProps(domElement, newProps); // Apply the diff to the DOM node.\n\n          updateProperties(domElement, updatePayload, type, oldProps, newProps);\n        },\n        resetTextContent: function (domElement) {\n          domElement.textContent = '';\n        },\n        commitTextUpdate: function (textInstance, oldText, newText) {\n          textInstance.nodeValue = newText;\n        },\n        appendChild: function (parentInstance, child) {\n          parentInstance.appendChild(child);\n        },\n        appendChildToContainer: function (container, child) {\n          if (container.nodeType === COMMENT_NODE) {\n            container.parentNode.insertBefore(child, container);\n          } else {\n            container.appendChild(child);\n          }\n        },\n        insertBefore: function (parentInstance, child, beforeChild) {\n          parentInstance.insertBefore(child, beforeChild);\n        },\n        insertInContainerBefore: function (container, child, beforeChild) {\n          if (container.nodeType === COMMENT_NODE) {\n            container.parentNode.insertBefore(child, beforeChild);\n          } else {\n            container.insertBefore(child, beforeChild);\n          }\n        },\n        removeChild: function (parentInstance, child) {\n          parentInstance.removeChild(child);\n        },\n        removeChildFromContainer: function (container, child) {\n          if (container.nodeType === COMMENT_NODE) {\n            container.parentNode.removeChild(child);\n          } else {\n            container.removeChild(child);\n          }\n        }\n      },\n      hydration: {\n        canHydrateInstance: function (instance, type, props) {\n          if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n            return null;\n          } // This has now been refined to an element node.\n\n\n          return instance;\n        },\n        canHydrateTextInstance: function (instance, text) {\n          if (text === '' || instance.nodeType !== TEXT_NODE) {\n            // Empty strings are not parsed by HTML so there won't be a correct match here.\n            return null;\n          } // This has now been refined to a text node.\n\n\n          return instance;\n        },\n        getNextHydratableSibling: function (instance) {\n          var node = instance.nextSibling; // Skip non-hydratable nodes.\n\n          while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {\n            node = node.nextSibling;\n          }\n\n          return node;\n        },\n        getFirstHydratableChild: function (parentInstance) {\n          var next = parentInstance.firstChild; // Skip non-hydratable nodes.\n\n          while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {\n            next = next.nextSibling;\n          }\n\n          return next;\n        },\n        hydrateInstance: function (instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n          precacheFiberNode(internalInstanceHandle, instance); // TODO: Possibly defer this until the commit phase where all the events\n          // get attached.\n\n          updateFiberProps(instance, props);\n          var parentNamespace = void 0;\n          {\n            var hostContextDev = hostContext;\n            parentNamespace = hostContextDev.namespace;\n          }\n          return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);\n        },\n        hydrateTextInstance: function (textInstance, text, internalInstanceHandle) {\n          precacheFiberNode(internalInstanceHandle, textInstance);\n          return diffHydratedText(textInstance, text);\n        },\n        didNotMatchHydratedContainerTextInstance: function (parentContainer, textInstance, text) {\n          {\n            warnForUnmatchedText(textInstance, text);\n          }\n        },\n        didNotMatchHydratedTextInstance: function (parentType, parentProps, parentInstance, textInstance, text) {\n          if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n            warnForUnmatchedText(textInstance, text);\n          }\n        },\n        didNotHydrateContainerInstance: function (parentContainer, instance) {\n          {\n            if (instance.nodeType === 1) {\n              warnForDeletedHydratableElement(parentContainer, instance);\n            } else {\n              warnForDeletedHydratableText(parentContainer, instance);\n            }\n          }\n        },\n        didNotHydrateInstance: function (parentType, parentProps, parentInstance, instance) {\n          if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n            if (instance.nodeType === 1) {\n              warnForDeletedHydratableElement(parentInstance, instance);\n            } else {\n              warnForDeletedHydratableText(parentInstance, instance);\n            }\n          }\n        },\n        didNotFindHydratableContainerInstance: function (parentContainer, type, props) {\n          {\n            warnForInsertedHydratedElement(parentContainer, type, props);\n          }\n        },\n        didNotFindHydratableContainerTextInstance: function (parentContainer, text) {\n          {\n            warnForInsertedHydratedText(parentContainer, text);\n          }\n        },\n        didNotFindHydratableInstance: function (parentType, parentProps, parentInstance, type, props) {\n          if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n            warnForInsertedHydratedElement(parentInstance, type, props);\n          }\n        },\n        didNotFindHydratableTextInstance: function (parentType, parentProps, parentInstance, text) {\n          if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n            warnForInsertedHydratedText(parentInstance, text);\n          }\n        }\n      },\n      scheduleDeferredCallback: rIC,\n      useSyncScheduling: !enableAsyncSchedulingByDefaultInReactDOM\n    });\n    injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);\n    var warnedAboutHydrateAPI = false;\n\n    function renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n      !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n      {\n        if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n          var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);\n\n          if (hostInstance) {\n            warning(hostInstance.parentNode === container, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');\n          }\n        }\n\n        var isRootRenderedBySomeReact = !!container._reactRootContainer;\n        var rootEl = getReactRootElementInContainer(container);\n        var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));\n        warning(!hasNonRootReactChild || isRootRenderedBySomeReact, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');\n        warning(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');\n      }\n      var root = container._reactRootContainer;\n\n      if (!root) {\n        var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content.\n\n        if (!shouldHydrate) {\n          var warned = false;\n          var rootSibling = void 0;\n\n          while (rootSibling = container.lastChild) {\n            {\n              if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {\n                warned = true;\n                warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');\n              }\n            }\n            container.removeChild(rootSibling);\n          }\n        }\n\n        {\n          if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n            warnedAboutHydrateAPI = true;\n            lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');\n          }\n        }\n        var newRoot = DOMRenderer.createContainer(container, shouldHydrate);\n        root = container._reactRootContainer = newRoot; // Initial mount should not be batched.\n\n        DOMRenderer.unbatchedUpdates(function () {\n          DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);\n        });\n      } else {\n        DOMRenderer.updateContainer(children, root, parentComponent, callback);\n      }\n\n      return DOMRenderer.getPublicRootInstance(root);\n    }\n\n    function createPortal(children, container) {\n      var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0; // TODO: pass ReactDOM portal implementation as third argument\n\n      return createPortal$1(children, container, null, key);\n    }\n\n    function ReactRoot(container, hydrate) {\n      var root = DOMRenderer.createContainer(container, hydrate);\n      this._reactRootContainer = root;\n    }\n\n    ReactRoot.prototype.render = function (children, callback) {\n      var root = this._reactRootContainer;\n      DOMRenderer.updateContainer(children, root, null, callback);\n    };\n\n    ReactRoot.prototype.unmount = function (callback) {\n      var root = this._reactRootContainer;\n      DOMRenderer.updateContainer(null, root, null, callback);\n    };\n\n    var ReactDOM = {\n      createPortal: createPortal,\n      findDOMNode: function (componentOrElement) {\n        {\n          var owner = ReactCurrentOwner.current;\n\n          if (owner !== null) {\n            var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n            warning(warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner) || 'A component');\n            owner.stateNode._warnedAboutRefsInRender = true;\n          }\n        }\n\n        if (componentOrElement == null) {\n          return null;\n        }\n\n        if (componentOrElement.nodeType === ELEMENT_NODE) {\n          return componentOrElement;\n        }\n\n        var inst = get(componentOrElement);\n\n        if (inst) {\n          return DOMRenderer.findHostInstance(inst);\n        }\n\n        if (typeof componentOrElement.render === 'function') {\n          invariant(false, 'Unable to find node on an unmounted component.');\n        } else {\n          invariant(false, 'Element appears to be neither ReactComponent nor DOMNode. Keys: %s', Object.keys(componentOrElement));\n        }\n      },\n      hydrate: function (element, container, callback) {\n        // TODO: throw or warn if we couldn't hydrate?\n        return renderSubtreeIntoContainer(null, element, container, true, callback);\n      },\n      render: function (element, container, callback) {\n        return renderSubtreeIntoContainer(null, element, container, false, callback);\n      },\n      unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {\n        !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;\n        return renderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n      },\n      unmountComponentAtNode: function (container) {\n        !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;\n\n        if (container._reactRootContainer) {\n          {\n            var rootEl = getReactRootElementInContainer(container);\n            var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);\n            warning(!renderedByDifferentReact, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by another copy of React.');\n          } // Unmount should not be batched.\n\n          DOMRenderer.unbatchedUpdates(function () {\n            renderSubtreeIntoContainer(null, null, container, false, function () {\n              container._reactRootContainer = null;\n            });\n          }); // If you call unmountComponentAtNode twice in quick succession, you'll\n          // get `true` twice. That's probably fine?\n\n          return true;\n        } else {\n          {\n            var _rootEl = getReactRootElementInContainer(container);\n\n            var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl)); // Check if the container itself is a React root node.\n\n            var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;\n            warning(!hasNonRootReactChild, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');\n          }\n          return false;\n        }\n      },\n      // Temporary alias since we already shipped React 16 RC with it.\n      // TODO: remove in React 17.\n      unstable_createPortal: createPortal,\n      unstable_batchedUpdates: batchedUpdates,\n      unstable_deferredUpdates: DOMRenderer.deferredUpdates,\n      flushSync: DOMRenderer.flushSync,\n      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n        // For TapEventPlugin which is popular in open source\n        EventPluginHub: EventPluginHub,\n        // Used by test-utils\n        EventPluginRegistry: EventPluginRegistry,\n        EventPropagators: EventPropagators,\n        ReactControlledComponent: ReactControlledComponent,\n        ReactDOMComponentTree: ReactDOMComponentTree,\n        ReactDOMEventListener: ReactDOMEventListener\n      }\n    };\n\n    if (enableCreateRoot) {\n      ReactDOM.createRoot = function createRoot(container, options) {\n        var hydrate = options != null && options.hydrate === true;\n        return new ReactRoot(container, hydrate);\n      };\n    }\n\n    var foundDevTools = DOMRenderer.injectIntoDevTools({\n      findFiberByHostInstance: getClosestInstanceFromNode,\n      bundleType: 1,\n      version: ReactVersion,\n      rendererPackageName: 'react-dom'\n    });\n    {\n      if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {\n        // If we're in Chrome or Firefox, provide a download link if not installed.\n        if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {\n          var protocol = window.location.protocol; // Don't warn in exotic cases like chrome-extension://.\n\n          if (/^(https?|file):$/.test(protocol)) {\n            console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');\n          }\n        }\n      }\n    }\n    var ReactDOM$2 = Object.freeze({\n      default: ReactDOM\n    });\n    var ReactDOM$3 = ReactDOM$2 && ReactDOM || ReactDOM$2; // TODO: decide on the top-level export form.\n    // This is hacky but makes it work with both Rollup and Jest.\n\n    var reactDom = ReactDOM$3['default'] ? ReactDOM$3['default'] : ReactDOM$3;\n    module.exports = reactDom;\n  })();\n}","map":{"version":3,"sources":["/home/indrajitauddy/Desktop/registration-react/node_modules/react-dom/cjs/react-dom.development.js"],"names":["process","env","NODE_ENV","React","require","invariant","warning","ExecutionEnvironment","_assign","emptyFunction$1","EventListener","getActiveElement","shallowEqual","containsNode","focusNode","emptyObject","checkPropTypes","hyphenateStyleName","camelizeStyleName","RESERVED_PROPS","children","dangerouslySetInnerHTML","defaultValue","defaultChecked","innerHTML","suppressContentEditableWarning","suppressHydrationWarning","style","checkMask","value","bitmask","DOMPropertyInjection","MUST_USE_PROPERTY","HAS_BOOLEAN_VALUE","HAS_NUMERIC_VALUE","HAS_POSITIVE_NUMERIC_VALUE","HAS_OVERLOADED_BOOLEAN_VALUE","HAS_STRING_BOOLEAN_VALUE","injectDOMPropertyConfig","domPropertyConfig","Injection","Properties","DOMAttributeNamespaces","DOMAttributeNames","DOMMutationMethods","propName","properties","hasOwnProperty","lowerCased","toLowerCase","propConfig","propertyInfo","attributeName","attributeNamespace","propertyName","mutationMethod","mustUseProperty","hasBooleanValue","hasNumericValue","hasPositiveNumericValue","hasOverloadedBooleanValue","hasStringBooleanValue","ATTRIBUTE_NAME_START_CHAR","ATTRIBUTE_NAME_CHAR","ROOT_ATTRIBUTE_NAME","shouldSetAttribute","name","isReservedProp","length","shouldAttributeAcceptBooleanValue","getPropertyInfo","prefix","slice","injection","HTMLDOMPropertyConfig","allowFullScreen","async","autoFocus","autoPlay","capture","checked","cols","contentEditable","controls","defer","disabled","download","draggable","formNoValidate","hidden","loop","multiple","muted","noValidate","open","playsInline","readOnly","required","reversed","rows","rowSpan","scoped","seamless","selected","size","start","span","spellCheck","tabIndex","itemScope","acceptCharset","className","htmlFor","httpEquiv","node","removeAttribute","type","hasAttribute","setAttribute","validity","badInput","ownerDocument","activeElement","HAS_STRING_BOOLEAN_VALUE$1","NS","xlink","xml","ATTRS","SVGDOMPropertyConfig","autoReverse","externalResourcesRequired","preserveAlpha","xlinkActuate","xlinkArcrole","xlinkHref","xlinkRole","xlinkShow","xlinkTitle","xlinkType","xmlBase","xmlLang","xmlSpace","CAMELIZE","capitalize","token","toUpperCase","forEach","original","reactName","replace","ReactErrorUtils","_caughtError","_hasCaughtError","_rethrowError","_hasRethrowError","injectErrorUtils","injectedErrorUtils","invokeGuardedCallback","func","context","a","b","c","d","e","f","apply","arguments","invokeGuardedCallbackAndCatchFirstError","hasCaughtError","error","clearCaughtError","rethrowCaughtError","funcArgs","Array","prototype","call","window","dispatchEvent","document","createEvent","fakeNode","createElement","invokeGuardedCallbackDev","didError","callCallback","removeEventListener","evtType","didSetError","isCrossOriginError","onError","event","colno","lineno","addEventListener","evt","initEvent","Error","eventPluginOrder","namesToPlugins","recomputePluginOrdering","pluginName","pluginModule","pluginIndex","indexOf","plugins","extractEvents","publishedEvents","eventTypes","eventName","publishEventForPlugin","dispatchConfig","eventNameDispatchConfigs","phasedRegistrationNames","phaseName","phasedRegistrationName","publishRegistrationName","registrationName","registrationNameModules","registrationNameDependencies","dependencies","lowerCasedName","possibleRegistrationNames","ondblclick","injectEventPluginOrder","injectedEventPluginOrder","injectEventPluginsByName","injectedNamesToPlugins","isOrderingDirty","EventPluginRegistry","Object","freeze","getFiberCurrentPropsFromNode","getInstanceFromNode","getNodeFromInstance","injection$2","injectComponentTree","Injected","validateEventDispatches","dispatchListeners","_dispatchListeners","dispatchInstances","_dispatchInstances","listenersIsArr","isArray","listenersLen","instancesIsArr","instancesLen","executeDispatch","simulated","listener","inst","currentTarget","undefined","executeDispatchesInOrder","i","isPropagationStopped","accumulateInto","current","next","push","concat","forEachAccumulated","arr","cb","scope","eventQueue","executeDispatchesAndRelease","isPersistent","constructor","release","executeDispatchesAndReleaseSimulated","executeDispatchesAndReleaseTopLevel","isInteractive","tag","shouldPreventMouseEvent","props","injection$1","getListener","stateNode","topLevelType","targetInst","nativeEvent","nativeEventTarget","events","possiblePlugin","extractedEvents","enqueueEvents","processEventQueue","processingEventQueue","EventPluginHub","IndeterminateComponent","FunctionalComponent","ClassComponent","HostRoot","HostPortal","HostComponent","HostText","CallComponent","CallHandlerPhase","ReturnComponent","Fragment","randomKey","Math","random","toString","internalInstanceKey","internalEventHandlersKey","precacheFiberNode$1","hostInst","getClosestInstanceFromNode","parents","parentNode","closest","pop","getInstanceFromNode$1","getNodeFromInstance$1","getFiberCurrentPropsFromNode$1","updateFiberProps$1","ReactDOMComponentTree","precacheFiberNode","updateFiberProps","getParent","getLowestCommonAncestor","instA","instB","depthA","tempA","depthB","tempB","depth","alternate","getParentInstance","traverseTwoPhase","fn","arg","path","traverseEnterLeave","from","to","argFrom","argTo","common","pathFrom","pathTo","_alternate","_i","listenerAtPhase","propagationPhase","accumulateDirectionalDispatches","phase","accumulateTwoPhaseDispatchesSingle","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","parentInst","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","accumulateTwoPhaseDispatchesSkipTarget","accumulateEnterLeaveDispatches","leave","enter","accumulateDirectDispatches","EventPropagators","contentKey","getTextContentAccessor","canUseDOM","documentElement","compositionState","_root","_startText","_fallbackText","initialize","getText","reset","getData","startValue","startLength","end","endValue","endLength","minEnd","sliceTail","didWarnForAddedNewProperty","isProxySupported","Proxy","EVENT_POOL_SIZE","shouldBeReleasedProperties","EventInterface","target","thatReturnsNull","eventPhase","bubbles","cancelable","timeStamp","Date","now","defaultPrevented","isTrusted","SyntheticEvent","preventDefault","stopPropagation","Interface","normalize","returnValue","isDefaultPrevented","thatReturnsTrue","thatReturnsFalse","cancelBubble","persist","destructor","defineProperty","getPooledWarningPropertyDefinition","augmentClass","Class","Super","E","addEventPoolingTo","construct","args","create","that","set","prop","getVal","isFunction","configurable","get","val","action","warn","result","warningCondition","getPooledEvent","nativeInst","EventConstructor","eventPool","instance","releasePooledEvent","getPooled","SyntheticEvent$1","CompositionEventInterface","data","SyntheticCompositionEvent","dispatchMarker","InputEventInterface","SyntheticInputEvent","END_KEYCODES","START_KEYCODE","canUseCompositionEvent","documentMode","canUseTextInputEvent","isPresto","useFallbackCompositionData","opera","version","parseInt","SPACEBAR_CODE","SPACEBAR_CHAR","String","fromCharCode","beforeInput","bubbled","captured","compositionEnd","compositionStart","compositionUpdate","hasSpaceKeypress","isKeypressCommand","ctrlKey","altKey","metaKey","getCompositionEventType","isFallbackCompositionStart","keyCode","isFallbackCompositionEnd","getDataFromCustomEvent","detail","isComposing","extractCompositionEvent","eventType","fallbackData","customData","getNativeBeforeInputChars","which","chars","getFallbackBeforeInputChars","char","extractBeforeInputEvent","BeforeInputEventPlugin","fiberHostComponent","ReactControlledComponentInjection","injectFiberControlledHostComponent","hostComponentImpl","restoreTarget","restoreQueue","restoreStateOfTarget","internalInstance","restoreControlledState","injection$3","enqueueStateRestore","restoreStateIfNeeded","queuedTargets","ReactControlledComponent","fiberBatchedUpdates","bookkeeping","isNestingBatched","batchedUpdates","ReactGenericBatchingInjection","injectFiberBatchedUpdates","_batchedUpdates","injection$4","supportedInputTypes","color","date","datetime","email","month","number","password","range","search","tel","text","time","url","week","isTextInputElement","elem","nodeName","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","getEventTarget","srcElement","correspondingUseElement","nodeType","useHasFeature","implementation","hasFeature","isEventSupported","eventNameSuffix","isSupported","element","isCheckable","getTracker","_valueTracker","detachTracker","getValueFromNode","trackValueOnNode","valueField","descriptor","getOwnPropertyDescriptor","currentValue","enumerable","tracker","getValue","setValue","stopTracking","track","updateValueIfChanged","lastValue","nextValue","eventTypes$1","change","createAndAccumulateChangeEvent","activeElementInst","shouldUseChangeEvent","manualDispatchChangeEvent","runEventInBatch","getInstIfValueChanged","targetNode","getTargetInstForChangeEvent","isInputEventSupported","startWatchingForValueChange","attachEvent","handlePropertyChange","stopWatchingForValueChange","detachEvent","handleEventsForInputEventPolyfill","getTargetInstForInputEventPolyfill","shouldUseClickEvent","getTargetInstForClickEvent","getTargetInstForInputOrChangeEvent","handleControlledInputBlur","state","_wrapperState","controlled","getAttribute","ChangeEventPlugin","_isInputEventSupported","getTargetInstFunc","handleEventFunc","DOMEventPluginOrder","UIEventInterface","view","SyntheticUIEvent","modifierKeyToProp","Alt","Control","Meta","Shift","modifierStateGetter","keyArg","syntheticEvent","getModifierState","keyProp","getEventModifierState","MouseEventInterface","screenX","screenY","clientX","clientY","pageX","pageY","shiftKey","button","buttons","relatedTarget","fromElement","toElement","SyntheticMouseEvent","eventTypes$2","mouseEnter","mouseLeave","EnterLeaveEventPlugin","win","doc","defaultView","parentWindow","related","fromNode","toNode","key","_reactInternalFiber","has","ReactInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentOwner","ReactDebugCurrentFrame","getComponentName","fiber","displayName","NoEffect","PerformedWork","Placement","Update","PlacementAndUpdate","Deletion","ContentReset","Callback","Err","Ref","MOUNTING","MOUNTED","UNMOUNTED","isFiberMountedImpl","effectTag","isFiberMounted","isMounted","component","owner","ownerFiber","_warnedAboutRefsInRender","assertIsMounted","findCurrentFiberUsingSlowPath","parentA","parentB","child","sibling","didFindChild","_child","findCurrentHostFiber","parent","currentParent","findCurrentHostFiberWithNoPortals","CALLBACK_BOOKKEEPING_POOL_SIZE","callbackBookkeepingPool","findRootContainerNode","containerInfo","getTopLevelCallbackBookKeeping","ancestors","releaseTopLevelCallbackBookKeeping","handleTopLevelImpl","bookKeeping","ancestor","root","_handleTopLevel","_enabled","setHandleTopLevel","handleTopLevel","setEnabled","enabled","isEnabled","trapBubbledEvent","handlerBaseName","listen","bind","trapCapturedEvent","ReactDOMEventListener","makePrefixMap","styleProp","prefixes","vendorPrefixes","animationend","animationiteration","animationstart","transitionend","prefixedEventNames","animation","transition","getVendorPrefixedEventName","prefixMap","topLevelTypes$1","topAbort","topAnimationEnd","topAnimationIteration","topAnimationStart","topBlur","topCancel","topCanPlay","topCanPlayThrough","topChange","topClick","topClose","topCompositionEnd","topCompositionStart","topCompositionUpdate","topContextMenu","topCopy","topCut","topDoubleClick","topDrag","topDragEnd","topDragEnter","topDragExit","topDragLeave","topDragOver","topDragStart","topDrop","topDurationChange","topEmptied","topEncrypted","topEnded","topError","topFocus","topInput","topKeyDown","topKeyPress","topKeyUp","topLoadedData","topLoad","topLoadedMetadata","topLoadStart","topMouseDown","topMouseMove","topMouseOut","topMouseOver","topMouseUp","topPaste","topPause","topPlay","topPlaying","topProgress","topRateChange","topScroll","topSeeked","topSeeking","topSelectionChange","topStalled","topSuspend","topTextInput","topTimeUpdate","topToggle","topTouchCancel","topTouchEnd","topTouchMove","topTouchStart","topTransitionEnd","topVolumeChange","topWaiting","topWheel","BrowserEventConstants","topLevelTypes","runEventQueueInBatch","alreadyListeningTo","reactTopListenersCounter","topListenersIDKey","getListeningForDocument","mountAt","listenTo","contentDocumentHandle","isListening","dependency","isListeningToAllDependencies","getLeafNode","firstChild","getSiblingNode","nextSibling","getNodeForCharacterOffset","offset","nodeStart","nodeEnd","textContent","getOffsets","outerNode","selection","getSelection","rangeCount","anchorNode","anchorOffset","focusNode$$1","focusOffset","getModernOffsetsFromPoints","indexWithinAnchor","indexWithinFocus","outer","nodeValue","setOffsets","offsets","min","extend","temp","startMarker","endMarker","createRange","setStart","removeAllRanges","addRange","setEnd","isInDocument","hasSelectionCapabilities","getSelectionInformation","focusedElem","selectionRange","getSelection$1","restoreSelection","priorSelectionInformation","curFocusedElem","priorFocusedElem","priorSelectionRange","setSelection","left","scrollLeft","top","scrollTop","info","input","selectionStart","selectionEnd","skipSelectionChangeEvent","eventTypes$3","select","activeElement$1","activeElementInst$1","lastSelection","mouseDown","constructSelectEvent","currentSelection","SelectEventPlugin","AnimationEventInterface","animationName","elapsedTime","pseudoElement","SyntheticAnimationEvent","ClipboardEventInterface","clipboardData","SyntheticClipboardEvent","FocusEventInterface","SyntheticFocusEvent","getEventCharCode","charCode","normalizeKey","Esc","Spacebar","Left","Up","Right","Down","Del","Win","Menu","Apps","Scroll","MozPrintableKey","translateToKey","getEventKey","KeyboardEventInterface","location","repeat","locale","SyntheticKeyboardEvent","DragEventInterface","dataTransfer","SyntheticDragEvent","TouchEventInterface","touches","targetTouches","changedTouches","SyntheticTouchEvent","TransitionEventInterface","SyntheticTransitionEvent","WheelEventInterface","deltaX","wheelDeltaX","deltaY","wheelDeltaY","wheelDelta","deltaZ","deltaMode","SyntheticWheelEvent","eventTypes$4","topLevelEventsToDispatchConfig","capitalizedEvent","onEvent","topEvent","knownHTMLTopLevelTypes","SimpleEventPlugin","enableAsyncSubtreeAPI","enableAsyncSchedulingByDefaultInReactDOM","enableReactFragment","enableCreateRoot","enableUserTimingAPI","enableMutatingReconciler","enableNoopReconciler","enablePersistentReconciler","valueStack","fiberStack","index","createCursor","cursor","reset$1","describeComponentFrame","source","ownerName","fileName","lineNumber","describeFiber","_debugOwner","_debugSource","getStackAddendumByWorkInProgressFiber","workInProgress","getCurrentFiberOwnerName","ReactDebugCurrentFiber","getCurrentFiberStackAddendum","resetCurrentFiber","getCurrentStack","setCurrentFiber","setCurrentPhase","reactEmoji","warningEmoji","supportsUserTiming","performance","mark","clearMarks","measure","clearMeasures","currentFiber","currentPhase","currentPhaseFiber","isCommitting","hasScheduledUpdateInCurrentCommit","hasScheduledUpdateInCurrentPhase","commitCountInCurrentWorkLoop","effectCountInCurrentCommit","isWaitingForCallback","labelsInCurrentCommit","Set","formatMarkName","markName","formatLabel","label","warning$$1","suffix","beginMark","clearMark","endMark","formattedMarkName","formattedLabel","err","getFiberMarkName","debugID","getFiberLabel","componentName","beginFiberMark","_debugID","add","clearFiberMark","endFiberMark","shouldIgnoreFiber","clearPendingPhaseMeasurement","pauseTimers","_debugIsCurrentlyTiming","resumeTimersRecursively","resumeTimers","recordEffect","recordScheduleUpdate","startRequestCallbackTimer","stopRequestCallbackTimer","didExpire","startWorkTimer","cancelWorkTimer","stopWorkTimer","stopFailedWorkTimer","startPhaseTimer","stopPhaseTimer","startWorkLoopTimer","nextUnitOfWork","stopWorkLoopTimer","interruptedBy","startCommitTimer","clear","stopCommitTimer","startCommitHostEffectsTimer","stopCommitHostEffectsTimer","count","startCommitLifeCyclesTimer","stopCommitLifeCyclesTimer","warnedAboutMissingGetChildContext","contextStackCursor","didPerformWorkStackCursor","previousContext","getUnmaskedContext","hasOwnContext","isContextProvider","cacheContext","unmaskedContext","maskedContext","__reactInternalMemoizedUnmaskedChildContext","__reactInternalMemoizedMaskedChildContext","getMaskedContext","contextTypes","hasContextChanged","isContextConsumer","childContextTypes","popContextProvider","popTopLevelContextObject","pushTopLevelContextObject","didChange","processChildContext","parentContext","getChildContext","childContext","contextKey","pushContextProvider","memoizedMergedChildContext","__reactInternalMemoizedMergedChildContext","invalidateContextProvider","mergedContext","resetContext","findCurrentUnmaskedContext","NoWork","Sync","Never","UNIT_SIZE","MAGIC_NUMBER_OFFSET","msToExpirationTime","ms","ceiling","num","precision","computeExpirationBucket","currentTime","expirationInMs","bucketSizeMs","NoContext","AsyncUpdates","hasBadMapPolyfill","nonExtensibleObject","preventExtensions","Map","debugCounter","FiberNode","internalContextTag","ref","pendingProps","memoizedProps","updateQueue","memoizedState","nextEffect","firstEffect","lastEffect","expirationTime","createFiber","shouldConstruct","Component","isReactComponent","createWorkInProgress","createHostRootFiber","createFiberFromElement","_owner","keys","_source","createFiberFromFragment","elements","createFiberFromText","content","createFiberFromHostInstanceForDeletion","createFiberFromCall","handler","createFiberFromReturn","returnNode","createFiberFromPortal","portal","pendingChildren","createFiberRoot","hydrate","uninitializedFiber","remainingExpirationTime","isReadyForCommit","finishedWork","pendingContext","nextScheduledRoot","onCommitFiberRoot","onCommitFiberUnmount","hasLoggedError","catchErrors","injectInternals","internals","__REACT_DEVTOOLS_GLOBAL_HOOK__","hook","isDisabled","supportsFiber","rendererID","inject","onCommitRoot","onCommitUnmount","didWarnUpdateInsideUpdate","createUpdateQueue","baseState","queue","first","last","callbackList","hasForceUpdate","isInitialized","isProcessing","insertUpdateIntoQueue","update","insertUpdateIntoFiber","alternateFiber","queue1","queue2","getUpdateExpirationTime","getStateFromUpdate","prevState","partialState","updateFn","processUpdateQueue","renderExpirationTime","currentQueue","dontMutatePrevState","didSkip","updateExpirationTime","_partialState","isReplace","isForced","callback","_callbackList","commitCallbacks","_callback","fakeInternalInstance","didWarnAboutStateAssignmentForComponent","warnOnInvalidCallback","callerName","ReactFiberClassComponent","scheduleWork","computeExpirationForFiber","memoizeProps","memoizeState","updater","enqueueSetState","nextCallback","enqueueReplaceState","enqueueForceUpdate","checkShouldComponentUpdate","oldProps","newProps","oldState","newState","newContext","shouldComponentUpdate","shouldUpdate","isPureReactComponent","checkClassInstance","renderPresent","render","noGetInitialStateOnES6","getInitialState","isReactClassApproved","noGetDefaultPropsOnES6","getDefaultProps","noInstancePropTypes","propTypes","noInstanceContextTypes","noComponentShouldUpdate","componentShouldUpdate","noComponentDidUnmount","componentDidUnmount","noComponentDidReceiveProps","componentDidReceiveProps","noComponentWillRecieveProps","componentWillRecieveProps","hasMutatedProps","noInstanceDefaultProps","defaultProps","resetInputPointers","adoptClassInstance","_reactInternalInstance","constructClassInstance","ctor","needsContext","callComponentWillMount","componentWillMount","callComponentWillReceiveProps","componentWillReceiveProps","mountClassInstance","refs","unstable_isAsyncReactComponent","componentDidMount","updateClassInstance","oldContext","newUnmaskedContext","componentDidUpdate","componentWillUpdate","REACT_PORTAL_TYPE","Symbol","createPortal$1","$$typeof","getCurrentFiberStackAddendum$1","didWarnAboutMaps","ownerHasKeyUseWarning","ownerHasFunctionTypeWarning","warnForMissingKey","_store","validated","currentComponentErrorInfo","isArray$1","ITERATOR_SYMBOL","iterator","FAUX_ITERATOR_SYMBOL","REACT_ELEMENT_TYPE","REACT_CALL_TYPE","REACT_RETURN_TYPE","REACT_FRAGMENT_TYPE","getIteratorFn","maybeIterable","iteratorFn","coerceRef","mixedRef","stringRef","_stringRef","throwOnInvalidObjectType","returnFiber","newChild","addendum","join","warnOnFunctionType","ChildReconciler","shouldClone","shouldTrackSideEffects","deleteChild","childToDelete","deleteRemainingChildren","currentFirstChild","mapRemainingChildren","existingChildren","existingChild","useFiber","clone","placeChild","newFiber","lastPlacedIndex","newIndex","oldIndex","placeSingleChild","updateTextNode","created","existing","updateElement","updateCall","updateReturn","updatePortal","updateFragment","fragment","createChild","_created","_created2","_created3","_created4","_created5","_created6","updateSlot","oldFiber","updateFromMap","newIdx","matchedFiber","_matchedFiber","_matchedFiber2","_matchedFiber3","_matchedFiber4","_matchedFiber5","warnOnInvalidKey","knownKeys","reconcileChildrenArray","newChildren","resultingFirstChild","previousNewFiber","nextOldFiber","_newFiber","_newFiber2","reconcileChildrenIterator","newChildrenIterable","entries","possibleMap","_newChildren","_step","done","step","_newFiber3","_newFiber4","reconcileSingleTextNode","reconcileSingleElement","_created7","reconcileSingleCall","reconcileSingleReturn","reconcileSinglePortal","reconcileChildFibers","isObject","_isMockFunction","reconcileChildFibersInPlace","mountChildFibersInPlace","cloneChildFibers","currentChild","warnedAboutStatelessRefs","ReactFiberBeginWork","config","hostContext","hydrationContext","shouldSetTextContent","useSyncScheduling","shouldDeprioritizeSubtree","pushHostContext","pushHostContainer","enterHydrationState","resetHydrationState","tryToClaimNextHydratableInstance","_ReactFiberClassCompo","reconcileChildren","nextChildren","reconcileChildrenAtExpirationTime","bailoutOnAlreadyFinishedWork","markRef","updateFunctionalComponent","nextProps","updateClassComponent","hasContext","finishClassComponent","pushHostRootContext","updateHostRoot","updateHostComponent","prevProps","isDirectTextChild","updateHostText","mountIndeterminateComponent","warningKey","debugSource","updateCallComponent","nextCall","updatePortalComponent","bailoutOnLowPriority","nextState","beginWork","beginFailedWork","ReactFiberCompleteWork","createInstance","createTextInstance","appendInitialChild","finalizeInitialChildren","prepareUpdate","mutation","persistence","getRootHostContainer","popHostContext","getHostContext","popHostContainer","prepareToHydrateHostInstance","prepareToHydrateHostTextInstance","popHydrationState","markUpdate","appendAllReturns","returns","moveCallToHandlerPhase","appendAllChildren","updateHostContainer","updatePayload","rootContainerInstance","oldText","newText","cloneInstance","createContainerChildSet","appendChildToContainerChildSet","finalizeContainerChildren","appendAllChildrenToContainer","containerChildSet","portalOrRoot","childrenUnchanged","container","newChildSet","currentInstance","recyclableInstance","newInstance","currentHostContext","completeWork","fiberRoot","_currentHostContext","wasHydrated","_instance","_rootContainerInstance","_currentHostContext2","_wasHydrated","invokeGuardedCallback$2","hasCaughtError$1","clearCaughtError$1","ReactFiberCommitWork","captureError","getPublicInstance","callComponentWillUnmountWithTimer","componentWillUnmount","safelyCallComponentWillUnmount","unmountError","safelyDetachRef","refError","commitLifeCycles","_updateQueue","_instance2","commitMount","commitAttachRef","commitDetachRef","currentRef","commitUnmount","commitNestedUnmounts","unmountHostComponents","emptyPortalContainer","detachFiber","commitContainer","replaceContainerChildren","emptyChildSet","_pendingChildren","commitResetTextContent","commitPlacement","commitDeletion","commitWork","commitUpdate","resetTextContent","commitTextUpdate","appendChild","appendChildToContainer","insertBefore","insertInContainerBefore","removeChild","removeChildFromContainer","getHostParentFiber","isHostParent","getHostSibling","siblings","parentFiber","isContainer","before","currentParentIsValid","currentParentIsContainer","findParent","textInstance","NO_CONTEXT","ReactFiberHostContext","getChildHostContext","getRootHostContext","contextFiberStackCursor","rootInstanceStackCursor","requiredContext","rootInstance","nextRootInstance","nextRootContext","nextContext","resetHostContainer","ReactFiberHydrationContext","hydration","canHydrateInstance","canHydrateTextInstance","getNextHydratableSibling","getFirstHydratableChild","hydrateInstance","hydrateTextInstance","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","didNotHydrateContainerInstance","didNotHydrateInstance","didNotFindHydratableContainerInstance","didNotFindHydratableContainerTextInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","hydrationParentFiber","nextHydratableInstance","isHydrating","parentInstance","deleteHydratableInstance","insertNonHydratedInstance","parentContainer","parentType","parentProps","_type","_props","_text","tryHydrate","nextInstance","popToNextHostParent","ReactFiberInstrumentation","debugTool","ReactFiberInstrumentation_1","defaultShowDialog","capturedError","showDialog","logCapturedError","logError","componentStack","errorBoundaryName","errorBoundaryFound","willRetry","componentNameMessage","errorBoundaryMessage","combinedMessage","console","invokeGuardedCallback$1","didWarnAboutStateTransition","didWarnSetStateChildContext","didWarnStateUpdateForUnmountedComponent","warnAboutUpdateOnUnmounted","warnAboutInvalidUpdates","ReactFiberScheduler","_ReactFiberBeginWork","_ReactFiberCompleteWo","_ReactFiberCommitWork","scheduleDeferredCallback","prepareForCommit","resetAfterCommit","startTime","mostRecentCurrentTime","expirationContext","isWorking","nextRoot","nextRenderExpirationTime","capturedErrors","failedBoundaries","commitPhaseBoundaries","firstUncaughtError","didFatal","isUnmounting","resetContextStack","commitAllHostEffects","primaryEffectTag","_current","_current2","commitAllLifeCycles","commitErrorHandling","commitRoot","_error","_didError","_error2","onCommitWork","scheduleErrorRecovery","_error3","onUncaughtError","remainingTime","resetExpirationTime","renderTime","newExpirationTime","completeUnitOfWork","siblingFiber","onCompleteWork","performUnitOfWork","onBeginWork","performFailedUnitOfWork","workLoop","slowWorkLoopThatChecksForFailedWork","shouldYield","hasCapturedError","renderRootCatchBlock","failedWork","boundary","unwindContexts","renderRoot","uncaughtError","isFailedBoundary","componentDidCatch","_componentStack","_componentName","errorBoundary","effectfulFiber","computeAsyncExpiration","recalculateCurrentTime","expirationMs","scheduleWorkImpl","isErrorRecovery","requestWork","deferredUpdates","previousExpirationContext","syncUpdates","firstScheduledRoot","lastScheduledRoot","isCallbackScheduled","isRendering","nextFlushedRoot","nextFlushedExpirationTime","deadlineDidExpire","hasUnhandledError","unhandledError","deadline","isBatchingUpdates","isUnbatchingUpdates","NESTED_UPDATE_LIMIT","nestedUpdateCount","timeHeuristicForUnitOfWork","performWorkOnRoot","performWork","performAsyncWork","findHighestPriorityRoot","highestPriorityWork","highestPriorityRoot","previousScheduledRoot","previousFlushedRoot","dl","minExpirationTime","_error4","_finishedWork","timeRemaining","previousIsBatchingUpdates","unbatchedUpdates","flushSync","didWarnAboutNestedUpdates","getContextForSubtree","parentComponent","ReactFiberReconciler$1","_ReactFiberScheduler","scheduleTopLevelUpdate","findHostInstance","hostFiber","createContainer","updateContainer","onMountContainer","onUnmountContainer","onUpdateContainer","getPublicRootInstance","containerFiber","findHostInstanceWithNoPortals","injectIntoDevTools","devToolsConfig","findFiberByHostInstance","findHostInstanceByFiber","ReactFiberReconciler$2","default","ReactFiberReconciler$3","reactReconciler","ReactVersion","requestAnimationFrame","hasNativePerformanceNow","rIC","frameCallback","setTimeout","Infinity","requestIdleCallback","scheduledRICCallback","isIdleScheduled","isAnimationFrameScheduled","frameDeadline","previousFrameTime","activeFrameTime","frameDeadlineObject","messageKey","idleTick","animationTick","rafTime","nextFrameTime","postMessage","lowPriorityWarning","printWarning","format","_len","_key","argIndex","message","x","condition","_len2","_key2","lowPriorityWarning$1","VALID_ATTRIBUTE_NAME_REGEX","RegExp","illegalAttributeNameCache","validatedAttributeNameCache","isAttributeNameSafe","test","shouldIgnoreValue","isNaN","getValueForProperty","expected","stringValue","getValueForAttribute","setValueForProperty","deleteValueForProperty","namespace","setAttributeNS","setValueForAttribute","deleteValueForAttribute","ReactControlledValuePropTypes","hasReadOnlyValue","checkbox","image","radio","submit","onChange","tagName","getStack","getCurrentFiberOwnerName$2","getCurrentFiberStackAddendum$3","didWarnValueDefaultValue","didWarnCheckedDefaultChecked","didWarnControlledToUncontrolled","didWarnUncontrolledToControlled","isControlled","usesChecked","getHostProps","hostProps","max","initialValue","initialChecked","initWrapperState","updateWrapper","valueAsNumber","parseFloat","postMountWrapper","restoreControlledState$1","updateNamedCousins","rootNode","queryRoot","group","querySelectorAll","JSON","stringify","otherNode","form","otherProps","flattenChildren","Children","validateProps","postMountWrapper$1","getHostProps$1","getCurrentFiberOwnerName$3","getCurrentFiberStackAddendum$4","didWarnValueDefaultValue$1","getDeclarationErrorAddendum","valuePropNames","checkSelectPropTypes","updateOptions","propValue","setDefaultSelected","options","selectedValues","selectedValue","defaultSelected","_selectedValue","_i2","getHostProps$2","initWrapperState$1","wasMultiple","postMountWrapper$2","postUpdateWrapper","restoreControlledState$2","getCurrentFiberStackAddendum$5","didWarnValDefaultVal","getHostProps$3","initWrapperState$2","updateWrapper$1","newValue","postMountWrapper$3","restoreControlledState$3","HTML_NAMESPACE$1","MATH_NAMESPACE","SVG_NAMESPACE","Namespaces","html","mathml","svg","getIntrinsicNamespace","getChildNamespace","parentNamespace","createMicrosoftUnsafeLocalFunction","MSApp","execUnsafeLocalFunction","arg0","arg1","arg2","arg3","reusableSVGContainer","setInnerHTML","namespaceURI","svgNode","matchHtmlRegExp","escapeHtml","string","str","match","exec","escape","lastIndex","charCodeAt","substring","escapeTextContentForBrowser","setTextContent","lastChild","setTextContent$1","isUnitlessNumber","animationIterationCount","borderImageOutset","borderImageSlice","borderImageWidth","boxFlex","boxFlexGroup","boxOrdinalGroup","columnCount","columns","flex","flexGrow","flexPositive","flexShrink","flexNegative","flexOrder","gridRow","gridRowEnd","gridRowSpan","gridRowStart","gridColumn","gridColumnEnd","gridColumnSpan","gridColumnStart","fontWeight","lineClamp","lineHeight","opacity","order","orphans","tabSize","widows","zIndex","zoom","fillOpacity","floodOpacity","stopOpacity","strokeDasharray","strokeDashoffset","strokeMiterlimit","strokeOpacity","strokeWidth","prefixKey","charAt","dangerousStyleValue","isCustomProperty","isEmpty","trim","warnValidStyle","badVendoredStyleNamePattern","badStyleValueWithSemicolonPattern","warnedStyleNames","warnedStyleValues","warnedForNaNValue","warnedForInfinityValue","warnHyphenatedStyleName","warnBadVendoredStyleName","warnStyleValueWithSemicolon","warnStyleValueIsNaN","warnStyleValueIsInfinity","isFinite","warnValidStyle$1","createDangerousStringForStyles","styles","serialized","delimiter","styleName","styleValue","setValueForStyles","setProperty","omittedCloseTags","area","base","br","col","embed","hr","img","keygen","link","meta","param","wbr","voidElementTags","menuitem","HTML$1","assertValidProps","isCustomComponent","is","ariaProperties","warnedProperties","rARIA","rARIACamel","getStackAddendum","stack","validateProperty","ariaName","correctName","standardName","warnInvalidARIAProps","invalidProps","isValid","unknownPropString","map","validateProperties","didWarnValueNull","getStackAddendum$1","validateProperties$1","possibleStandardNames","accept","acceptcharset","accesskey","allowfullscreen","alt","as","autocapitalize","autocomplete","autocorrect","autofocus","autoplay","autosave","cellpadding","cellspacing","challenge","charset","cite","classid","classname","colspan","contenteditable","contextmenu","controlslist","coords","crossorigin","dangerouslysetinnerhtml","defaultchecked","defaultvalue","dir","enctype","formmethod","formaction","formenctype","formnovalidate","formtarget","frameborder","headers","height","high","href","hreflang","htmlfor","httpequiv","icon","id","innerhtml","inputmode","integrity","itemid","itemprop","itemref","itemscope","itemtype","keyparams","keytype","kind","lang","list","low","manifest","marginwidth","marginheight","maxlength","media","mediagroup","method","minlength","nonce","novalidate","optimum","pattern","placeholder","playsinline","poster","preload","profile","radiogroup","readonly","referrerpolicy","rel","role","rowspan","sandbox","scrolling","shape","sizes","spellcheck","src","srcdoc","srclang","srcset","summary","tabindex","title","usemap","width","wmode","wrap","about","accentheight","accumulate","additive","alignmentbaseline","allowreorder","alphabetic","amplitude","arabicform","ascent","attributename","attributetype","autoreverse","azimuth","basefrequency","baselineshift","baseprofile","bbox","begin","bias","by","calcmode","capheight","clip","clippath","clippathunits","cliprule","colorinterpolation","colorinterpolationfilters","colorprofile","colorrendering","contentscripttype","contentstyletype","cx","cy","datatype","decelerate","descent","diffuseconstant","direction","display","divisor","dominantbaseline","dur","dx","dy","edgemode","elevation","enablebackground","exponent","externalresourcesrequired","fill","fillopacity","fillrule","filter","filterres","filterunits","floodopacity","floodcolor","focusable","fontfamily","fontsize","fontsizeadjust","fontstretch","fontstyle","fontvariant","fontweight","fx","fy","g1","g2","glyphname","glyphorientationhorizontal","glyphorientationvertical","glyphref","gradienttransform","gradientunits","hanging","horizadvx","horizoriginx","ideographic","imagerendering","in2","inlist","intercept","k1","k2","k3","k4","k","kernelmatrix","kernelunitlength","kerning","keypoints","keysplines","keytimes","lengthadjust","letterspacing","lightingcolor","limitingconeangle","local","markerend","markerheight","markermid","markerstart","markerunits","markerwidth","mask","maskcontentunits","maskunits","mathematical","mode","numoctaves","operator","orient","orientation","origin","overflow","overlineposition","overlinethickness","paintorder","panose1","pathlength","patterncontentunits","patterntransform","patternunits","pointerevents","points","pointsatx","pointsaty","pointsatz","preservealpha","preserveaspectratio","primitiveunits","property","r","radius","refx","refy","renderingintent","repeatcount","repeatdur","requiredextensions","requiredfeatures","resource","restart","results","rotate","rx","ry","scale","security","seed","shaperendering","slope","spacing","specularconstant","specularexponent","speed","spreadmethod","startoffset","stddeviation","stemh","stemv","stitchtiles","stopcolor","stopopacity","strikethroughposition","strikethroughthickness","stroke","strokedasharray","strokedashoffset","strokelinecap","strokelinejoin","strokemiterlimit","strokewidth","strokeopacity","suppresscontenteditablewarning","suppresshydrationwarning","surfacescale","systemlanguage","tablevalues","targetx","targety","textanchor","textdecoration","textlength","textrendering","transform","u1","u2","underlineposition","underlinethickness","unicode","unicodebidi","unicoderange","unitsperem","unselectable","valphabetic","values","vectoreffect","vertadvy","vertoriginx","vertoriginy","vhanging","videographic","viewbox","viewtarget","visibility","vmathematical","vocab","widths","wordspacing","writingmode","x1","x2","xchannelselector","xheight","xlinkactuate","xlinkarcrole","xlinkhref","xlinkrole","xlinkshow","xlinktitle","xlinktype","xmlbase","xmllang","xmlns","xmlnsxlink","xmlspace","y1","y2","y","ychannelselector","z","zoomandpan","getStackAddendum$2","warnedProperties$1","hasOwnProperty$1","EVENT_NAME_REGEX","rARIA$1","rARIACamel$1","validateProperty$1","isReserved","warnUnknownProperties","unknownProps","validateProperties$2","getCurrentFiberOwnerName$1","getCurrentFiberStackAddendum$2","didWarnInvalidHydration","didWarnShadyDOM","DANGEROUSLY_SET_INNER_HTML","SUPPRESS_CONTENT_EDITABLE_WARNING","SUPPRESS_HYDRATION_WARNING$1","AUTOFOCUS","CHILDREN","STYLE","HTML","HTML_NAMESPACE","thatReturns","warnedUnknownTags","dialog","validatePropertiesInDevelopment","NORMALIZE_NEWLINES_REGEX","NORMALIZE_NULL_AND_REPLACEMENT_REGEX","normalizeMarkupForTextOrAttribute","markup","markupString","warnForTextDifference","serverText","clientText","normalizedClientText","normalizedServerText","warnForPropDifference","serverValue","clientValue","normalizedClientValue","normalizedServerValue","warnForExtraAttributes","attributeNames","names","warnForInvalidEventListener","normalizeHTML","testElement","createElementNS","ensureListeningTo","rootContainerElement","isDocumentOrFragment","getOwnerDocumentFromRootContainer","mediaEvents","trapClickOnNonInteractiveElement","onclick","setInitialDOMProperties","domElement","isCustomComponentTag","propKey","nextProp","nextHtml","canSetTextContent","updateDOMProperties","wasCustomComponentTag","createElement$1","div","createTextNode$1","createTextNode","setInitialProperties$1","rawProps","shadyRoot","onClick","diffProperties$1","lastRawProps","nextRawProps","lastProps","styleUpdates","lastStyle","lastProp","lastHtml","updateProperties$1","diffHydratedProperties$1","extraAttributeNames","attributes","rawHtml","serverHTML","expectedHTML","expectedStyle","ownNamespace","diffHydratedText$1","textNode","isDifferent","warnForUnmatchedText$1","warnForDeletedHydratableElement$1","warnForDeletedHydratableText$1","warnForInsertedHydratedElement$1","warnForInsertedHydratedText$1","ReactDOMFiberComponent","setInitialProperties","diffProperties","updateProperties","diffHydratedProperties","diffHydratedText","warnForUnmatchedText","warnForDeletedHydratableElement","warnForDeletedHydratableText","warnForInsertedHydratedElement","warnForInsertedHydratedText","getCurrentFiberStackAddendum$6","validateDOMNesting","specialTags","inScopeTags","buttonScopeTags","impliedEndTags","emptyAncestorInfo","formTag","aTagInScope","buttonTagInScope","nobrTagInScope","pTagInButtonScope","listItemTagAutoclosing","dlItemTagAutoclosing","updatedAncestorInfo$1","oldInfo","ancestorInfo","isTagValidWithParent","parentTag","findInvalidAncestorForTag","didWarn","childTag","childText","parentInfo","invalidParent","invalidAncestor","invalidParentOrAncestor","ancestorTag","warnKey","tagDisplayName","whitespaceInfo","updatedAncestorInfo","isTagValidInContext","validateDOMNesting$1","SUPPRESS_HYDRATION_WARNING","eventsEnabled","selectionInformation","isValidContainer","getReactRootElementInContainer","shouldHydrateDueToLegacyHeuristic","rootElement","shouldAutoFocusHostComponent","DOMRenderer","validatedTag","_ancestorInfo","parentHostContext","parentHostContextDev","_namespace","_ancestorInfo2","internalInstanceHandle","hostContextDev","ownAncestorInfo","__html","focus","beforeChild","warnedAboutHydrateAPI","renderSubtreeIntoContainer","forceHydrate","_reactRootContainer","hostInstance","isRootRenderedBySomeReact","rootEl","hasNonRootReactChild","shouldHydrate","warned","rootSibling","newRoot","createPortal","ReactRoot","unmount","ReactDOM","findDOMNode","componentOrElement","warnedAboutRefsInRender","unstable_renderSubtreeIntoContainer","containerNode","unmountComponentAtNode","renderedByDifferentReact","_rootEl","isContainerReactRoot","unstable_createPortal","unstable_batchedUpdates","unstable_deferredUpdates","createRoot","foundDevTools","bundleType","rendererPackageName","self","navigator","userAgent","protocol","ReactDOM$2","ReactDOM$3","reactDom","module","exports"],"mappings":"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","sourcesContent":["/** @license React v16.1.1\n * react-dom.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar React = require('react');\nvar invariant = require('fbjs/lib/invariant');\nvar warning = require('fbjs/lib/warning');\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\nvar _assign = require('object-assign');\nvar emptyFunction$1 = require('fbjs/lib/emptyFunction');\nvar EventListener = require('fbjs/lib/EventListener');\nvar getActiveElement = require('fbjs/lib/getActiveElement');\nvar shallowEqual = require('fbjs/lib/shallowEqual');\nvar containsNode = require('fbjs/lib/containsNode');\nvar focusNode = require('fbjs/lib/focusNode');\nvar emptyObject = require('fbjs/lib/emptyObject');\nvar checkPropTypes = require('prop-types/checkPropTypes');\nvar hyphenateStyleName = require('fbjs/lib/hyphenateStyleName');\nvar camelizeStyleName = require('fbjs/lib/camelizeStyleName');\n\n/**\n * WARNING: DO NOT manually require this module.\n * This is a replacement for `invariant(...)` used by the error code system\n * and will _only_ be required by the corresponding babel pass.\n * It always throws.\n */\n\n!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;\n\n// These attributes should be all lowercase to allow for\n// case insensitive checks\nvar RESERVED_PROPS = {\n  children: true,\n  dangerouslySetInnerHTML: true,\n  defaultValue: true,\n  defaultChecked: true,\n  innerHTML: true,\n  suppressContentEditableWarning: true,\n  suppressHydrationWarning: true,\n  style: true\n};\n\nfunction checkMask(value, bitmask) {\n  return (value & bitmask) === bitmask;\n}\n\nvar DOMPropertyInjection = {\n  /**\n   * Mapping from normalized, camelcased property names to a configuration that\n   * specifies how the associated DOM property should be accessed or rendered.\n   */\n  MUST_USE_PROPERTY: 0x1,\n  HAS_BOOLEAN_VALUE: 0x4,\n  HAS_NUMERIC_VALUE: 0x8,\n  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,\n  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,\n  HAS_STRING_BOOLEAN_VALUE: 0x40,\n\n  /**\n   * Inject some specialized knowledge about the DOM. This takes a config object\n   * with the following properties:\n   *\n   * Properties: object mapping DOM property name to one of the\n   * DOMPropertyInjection constants or null. If your attribute isn't in here,\n   * it won't get written to the DOM.\n   *\n   * DOMAttributeNames: object mapping React attribute name to the DOM\n   * attribute name. Attribute names not specified use the **lowercase**\n   * normalized name.\n   *\n   * DOMAttributeNamespaces: object mapping React attribute name to the DOM\n   * attribute namespace URL. (Attribute names not specified use no namespace.)\n   *\n   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.\n   * Property names not specified use the normalized name.\n   *\n   * DOMMutationMethods: Properties that require special mutation methods. If\n   * `value` is undefined, the mutation method should unset the property.\n   *\n   * @param {object} domPropertyConfig the config as described above.\n   */\n  injectDOMPropertyConfig: function (domPropertyConfig) {\n    var Injection = DOMPropertyInjection;\n    var Properties = domPropertyConfig.Properties || {};\n    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};\n    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};\n    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};\n\n    for (var propName in Properties) {\n      !!properties.hasOwnProperty(propName) ? invariant(false, \"injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.\", propName) : void 0;\n\n      var lowerCased = propName.toLowerCase();\n      var propConfig = Properties[propName];\n\n      var propertyInfo = {\n        attributeName: lowerCased,\n        attributeNamespace: null,\n        propertyName: propName,\n        mutationMethod: null,\n\n        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),\n        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),\n        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),\n        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),\n        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE),\n        hasStringBooleanValue: checkMask(propConfig, Injection.HAS_STRING_BOOLEAN_VALUE)\n      };\n      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? invariant(false, \"DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s\", propName) : void 0;\n\n      if (DOMAttributeNames.hasOwnProperty(propName)) {\n        var attributeName = DOMAttributeNames[propName];\n\n        propertyInfo.attributeName = attributeName;\n      }\n\n      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {\n        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];\n      }\n\n      if (DOMMutationMethods.hasOwnProperty(propName)) {\n        propertyInfo.mutationMethod = DOMMutationMethods[propName];\n      }\n\n      // Downcase references to whitelist properties to check for membership\n      // without case-sensitivity. This allows the whitelist to pick up\n      // `allowfullscreen`, which should be written using the property configuration\n      // for `allowFullscreen`\n      properties[propName] = propertyInfo;\n    }\n  }\n};\n\n/* eslint-disable max-len */\nvar ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n/* eslint-enable max-len */\nvar ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n\n\nvar ROOT_ATTRIBUTE_NAME = 'data-reactroot';\n\n/**\n * Map from property \"standard name\" to an object with info about how to set\n * the property in the DOM. Each object contains:\n *\n * attributeName:\n *   Used when rendering markup or with `*Attribute()`.\n * attributeNamespace\n * propertyName:\n *   Used on DOM node instances. (This includes properties that mutate due to\n *   external factors.)\n * mutationMethod:\n *   If non-null, used instead of the property or `setAttribute()` after\n *   initial render.\n * mustUseProperty:\n *   Whether the property must be accessed and mutated as an object property.\n * hasBooleanValue:\n *   Whether the property should be removed when set to a falsey value.\n * hasNumericValue:\n *   Whether the property must be numeric or parse as a numeric and should be\n *   removed when set to a falsey value.\n * hasPositiveNumericValue:\n *   Whether the property must be positive numeric or parse as a positive\n *   numeric and should be removed when set to a falsey value.\n * hasOverloadedBooleanValue:\n *   Whether the property can be used as a flag as well as with a value.\n *   Removed when strictly equal to false; present without a value when\n *   strictly equal to true; present with a value otherwise.\n */\nvar properties = {};\n\n/**\n * Checks whether a property name is a writeable attribute.\n * @method\n */\nfunction shouldSetAttribute(name, value) {\n  if (isReservedProp(name)) {\n    return false;\n  }\n  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {\n    return false;\n  }\n  if (value === null) {\n    return true;\n  }\n  switch (typeof value) {\n    case 'boolean':\n      return shouldAttributeAcceptBooleanValue(name);\n    case 'undefined':\n    case 'number':\n    case 'string':\n    case 'object':\n      return true;\n    default:\n      // function, symbol\n      return false;\n  }\n}\n\nfunction getPropertyInfo(name) {\n  return properties.hasOwnProperty(name) ? properties[name] : null;\n}\n\nfunction shouldAttributeAcceptBooleanValue(name) {\n  if (isReservedProp(name)) {\n    return true;\n  }\n  var propertyInfo = getPropertyInfo(name);\n  if (propertyInfo) {\n    return propertyInfo.hasBooleanValue || propertyInfo.hasStringBooleanValue || propertyInfo.hasOverloadedBooleanValue;\n  }\n  var prefix = name.toLowerCase().slice(0, 5);\n  return prefix === 'data-' || prefix === 'aria-';\n}\n\n/**\n * Checks to see if a property name is within the list of properties\n * reserved for internal React operations. These properties should\n * not be set on an HTML element.\n *\n * @private\n * @param {string} name\n * @return {boolean} If the name is within reserved props\n */\nfunction isReservedProp(name) {\n  return RESERVED_PROPS.hasOwnProperty(name);\n}\n\nvar injection = DOMPropertyInjection;\n\nvar MUST_USE_PROPERTY = injection.MUST_USE_PROPERTY;\nvar HAS_BOOLEAN_VALUE = injection.HAS_BOOLEAN_VALUE;\nvar HAS_NUMERIC_VALUE = injection.HAS_NUMERIC_VALUE;\nvar HAS_POSITIVE_NUMERIC_VALUE = injection.HAS_POSITIVE_NUMERIC_VALUE;\nvar HAS_OVERLOADED_BOOLEAN_VALUE = injection.HAS_OVERLOADED_BOOLEAN_VALUE;\nvar HAS_STRING_BOOLEAN_VALUE = injection.HAS_STRING_BOOLEAN_VALUE;\n\nvar HTMLDOMPropertyConfig = {\n  // When adding attributes to this list, be sure to also add them to\n  // the `possibleStandardNames` module to ensure casing and incorrect\n  // name warnings.\n  Properties: {\n    allowFullScreen: HAS_BOOLEAN_VALUE,\n    // specifies target context for links with `preload` type\n    async: HAS_BOOLEAN_VALUE,\n    // Note: there is a special case that prevents it from being written to the DOM\n    // on the client side because the browsers are inconsistent. Instead we call focus().\n    autoFocus: HAS_BOOLEAN_VALUE,\n    autoPlay: HAS_BOOLEAN_VALUE,\n    capture: HAS_OVERLOADED_BOOLEAN_VALUE,\n    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    cols: HAS_POSITIVE_NUMERIC_VALUE,\n    contentEditable: HAS_STRING_BOOLEAN_VALUE,\n    controls: HAS_BOOLEAN_VALUE,\n    'default': HAS_BOOLEAN_VALUE,\n    defer: HAS_BOOLEAN_VALUE,\n    disabled: HAS_BOOLEAN_VALUE,\n    download: HAS_OVERLOADED_BOOLEAN_VALUE,\n    draggable: HAS_STRING_BOOLEAN_VALUE,\n    formNoValidate: HAS_BOOLEAN_VALUE,\n    hidden: HAS_BOOLEAN_VALUE,\n    loop: HAS_BOOLEAN_VALUE,\n    // Caution; `option.selected` is not updated if `select.multiple` is\n    // disabled with `removeAttribute`.\n    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    noValidate: HAS_BOOLEAN_VALUE,\n    open: HAS_BOOLEAN_VALUE,\n    playsInline: HAS_BOOLEAN_VALUE,\n    readOnly: HAS_BOOLEAN_VALUE,\n    required: HAS_BOOLEAN_VALUE,\n    reversed: HAS_BOOLEAN_VALUE,\n    rows: HAS_POSITIVE_NUMERIC_VALUE,\n    rowSpan: HAS_NUMERIC_VALUE,\n    scoped: HAS_BOOLEAN_VALUE,\n    seamless: HAS_BOOLEAN_VALUE,\n    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    size: HAS_POSITIVE_NUMERIC_VALUE,\n    start: HAS_NUMERIC_VALUE,\n    // support for projecting regular DOM Elements via V1 named slots ( shadow dom )\n    span: HAS_POSITIVE_NUMERIC_VALUE,\n    spellCheck: HAS_STRING_BOOLEAN_VALUE,\n    // Style must be explicitly set in the attribute list. React components\n    // expect a style object\n    style: 0,\n    // Keep it in the whitelist because it is case-sensitive for SVG.\n    tabIndex: 0,\n    // itemScope is for for Microdata support.\n    // See http://schema.org/docs/gs.html\n    itemScope: HAS_BOOLEAN_VALUE,\n    // These attributes must stay in the white-list because they have\n    // different attribute names (see DOMAttributeNames below)\n    acceptCharset: 0,\n    className: 0,\n    htmlFor: 0,\n    httpEquiv: 0,\n    // Attributes with mutation methods must be specified in the whitelist\n    // Set the string boolean flag to allow the behavior\n    value: HAS_STRING_BOOLEAN_VALUE\n  },\n  DOMAttributeNames: {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv'\n  },\n  DOMMutationMethods: {\n    value: function (node, value) {\n      if (value == null) {\n        return node.removeAttribute('value');\n      }\n\n      // Number inputs get special treatment due to some edge cases in\n      // Chrome. Let everything else assign the value attribute as normal.\n      // https://github.com/facebook/react/issues/7253#issuecomment-236074326\n      if (node.type !== 'number' || node.hasAttribute('value') === false) {\n        node.setAttribute('value', '' + value);\n      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {\n        // Don't assign an attribute if validation reports bad\n        // input. Chrome will clear the value. Additionally, don't\n        // operate on inputs that have focus, otherwise Chrome might\n        // strip off trailing decimal places and cause the user's\n        // cursor position to jump to the beginning of the input.\n        //\n        // In ReactDOMInput, we have an onBlur event that will trigger\n        // this function again when focus is lost.\n        node.setAttribute('value', '' + value);\n      }\n    }\n  }\n};\n\nvar HAS_STRING_BOOLEAN_VALUE$1 = injection.HAS_STRING_BOOLEAN_VALUE;\n\n\nvar NS = {\n  xlink: 'http://www.w3.org/1999/xlink',\n  xml: 'http://www.w3.org/XML/1998/namespace'\n};\n\n/**\n * This is a list of all SVG attributes that need special casing,\n * namespacing, or boolean value assignment.\n *\n * When adding attributes to this list, be sure to also add them to\n * the `possibleStandardNames` module to ensure casing and incorrect\n * name warnings.\n *\n * SVG Attributes List:\n * https://www.w3.org/TR/SVG/attindex.html\n * SMIL Spec:\n * https://www.w3.org/TR/smil\n */\nvar ATTRS = ['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'x-height', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xmlns:xlink', 'xml:lang', 'xml:space'];\n\nvar SVGDOMPropertyConfig = {\n  Properties: {\n    autoReverse: HAS_STRING_BOOLEAN_VALUE$1,\n    externalResourcesRequired: HAS_STRING_BOOLEAN_VALUE$1,\n    preserveAlpha: HAS_STRING_BOOLEAN_VALUE$1\n  },\n  DOMAttributeNames: {\n    autoReverse: 'autoReverse',\n    externalResourcesRequired: 'externalResourcesRequired',\n    preserveAlpha: 'preserveAlpha'\n  },\n  DOMAttributeNamespaces: {\n    xlinkActuate: NS.xlink,\n    xlinkArcrole: NS.xlink,\n    xlinkHref: NS.xlink,\n    xlinkRole: NS.xlink,\n    xlinkShow: NS.xlink,\n    xlinkTitle: NS.xlink,\n    xlinkType: NS.xlink,\n    xmlBase: NS.xml,\n    xmlLang: NS.xml,\n    xmlSpace: NS.xml\n  }\n};\n\nvar CAMELIZE = /[\\-\\:]([a-z])/g;\nvar capitalize = function (token) {\n  return token[1].toUpperCase();\n};\n\nATTRS.forEach(function (original) {\n  var reactName = original.replace(CAMELIZE, capitalize);\n\n  SVGDOMPropertyConfig.Properties[reactName] = 0;\n  SVGDOMPropertyConfig.DOMAttributeNames[reactName] = original;\n});\n\ninjection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);\ninjection.injectDOMPropertyConfig(SVGDOMPropertyConfig);\n\nvar ReactErrorUtils = {\n  // Used by Fiber to simulate a try-catch.\n  _caughtError: null,\n  _hasCaughtError: false,\n\n  // Used by event system to capture/rethrow the first error.\n  _rethrowError: null,\n  _hasRethrowError: false,\n\n  injection: {\n    injectErrorUtils: function (injectedErrorUtils) {\n      !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;\n      invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;\n    }\n  },\n\n  /**\n   * Call a function while guarding against errors that happens within it.\n   * Returns an error if it throws, otherwise null.\n   *\n   * In production, this is implemented using a try-catch. The reason we don't\n   * use a try-catch directly is so that we can swap out a different\n   * implementation in DEV mode.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {\n    invokeGuardedCallback.apply(ReactErrorUtils, arguments);\n  },\n\n  /**\n   * Same as invokeGuardedCallback, but instead of returning an error, it stores\n   * it in a global so it can be rethrown by `rethrowCaughtError` later.\n   * TODO: See if _caughtError and _rethrowError can be unified.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {\n    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n    if (ReactErrorUtils.hasCaughtError()) {\n      var error = ReactErrorUtils.clearCaughtError();\n      if (!ReactErrorUtils._hasRethrowError) {\n        ReactErrorUtils._hasRethrowError = true;\n        ReactErrorUtils._rethrowError = error;\n      }\n    }\n  },\n\n  /**\n   * During execution of guarded functions we will capture the first error which\n   * we will rethrow to be handled by the top level error handler.\n   */\n  rethrowCaughtError: function () {\n    return rethrowCaughtError.apply(ReactErrorUtils, arguments);\n  },\n\n  hasCaughtError: function () {\n    return ReactErrorUtils._hasCaughtError;\n  },\n\n  clearCaughtError: function () {\n    if (ReactErrorUtils._hasCaughtError) {\n      var error = ReactErrorUtils._caughtError;\n      ReactErrorUtils._caughtError = null;\n      ReactErrorUtils._hasCaughtError = false;\n      return error;\n    } else {\n      invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n};\n\nvar invokeGuardedCallback = function (name, func, context, a, b, c, d, e, f) {\n  ReactErrorUtils._hasCaughtError = false;\n  ReactErrorUtils._caughtError = null;\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    ReactErrorUtils._caughtError = error;\n    ReactErrorUtils._hasCaughtError = true;\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function onError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');\n\n      // Attach our event handlers\n      window.addEventListener('error', onError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      var evt = document.createEvent('Event');\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n        } else if (isCrossOriginError) {\n          error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');\n        }\n        ReactErrorUtils._hasCaughtError = true;\n        ReactErrorUtils._caughtError = error;\n      } else {\n        ReactErrorUtils._hasCaughtError = false;\n        ReactErrorUtils._caughtError = null;\n      }\n\n      // Remove our event listeners\n      window.removeEventListener('error', onError);\n    };\n\n    invokeGuardedCallback = invokeGuardedCallbackDev;\n  }\n}\n\nvar rethrowCaughtError = function () {\n  if (ReactErrorUtils._hasRethrowError) {\n    var error = ReactErrorUtils._rethrowError;\n    ReactErrorUtils._rethrowError = null;\n    ReactErrorUtils._hasRethrowError = false;\n    throw error;\n  }\n};\n\n/**\n * Injectable ordering of event plugins.\n */\nvar eventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var pluginModule = namesToPlugins[pluginName];\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\n    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;\n    if (plugins[pluginIndex]) {\n      continue;\n    }\n    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;\n    plugins[pluginIndex] = pluginModule;\n    var publishedEvents = pluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;\n  eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;\n  registrationNameModules[registrationName] = pluginModule;\n  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;\n\n  {\n    var lowerCasedName = registrationName.toLowerCase();\n    possibleRegistrationNames[lowerCasedName] = registrationName;\n\n    if (registrationName === 'onDoubleClick') {\n      possibleRegistrationNames.ondblclick = registrationName;\n    }\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\nvar plugins = [];\n\n/**\n * Mapping from event name to dispatch config\n */\nvar eventNameDispatchConfigs = {};\n\n/**\n * Mapping from registration name to plugin module\n */\nvar registrationNameModules = {};\n\n/**\n * Mapping from registration name to event name\n */\nvar registrationNameDependencies = {};\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\nvar possibleRegistrationNames = {};\n// Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\nfunction injectEventPluginOrder(injectedEventPluginOrder) {\n  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;\n  // Clone the ordering so it cannot be dynamically mutated.\n  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n  recomputePluginOrdering();\n}\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\nfunction injectEventPluginsByName(injectedNamesToPlugins) {\n  var isOrderingDirty = false;\n  for (var pluginName in injectedNamesToPlugins) {\n    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n      continue;\n    }\n    var pluginModule = injectedNamesToPlugins[pluginName];\n    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {\n      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;\n      namesToPlugins[pluginName] = pluginModule;\n      isOrderingDirty = true;\n    }\n  }\n  if (isOrderingDirty) {\n    recomputePluginOrdering();\n  }\n}\n\nvar EventPluginRegistry = Object.freeze({\n\tplugins: plugins,\n\teventNameDispatchConfigs: eventNameDispatchConfigs,\n\tregistrationNameModules: registrationNameModules,\n\tregistrationNameDependencies: registrationNameDependencies,\n\tpossibleRegistrationNames: possibleRegistrationNames,\n\tinjectEventPluginOrder: injectEventPluginOrder,\n\tinjectEventPluginsByName: injectEventPluginsByName\n});\n\nvar getFiberCurrentPropsFromNode = null;\nvar getInstanceFromNode = null;\nvar getNodeFromInstance = null;\n\nvar injection$2 = {\n  injectComponentTree: function (Injected) {\n    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;\n    getInstanceFromNode = Injected.getInstanceFromNode;\n    getNodeFromInstance = Injected.getNodeFromInstance;\n\n    {\n      warning(getNodeFromInstance && getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');\n    }\n  }\n};\n\n\n\n\n\n\nvar validateEventDispatches;\n{\n  validateEventDispatches = function (event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n\n    warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\nfunction executeDispatch(event, simulated, listener, inst) {\n  var type = event.type || 'unknown-event';\n  event.currentTarget = getNodeFromInstance(inst);\n  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n  }\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\n\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\n\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function (event, simulated) {\n  if (event) {\n    executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function (e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function (e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\nfunction isInteractive(tag) {\n  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case 'onClick':\n    case 'onClickCapture':\n    case 'onDoubleClick':\n    case 'onDoubleClickCapture':\n    case 'onMouseDown':\n    case 'onMouseDownCapture':\n    case 'onMouseMove':\n    case 'onMouseMoveCapture':\n    case 'onMouseUp':\n    case 'onMouseUpCapture':\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\nvar injection$1 = {\n  /**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */\n  injectEventPluginOrder: injectEventPluginOrder,\n\n  /**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */\n  injectEventPluginsByName: injectEventPluginsByName\n};\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nfunction getListener(inst, registrationName) {\n  var listener;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  var stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  var props = getFiberCurrentPropsFromNode(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;\n  return listener;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\nfunction extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var events;\n  for (var i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    var possiblePlugin = plugins[i];\n    if (possiblePlugin) {\n      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\n/**\n * Enqueues a synthetic event that should be dispatched when\n * `processEventQueue` is invoked.\n *\n * @param {*} events An accumulation of synthetic events.\n * @internal\n */\nfunction enqueueEvents(events) {\n  if (events) {\n    eventQueue = accumulateInto(eventQueue, events);\n  }\n}\n\n/**\n * Dispatches all synthetic events on the event queue.\n *\n * @internal\n */\nfunction processEventQueue(simulated) {\n  // Set `eventQueue` to null before processing it so that we can tell if more\n  // events get enqueued while processing.\n  var processingEventQueue = eventQueue;\n  eventQueue = null;\n  if (simulated) {\n    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);\n  } else {\n    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);\n  }\n  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;\n  // This would be a good time to rethrow if any of the event handlers threw.\n  ReactErrorUtils.rethrowCaughtError();\n}\n\nvar EventPluginHub = Object.freeze({\n\tinjection: injection$1,\n\tgetListener: getListener,\n\textractEvents: extractEvents,\n\tenqueueEvents: enqueueEvents,\n\tprocessEventQueue: processEventQueue\n});\n\nvar IndeterminateComponent = 0; // Before we know whether it is functional or class\nvar FunctionalComponent = 1;\nvar ClassComponent = 2;\nvar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nvar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 5;\nvar HostText = 6;\nvar CallComponent = 7;\nvar CallHandlerPhase = 8;\nvar ReturnComponent = 9;\nvar Fragment = 10;\n\nvar randomKey = Math.random().toString(36).slice(2);\nvar internalInstanceKey = '__reactInternalInstance$' + randomKey;\nvar internalEventHandlersKey = '__reactEventHandlers$' + randomKey;\n\nfunction precacheFiberNode$1(hostInst, node) {\n  node[internalInstanceKey] = hostInst;\n}\n\n/**\n * Given a DOM node, return the closest ReactDOMComponent or\n * ReactDOMTextComponent instance ancestor.\n */\nfunction getClosestInstanceFromNode(node) {\n  if (node[internalInstanceKey]) {\n    return node[internalInstanceKey];\n  }\n\n  // Walk up the tree until we find an ancestor whose instance we have cached.\n  var parents = [];\n  while (!node[internalInstanceKey]) {\n    parents.push(node);\n    if (node.parentNode) {\n      node = node.parentNode;\n    } else {\n      // Top of the tree. This node must not be part of a React tree (or is\n      // unmounted, potentially).\n      return null;\n    }\n  }\n\n  var closest = void 0;\n  var inst = node[internalInstanceKey];\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber, this will always be the deepest root.\n    return inst;\n  }\n  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {\n    closest = inst;\n  }\n\n  return closest;\n}\n\n/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */\nfunction getInstanceFromNode$1(node) {\n  var inst = node[internalInstanceKey];\n  if (inst) {\n    if (inst.tag === HostComponent || inst.tag === HostText) {\n      return inst;\n    } else {\n      return null;\n    }\n  }\n  return null;\n}\n\n/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */\nfunction getNodeFromInstance$1(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  }\n\n  // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n  invariant(false, 'getNodeFromInstance: Invalid argument.');\n}\n\nfunction getFiberCurrentPropsFromNode$1(node) {\n  return node[internalEventHandlersKey] || null;\n}\n\nfunction updateFiberProps$1(node, props) {\n  node[internalEventHandlersKey] = props;\n}\n\nvar ReactDOMComponentTree = Object.freeze({\n\tprecacheFiberNode: precacheFiberNode$1,\n\tgetClosestInstanceFromNode: getClosestInstanceFromNode,\n\tgetInstanceFromNode: getInstanceFromNode$1,\n\tgetNodeFromInstance: getNodeFromInstance$1,\n\tgetFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,\n\tupdateFiberProps: updateFiberProps$1\n});\n\nfunction getParent(inst) {\n  do {\n    inst = inst['return'];\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\n\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i;\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\n  var pathFrom = [];\n  while (true) {\n    if (!from) {\n      break;\n    }\n    if (from === common) {\n      break;\n    }\n    var alternate = from.alternate;\n    if (alternate !== null && alternate === common) {\n      break;\n    }\n    pathFrom.push(from);\n    from = getParent(from);\n  }\n  var pathTo = [];\n  while (true) {\n    if (!to) {\n      break;\n    }\n    if (to === common) {\n      break;\n    }\n    var _alternate = to.alternate;\n    if (_alternate !== null && _alternate === common) {\n      break;\n    }\n    pathTo.push(to);\n    to = getParent(to);\n  }\n  for (var i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], 'bubbled', argFrom);\n  }\n  for (var _i = pathTo.length; _i-- > 0;) {\n    fn(pathTo[_i], 'captured', argTo);\n  }\n}\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    warning(inst, 'Dispatching inst must not be null');\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\nvar EventPropagators = Object.freeze({\n\taccumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n\taccumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n\taccumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,\n\taccumulateDirectDispatches: accumulateDirectDispatches\n});\n\nvar contentKey = null;\n\n/**\n * Gets the key used to access text content on a DOM node.\n *\n * @return {?string} Key used to access text content.\n * @internal\n */\nfunction getTextContentAccessor() {\n  if (!contentKey && ExecutionEnvironment.canUseDOM) {\n    // Prefer textContent to innerText because many browsers support both but\n    // SVG <text> elements don't support innerText even when <div> does.\n    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';\n  }\n  return contentKey;\n}\n\n/**\n * This helper object stores information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */\nvar compositionState = {\n  _root: null,\n  _startText: null,\n  _fallbackText: null\n};\n\nfunction initialize(nativeEventTarget) {\n  compositionState._root = nativeEventTarget;\n  compositionState._startText = getText();\n  return true;\n}\n\nfunction reset() {\n  compositionState._root = null;\n  compositionState._startText = null;\n  compositionState._fallbackText = null;\n}\n\nfunction getData() {\n  if (compositionState._fallbackText) {\n    return compositionState._fallbackText;\n  }\n\n  var start;\n  var startValue = compositionState._startText;\n  var startLength = startValue.length;\n  var end;\n  var endValue = getText();\n  var endLength = endValue.length;\n\n  for (start = 0; start < startLength; start++) {\n    if (startValue[start] !== endValue[start]) {\n      break;\n    }\n  }\n\n  var minEnd = startLength - start;\n  for (end = 1; end <= minEnd; end++) {\n    if (startValue[startLength - end] !== endValue[endLength - end]) {\n      break;\n    }\n  }\n\n  var sliceTail = end > 1 ? 1 - end : undefined;\n  compositionState._fallbackText = endValue.slice(start, sliceTail);\n  return compositionState._fallbackText;\n}\n\nfunction getText() {\n  if ('value' in compositionState._root) {\n    return compositionState._root.value;\n  }\n  return compositionState._root[getTextContentAccessor()];\n}\n\n/* eslint valid-typeof: 0 */\n\nvar didWarnForAddedNewProperty = false;\nvar isProxySupported = typeof Proxy === 'function';\nvar EVENT_POOL_SIZE = 10;\n\nvar shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: emptyFunction$1.thatReturnsNull,\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function (event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === 'target') {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = emptyFunction$1.thatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = emptyFunction$1.thatReturnsFalse;\n  }\n  this.isPropagationStopped = emptyFunction$1.thatReturnsFalse;\n  return this;\n}\n\n_assign(SyntheticEvent.prototype, {\n  preventDefault: function () {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== 'unknown') {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = emptyFunction$1.thatReturnsTrue;\n  },\n\n  stopPropagation: function () {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== 'unknown') {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = emptyFunction$1.thatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function () {\n    this.isPersistent = emptyFunction$1.thatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: emptyFunction$1.thatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function () {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n      }\n    }\n    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {\n      this[shouldBeReleasedProperties[i]] = null;\n    }\n    {\n      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction$1));\n      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction$1));\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n *\n * @param {function} Class\n * @param {?object} Interface\n */\nSyntheticEvent.augmentClass = function (Class, Interface) {\n  var Super = this;\n\n  var E = function () {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  _assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = _assign({}, Super.Interface, Interface);\n  Class.augmentClass = Super.augmentClass;\n  addEventPoolingTo(Class);\n};\n\n/** Proxying after everything set on SyntheticEvent\n * to resolve Proxy issue on some WebKit browsers\n * in which some Event properties are set to undefined (GH#10010)\n */\n{\n  if (isProxySupported) {\n    /*eslint-disable no-func-assign */\n    SyntheticEvent = new Proxy(SyntheticEvent, {\n      construct: function (target, args) {\n        return this.apply(target, Object.create(target.prototype), args);\n      },\n      apply: function (constructor, that, args) {\n        return new Proxy(constructor.apply(that, args), {\n          set: function (target, prop, value) {\n            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {\n              warning(didWarnForAddedNewProperty || target.isPersistent(), \"This synthetic event is reused for performance reasons. If you're \" + \"seeing this, you're adding a new property in the synthetic event object. \" + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.');\n              didWarnForAddedNewProperty = true;\n            }\n            target[prop] = value;\n            return true;\n          }\n        });\n      }\n    });\n    /*eslint-enable no-func-assign */\n  }\n}\n\naddEventPoolingTo(SyntheticEvent);\n\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === 'function';\n  return {\n    configurable: true,\n    set: set,\n    get: get\n  };\n\n  function set(val) {\n    var action = isFunction ? 'setting the method' : 'setting the property';\n    warn(action, 'This is effectively a no-op');\n    return val;\n  }\n\n  function get() {\n    var action = isFunction ? 'accessing the method' : 'accessing the property';\n    var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    warning(warningCondition, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n    return instance;\n  }\n  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\nvar SyntheticEvent$1 = SyntheticEvent;\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */\nvar CompositionEventInterface = {\n  data: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */\nvar InputEventInterface = {\n  data: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticInputEvent, InputEventInterface);\n\nvar END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\nvar START_KEYCODE = 229;\n\nvar canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;\n\nvar documentMode = null;\nif (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {\n  documentMode = document.documentMode;\n}\n\n// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();\n\n// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\n\n/**\n * Opera <= 12 includes TextEvent in window, but does not fire\n * text input events. Rely on keypress instead.\n */\nfunction isPresto() {\n  var opera = window.opera;\n  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;\n}\n\nvar SPACEBAR_CODE = 32;\nvar SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n\n// Events and their corresponding property names.\nvar eventTypes = {\n  beforeInput: {\n    phasedRegistrationNames: {\n      bubbled: 'onBeforeInput',\n      captured: 'onBeforeInputCapture'\n    },\n    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']\n  },\n  compositionEnd: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionEnd',\n      captured: 'onCompositionEndCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  },\n  compositionStart: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionStart',\n      captured: 'onCompositionStartCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  },\n  compositionUpdate: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionUpdate',\n      captured: 'onCompositionUpdateCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  }\n};\n\n// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress = false;\n\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\nfunction isKeypressCommand(nativeEvent) {\n  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\n  // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n  !(nativeEvent.ctrlKey && nativeEvent.altKey);\n}\n\n/**\n * Translate native top level events into event types.\n *\n * @param {string} topLevelType\n * @return {object}\n */\nfunction getCompositionEventType(topLevelType) {\n  switch (topLevelType) {\n    case 'topCompositionStart':\n      return eventTypes.compositionStart;\n    case 'topCompositionEnd':\n      return eventTypes.compositionEnd;\n    case 'topCompositionUpdate':\n      return eventTypes.compositionUpdate;\n  }\n}\n\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionStart(topLevelType, nativeEvent) {\n  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;\n}\n\n/**\n * Does our fallback mode think that this event is the end of composition?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionEnd(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case 'topKeyUp':\n      // Command keys insert or clear IME input.\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n    case 'topKeyDown':\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return nativeEvent.keyCode !== START_KEYCODE;\n    case 'topKeyPress':\n    case 'topMouseDown':\n    case 'topBlur':\n      // Events are not possible without cancelling IME.\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */\nfunction getDataFromCustomEvent(nativeEvent) {\n  var detail = nativeEvent.detail;\n  if (typeof detail === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n  return null;\n}\n\n// Track the current IME composition status, if any.\nvar isComposing = false;\n\n/**\n * @return {?object} A SyntheticCompositionEvent.\n */\nfunction extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var eventType;\n  var fallbackData;\n\n  if (canUseCompositionEvent) {\n    eventType = getCompositionEventType(topLevelType);\n  } else if (!isComposing) {\n    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\n      eventType = eventTypes.compositionStart;\n    }\n  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n    eventType = eventTypes.compositionEnd;\n  }\n\n  if (!eventType) {\n    return null;\n  }\n\n  if (useFallbackCompositionData) {\n    // The current composition is stored statically and must not be\n    // overwritten while composition continues.\n    if (!isComposing && eventType === eventTypes.compositionStart) {\n      isComposing = initialize(nativeEventTarget);\n    } else if (eventType === eventTypes.compositionEnd) {\n      if (isComposing) {\n        fallbackData = getData();\n      }\n    }\n  }\n\n  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);\n\n  if (fallbackData) {\n    // Inject data generated from fallback path into the synthetic event.\n    // This matches the property of native CompositionEventInterface.\n    event.data = fallbackData;\n  } else {\n    var customData = getDataFromCustomEvent(nativeEvent);\n    if (customData !== null) {\n      event.data = customData;\n    }\n  }\n\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The string corresponding to this `beforeInput` event.\n */\nfunction getNativeBeforeInputChars(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case 'topCompositionEnd':\n      return getDataFromCustomEvent(nativeEvent);\n    case 'topKeyPress':\n      /**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */\n      var which = nativeEvent.which;\n      if (which !== SPACEBAR_CODE) {\n        return null;\n      }\n\n      hasSpaceKeypress = true;\n      return SPACEBAR_CHAR;\n\n    case 'topTextInput':\n      // Record the characters to be added to the DOM.\n      var chars = nativeEvent.data;\n\n      // If it's a spacebar character, assume that we have already handled\n      // it at the keypress level and bail immediately. Android Chrome\n      // doesn't give us keycodes, so we need to blacklist it.\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n        return null;\n      }\n\n      return chars;\n\n    default:\n      // For other native event types, do nothing.\n      return null;\n  }\n}\n\n/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The fallback string for this `beforeInput` event.\n */\nfunction getFallbackBeforeInputChars(topLevelType, nativeEvent) {\n  // If we are currently composing (IME) and using a fallback to do so,\n  // try to extract the composed characters from the fallback object.\n  // If composition event is available, we extract a string only at\n  // compositionevent, otherwise extract it at fallback events.\n  if (isComposing) {\n    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n      var chars = getData();\n      reset();\n      isComposing = false;\n      return chars;\n    }\n    return null;\n  }\n\n  switch (topLevelType) {\n    case 'topPaste':\n      // If a paste event occurs after a keypress, throw out the input\n      // chars. Paste events should not lead to BeforeInput events.\n      return null;\n    case 'topKeyPress':\n      /**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */\n      if (!isKeypressCommand(nativeEvent)) {\n        // IE fires the `keypress` event when a user types an emoji via\n        // Touch keyboard of Windows.  In such a case, the `char` property\n        // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n        // is 2, the property `which` does not represent an emoji correctly.\n        // In such a case, we directly return the `char` property instead of\n        // using `which`.\n        if (nativeEvent.char && nativeEvent.char.length > 1) {\n          return nativeEvent.char;\n        } else if (nativeEvent.which) {\n          return String.fromCharCode(nativeEvent.which);\n        }\n      }\n      return null;\n    case 'topCompositionEnd':\n      return useFallbackCompositionData ? null : nativeEvent.data;\n    default:\n      return null;\n  }\n}\n\n/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */\nfunction extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var chars;\n\n  if (canUseTextInputEvent) {\n    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\n  } else {\n    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\n  }\n\n  // If no characters are being inserted, no BeforeInput event should\n  // be fired.\n  if (!chars) {\n    return null;\n  }\n\n  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);\n\n  event.data = chars;\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */\nvar BeforeInputEventPlugin = {\n  eventTypes: eventTypes,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];\n  }\n};\n\n// Use to restore controlled state after a change event has fired.\n\nvar fiberHostComponent = null;\n\nvar ReactControlledComponentInjection = {\n  injectFiberControlledHostComponent: function (hostComponentImpl) {\n    // The fiber implementation doesn't use dynamic dispatch so we need to\n    // inject the implementation.\n    fiberHostComponent = hostComponentImpl;\n  }\n};\n\nvar restoreTarget = null;\nvar restoreQueue = null;\n\nfunction restoreStateOfTarget(target) {\n  // We perform this translation at the end of the event loop so that we\n  // always receive the correct fiber here\n  var internalInstance = getInstanceFromNode(target);\n  if (!internalInstance) {\n    // Unmounted\n    return;\n  }\n  !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\n  fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);\n}\n\nvar injection$3 = ReactControlledComponentInjection;\n\nfunction enqueueStateRestore(target) {\n  if (restoreTarget) {\n    if (restoreQueue) {\n      restoreQueue.push(target);\n    } else {\n      restoreQueue = [target];\n    }\n  } else {\n    restoreTarget = target;\n  }\n}\n\nfunction restoreStateIfNeeded() {\n  if (!restoreTarget) {\n    return;\n  }\n  var target = restoreTarget;\n  var queuedTargets = restoreQueue;\n  restoreTarget = null;\n  restoreQueue = null;\n\n  restoreStateOfTarget(target);\n  if (queuedTargets) {\n    for (var i = 0; i < queuedTargets.length; i++) {\n      restoreStateOfTarget(queuedTargets[i]);\n    }\n  }\n}\n\nvar ReactControlledComponent = Object.freeze({\n\tinjection: injection$3,\n\tenqueueStateRestore: enqueueStateRestore,\n\trestoreStateIfNeeded: restoreStateIfNeeded\n});\n\n// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nvar fiberBatchedUpdates = function (fn, bookkeeping) {\n  return fn(bookkeeping);\n};\n\nvar isNestingBatched = false;\nfunction batchedUpdates(fn, bookkeeping) {\n  if (isNestingBatched) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state. Therefore, we add the target to\n    // a queue of work.\n    return fiberBatchedUpdates(fn, bookkeeping);\n  }\n  isNestingBatched = true;\n  try {\n    return fiberBatchedUpdates(fn, bookkeeping);\n  } finally {\n    // Here we wait until all updates have propagated, which is important\n    // when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    // Then we restore state of any controlled component.\n    isNestingBatched = false;\n    restoreStateIfNeeded();\n  }\n}\n\nvar ReactGenericBatchingInjection = {\n  injectFiberBatchedUpdates: function (_batchedUpdates) {\n    fiberBatchedUpdates = _batchedUpdates;\n  }\n};\n\nvar injection$4 = ReactGenericBatchingInjection;\n\n/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */\nvar supportedInputTypes = {\n  color: true,\n  date: true,\n  datetime: true,\n  'datetime-local': true,\n  email: true,\n  month: true,\n  number: true,\n  password: true,\n  range: true,\n  search: true,\n  tel: true,\n  text: true,\n  time: true,\n  url: true,\n  week: true\n};\n\nfunction isTextInputElement(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n\n  if (nodeName === 'input') {\n    return !!supportedInputTypes[elem.type];\n  }\n\n  if (nodeName === 'textarea') {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * HTML nodeType values that represent the type of the node\n */\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar DOCUMENT_NODE = 9;\nvar DOCUMENT_FRAGMENT_NODE = 11;\n\n/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */\nfunction getEventTarget(nativeEvent) {\n  var target = nativeEvent.target || nativeEvent.srcElement || window;\n\n  // Normalize SVG <use> element events #4963\n  if (target.correspondingUseElement) {\n    target = target.correspondingUseElement;\n  }\n\n  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n  // @see http://www.quirksmode.org/js/events_properties.html\n  return target.nodeType === TEXT_NODE ? target.parentNode : target;\n}\n\nvar useHasFeature;\nif (ExecutionEnvironment.canUseDOM) {\n  useHasFeature = document.implementation && document.implementation.hasFeature &&\n  // always returns true in newer browsers as per the standard.\n  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n  document.implementation.hasFeature('', '') !== true;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix, capture) {\n  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nfunction isCheckable(elem) {\n  var type = elem.type;\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');\n}\n\nfunction getTracker(node) {\n  return node._valueTracker;\n}\n\nfunction detachTracker(node) {\n  node._valueTracker = null;\n}\n\nfunction getValueFromNode(node) {\n  var value = '';\n  if (!node) {\n    return value;\n  }\n\n  if (isCheckable(node)) {\n    value = node.checked ? 'true' : 'false';\n  } else {\n    value = node.value;\n  }\n\n  return value;\n}\n\nfunction trackValueOnNode(node) {\n  var valueField = isCheckable(node) ? 'checked' : 'value';\n  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\n\n  var currentValue = '' + node[valueField];\n\n  // if someone has already defined a value or Safari, then bail\n  // and don't track value will cause over reporting of changes,\n  // but it's better then a hard failure\n  // (needed for certain tests that spyOn input values and Safari)\n  if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {\n    return;\n  }\n\n  Object.defineProperty(node, valueField, {\n    enumerable: descriptor.enumerable,\n    configurable: true,\n    get: function () {\n      return descriptor.get.call(this);\n    },\n    set: function (value) {\n      currentValue = '' + value;\n      descriptor.set.call(this, value);\n    }\n  });\n\n  var tracker = {\n    getValue: function () {\n      return currentValue;\n    },\n    setValue: function (value) {\n      currentValue = '' + value;\n    },\n    stopTracking: function () {\n      detachTracker(node);\n      delete node[valueField];\n    }\n  };\n  return tracker;\n}\n\nfunction track(node) {\n  if (getTracker(node)) {\n    return;\n  }\n\n  // TODO: Once it's just Fiber we can move this to node._wrapperState\n  node._valueTracker = trackValueOnNode(node);\n}\n\nfunction updateValueIfChanged(node) {\n  if (!node) {\n    return false;\n  }\n\n  var tracker = getTracker(node);\n  // if there is no tracker at this point it's unlikely\n  // that trying again will succeed\n  if (!tracker) {\n    return true;\n  }\n\n  var lastValue = tracker.getValue();\n  var nextValue = getValueFromNode(node);\n  if (nextValue !== lastValue) {\n    tracker.setValue(nextValue);\n    return true;\n  }\n  return false;\n}\n\nvar eventTypes$1 = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture'\n    },\n    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']\n  }\n};\n\nfunction createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n  var event = SyntheticEvent$1.getPooled(eventTypes$1.change, inst, nativeEvent, target);\n  event.type = 'change';\n  // Flag this event loop as needing state restore.\n  enqueueStateRestore(target);\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * For IE shims\n */\nvar activeElement = null;\nvar activeElementInst = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  enqueueEvents(event);\n  processEventQueue(false);\n}\n\nfunction getInstIfValueChanged(targetInst) {\n  var targetNode = getNodeFromInstance$1(targetInst);\n  if (updateValueIfChanged(targetNode)) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topChange') {\n    return targetInst;\n  }\n}\n\n/**\n * SECTION: handle `input` event\n */\nvar isInputEventSupported = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\n}\n\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  activeElement = null;\n  activeElementInst = null;\n}\n\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  if (getInstIfValueChanged(activeElementInst)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(topLevelType, targetInst) {\n  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst);\n  }\n}\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topClick') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topInput' || topLevelType === 'topChange') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction handleControlledInputBlur(inst, node) {\n  // TODO: In IE, inst is occasionally null. Why?\n  if (inst == null) {\n    return;\n  }\n\n  // Fiber and ReactDOM keep wrapper state in separate places\n  var state = inst._wrapperState || node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  // If controlled, assign the value attribute to the current value on blur\n  var value = '' + node.value;\n  if (node.getAttribute('value') !== value) {\n    node.setAttribute('value', value);\n  }\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nvar ChangeEventPlugin = {\n  eventTypes: eventTypes$1,\n\n  _isInputEventSupported: isInputEventSupported,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n    var getTargetInstFunc, handleEventFunc;\n    if (shouldUseChangeEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForChangeEvent;\n    } else if (isTextInputElement(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventPolyfill;\n        handleEventFunc = handleEventsForInputEventPolyfill;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n\n    if (getTargetInstFunc) {\n      var inst = getTargetInstFunc(topLevelType, targetInst);\n      if (inst) {\n        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    }\n\n    // When blurring, set the value attribute for number inputs\n    if (topLevelType === 'topBlur') {\n      handleControlledInputBlur(targetInst, targetNode);\n    }\n  }\n};\n\n/**\n * Module that is injectable into `EventPluginHub`, that specifies a\n * deterministic ordering of `EventPlugin`s. A convenient way to reason about\n * plugins, without having to package every one of them. This is better than\n * having plugins be ordered in the same order that they are injected because\n * that ordering would be influenced by the packaging order.\n * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that\n * preventing default on events is convenient in `SimpleEventPlugin` handlers.\n */\nvar DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];\n\n/**\n * @interface UIEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar UIEventInterface = {\n  view: null,\n  detail: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticUIEvent, UIEventInterface);\n\n/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */\n\nvar modifierKeyToProp = {\n  Alt: 'altKey',\n  Control: 'ctrlKey',\n  Meta: 'metaKey',\n  Shift: 'shiftKey'\n};\n\n// IE8 does not implement getModifierState so we simply map it to the only\n// modifier keys exposed by the event itself, does not support Lock-keys.\n// Currently, all major browsers except Chrome seems to support Lock-keys.\nfunction modifierStateGetter(keyArg) {\n  var syntheticEvent = this;\n  var nativeEvent = syntheticEvent.nativeEvent;\n  if (nativeEvent.getModifierState) {\n    return nativeEvent.getModifierState(keyArg);\n  }\n  var keyProp = modifierKeyToProp[keyArg];\n  return keyProp ? !!nativeEvent[keyProp] : false;\n}\n\nfunction getEventModifierState(nativeEvent) {\n  return modifierStateGetter;\n}\n\n/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar MouseEventInterface = {\n  screenX: null,\n  screenY: null,\n  clientX: null,\n  clientY: null,\n  pageX: null,\n  pageY: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  getModifierState: getEventModifierState,\n  button: null,\n  buttons: null,\n  relatedTarget: function (event) {\n    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);\n\nvar eventTypes$2 = {\n  mouseEnter: {\n    registrationName: 'onMouseEnter',\n    dependencies: ['topMouseOut', 'topMouseOver']\n  },\n  mouseLeave: {\n    registrationName: 'onMouseLeave',\n    dependencies: ['topMouseOut', 'topMouseOver']\n  }\n};\n\nvar EnterLeaveEventPlugin = {\n  eventTypes: eventTypes$2,\n\n  /**\n   * For almost every interaction we care about, there will be both a top-level\n   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n   * we do not extract duplicate events. However, moving the mouse into the\n   * browser from outside will not fire a `mouseout` event. In this case, we use\n   * the `mouseover` top-level event.\n   */\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n      return null;\n    }\n    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {\n      // Must not be a mouse in or mouse out - ignoring.\n      return null;\n    }\n\n    var win;\n    if (nativeEventTarget.window === nativeEventTarget) {\n      // `nativeEventTarget` is probably a window object.\n      win = nativeEventTarget;\n    } else {\n      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n      var doc = nativeEventTarget.ownerDocument;\n      if (doc) {\n        win = doc.defaultView || doc.parentWindow;\n      } else {\n        win = window;\n      }\n    }\n\n    var from;\n    var to;\n    if (topLevelType === 'topMouseOut') {\n      from = targetInst;\n      var related = nativeEvent.relatedTarget || nativeEvent.toElement;\n      to = related ? getClosestInstanceFromNode(related) : null;\n    } else {\n      // Moving to a node from outside the window.\n      from = null;\n      to = targetInst;\n    }\n\n    if (from === to) {\n      // Nothing pertains to our managed components.\n      return null;\n    }\n\n    var fromNode = from == null ? win : getNodeFromInstance$1(from);\n    var toNode = to == null ? win : getNodeFromInstance$1(to);\n\n    var leave = SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);\n    leave.type = 'mouseleave';\n    leave.target = fromNode;\n    leave.relatedTarget = toNode;\n\n    var enter = SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);\n    enter.type = 'mouseenter';\n    enter.target = toNode;\n    enter.relatedTarget = fromNode;\n\n    accumulateEnterLeaveDispatches(leave, enter, from, to);\n\n    return [leave, enter];\n  }\n};\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */\n\n\nfunction get(key) {\n  return key._reactInternalFiber;\n}\n\nfunction has(key) {\n  return key._reactInternalFiber !== undefined;\n}\n\nfunction set(key, value) {\n  key._reactInternalFiber = value;\n}\n\nvar ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar ReactCurrentOwner = ReactInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === 'string') {\n    return type;\n  }\n  if (typeof type === 'function') {\n    return type.displayName || type.name;\n  }\n  return null;\n}\n\n// Don't change these two values:\nvar NoEffect = 0; //           0b00000000\nvar PerformedWork = 1; //      0b00000001\n\n// You can change the rest (and add more).\nvar Placement = 2; //          0b00000010\nvar Update = 4; //             0b00000100\nvar PlacementAndUpdate = 6; // 0b00000110\nvar Deletion = 8; //           0b00001000\nvar ContentReset = 16; //      0b00010000\nvar Callback = 32; //          0b00100000\nvar Err = 64; //               0b01000000\nvar Ref = 128; //              0b10000000\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node['return']) {\n      node = node['return'];\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node['return']) {\n      node = node['return'];\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nfunction isFiberMounted(fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.tag === ClassComponent) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a['return'];\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, 'Unable to find node on an unmounted component.');\n    }\n\n    if (a['return'] !== b['return']) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n      }\n    }\n\n    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child['return'] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node['return'] || node['return'] === currentParent) {\n        return null;\n      }\n      node = node['return'];\n    }\n    node.sibling['return'] = node['return'];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child['return'] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node['return'] || node['return'] === currentParent) {\n        return null;\n      }\n      node = node['return'];\n    }\n    node.sibling['return'] = node['return'];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nvar CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\nvar callbackBookkeepingPool = [];\n\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\nfunction findRootContainerNode(inst) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  while (inst['return']) {\n    inst = inst['return'];\n  }\n  if (inst.tag !== HostRoot) {\n    // This can happen if we're in a detached tree.\n    return null;\n  }\n  return inst.stateNode.containerInfo;\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {\n  if (callbackBookkeepingPool.length) {\n    var instance = callbackBookkeepingPool.pop();\n    instance.topLevelType = topLevelType;\n    instance.nativeEvent = nativeEvent;\n    instance.targetInst = targetInst;\n    return instance;\n  }\n  return {\n    topLevelType: topLevelType,\n    nativeEvent: nativeEvent,\n    targetInst: targetInst,\n    ancestors: []\n  };\n}\n\nfunction releaseTopLevelCallbackBookKeeping(instance) {\n  instance.topLevelType = null;\n  instance.nativeEvent = null;\n  instance.targetInst = null;\n  instance.ancestors.length = 0;\n  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n    callbackBookkeepingPool.push(instance);\n  }\n}\n\nfunction handleTopLevelImpl(bookKeeping) {\n  var targetInst = bookKeeping.targetInst;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  var ancestor = targetInst;\n  do {\n    if (!ancestor) {\n      bookKeeping.ancestors.push(ancestor);\n      break;\n    }\n    var root = findRootContainerNode(ancestor);\n    if (!root) {\n      break;\n    }\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = getClosestInstanceFromNode(root);\n  } while (ancestor);\n\n  for (var i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    _handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));\n  }\n}\n\n// TODO: can we stop exporting these?\nvar _enabled = true;\nvar _handleTopLevel = void 0;\n\nfunction setHandleTopLevel(handleTopLevel) {\n  _handleTopLevel = handleTopLevel;\n}\n\nfunction setEnabled(enabled) {\n  _enabled = !!enabled;\n}\n\nfunction isEnabled() {\n  return _enabled;\n}\n\n/**\n * Traps top-level events by using event bubbling.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @param {string} handlerBaseName Event name (e.g. \"click\").\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */\nfunction trapBubbledEvent(topLevelType, handlerBaseName, element) {\n  if (!element) {\n    return null;\n  }\n  return EventListener.listen(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));\n}\n\n/**\n * Traps a top-level event by using event capturing.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @param {string} handlerBaseName Event name (e.g. \"click\").\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */\nfunction trapCapturedEvent(topLevelType, handlerBaseName, element) {\n  if (!element) {\n    return null;\n  }\n  return EventListener.capture(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));\n}\n\nfunction dispatchEvent(topLevelType, nativeEvent) {\n  if (!_enabled) {\n    return;\n  }\n\n  var nativeEventTarget = getEventTarget(nativeEvent);\n  var targetInst = getClosestInstanceFromNode(nativeEventTarget);\n  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {\n    // If we get an event (ex: img onload) before committing that\n    // component's mount, ignore it for now (that is, treat it as if it was an\n    // event on a non-React tree). We might also consider queueing events and\n    // dispatching them after the mount.\n    targetInst = null;\n  }\n\n  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);\n\n  try {\n    // Event queue being processed in the same cycle allows\n    // `preventDefault`.\n    batchedUpdates(handleTopLevelImpl, bookKeeping);\n  } finally {\n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n\nvar ReactDOMEventListener = Object.freeze({\n\tget _enabled () { return _enabled; },\n\tget _handleTopLevel () { return _handleTopLevel; },\n\tsetHandleTopLevel: setHandleTopLevel,\n\tsetEnabled: setEnabled,\n\tisEnabled: isEnabled,\n\ttrapBubbledEvent: trapBubbledEvent,\n\ttrapCapturedEvent: trapCapturedEvent,\n\tdispatchEvent: dispatchEvent\n});\n\n/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */\nfunction makePrefixMap(styleProp, eventName) {\n  var prefixes = {};\n\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n  prefixes['Webkit' + styleProp] = 'webkit' + eventName;\n  prefixes['Moz' + styleProp] = 'moz' + eventName;\n  prefixes['ms' + styleProp] = 'MS' + eventName;\n  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();\n\n  return prefixes;\n}\n\n/**\n * A list of event names to a configurable list of vendor prefixes.\n */\nvar vendorPrefixes = {\n  animationend: makePrefixMap('Animation', 'AnimationEnd'),\n  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),\n  animationstart: makePrefixMap('Animation', 'AnimationStart'),\n  transitionend: makePrefixMap('Transition', 'TransitionEnd')\n};\n\n/**\n * Event names that have already been detected and prefixed (if applicable).\n */\nvar prefixedEventNames = {};\n\n/**\n * Element to check for prefixes on.\n */\nvar style = {};\n\n/**\n * Bootstrap if a DOM exists.\n */\nif (ExecutionEnvironment.canUseDOM) {\n  style = document.createElement('div').style;\n\n  // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are usable, and if not remove them from the map.\n  if (!('AnimationEvent' in window)) {\n    delete vendorPrefixes.animationend.animation;\n    delete vendorPrefixes.animationiteration.animation;\n    delete vendorPrefixes.animationstart.animation;\n  }\n\n  // Same as above\n  if (!('TransitionEvent' in window)) {\n    delete vendorPrefixes.transitionend.transition;\n  }\n}\n\n/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */\nfunction getVendorPrefixedEventName(eventName) {\n  if (prefixedEventNames[eventName]) {\n    return prefixedEventNames[eventName];\n  } else if (!vendorPrefixes[eventName]) {\n    return eventName;\n  }\n\n  var prefixMap = vendorPrefixes[eventName];\n\n  for (var styleProp in prefixMap) {\n    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\n      return prefixedEventNames[eventName] = prefixMap[styleProp];\n    }\n  }\n\n  return '';\n}\n\n/**\n * Types of raw signals from the browser caught at the top level.\n *\n * For events like 'submit' which don't consistently bubble (which we\n * trap at a lower node than `document`), binding at `document` would\n * cause duplicate events so we don't include them here.\n */\nvar topLevelTypes$1 = {\n  topAbort: 'abort',\n  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',\n  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',\n  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',\n  topBlur: 'blur',\n  topCancel: 'cancel',\n  topCanPlay: 'canplay',\n  topCanPlayThrough: 'canplaythrough',\n  topChange: 'change',\n  topClick: 'click',\n  topClose: 'close',\n  topCompositionEnd: 'compositionend',\n  topCompositionStart: 'compositionstart',\n  topCompositionUpdate: 'compositionupdate',\n  topContextMenu: 'contextmenu',\n  topCopy: 'copy',\n  topCut: 'cut',\n  topDoubleClick: 'dblclick',\n  topDrag: 'drag',\n  topDragEnd: 'dragend',\n  topDragEnter: 'dragenter',\n  topDragExit: 'dragexit',\n  topDragLeave: 'dragleave',\n  topDragOver: 'dragover',\n  topDragStart: 'dragstart',\n  topDrop: 'drop',\n  topDurationChange: 'durationchange',\n  topEmptied: 'emptied',\n  topEncrypted: 'encrypted',\n  topEnded: 'ended',\n  topError: 'error',\n  topFocus: 'focus',\n  topInput: 'input',\n  topKeyDown: 'keydown',\n  topKeyPress: 'keypress',\n  topKeyUp: 'keyup',\n  topLoadedData: 'loadeddata',\n  topLoad: 'load',\n  topLoadedMetadata: 'loadedmetadata',\n  topLoadStart: 'loadstart',\n  topMouseDown: 'mousedown',\n  topMouseMove: 'mousemove',\n  topMouseOut: 'mouseout',\n  topMouseOver: 'mouseover',\n  topMouseUp: 'mouseup',\n  topPaste: 'paste',\n  topPause: 'pause',\n  topPlay: 'play',\n  topPlaying: 'playing',\n  topProgress: 'progress',\n  topRateChange: 'ratechange',\n  topScroll: 'scroll',\n  topSeeked: 'seeked',\n  topSeeking: 'seeking',\n  topSelectionChange: 'selectionchange',\n  topStalled: 'stalled',\n  topSuspend: 'suspend',\n  topTextInput: 'textInput',\n  topTimeUpdate: 'timeupdate',\n  topToggle: 'toggle',\n  topTouchCancel: 'touchcancel',\n  topTouchEnd: 'touchend',\n  topTouchMove: 'touchmove',\n  topTouchStart: 'touchstart',\n  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',\n  topVolumeChange: 'volumechange',\n  topWaiting: 'waiting',\n  topWheel: 'wheel'\n};\n\nvar BrowserEventConstants = {\n  topLevelTypes: topLevelTypes$1\n};\n\nfunction runEventQueueInBatch(events) {\n  enqueueEvents(events);\n  processEventQueue(false);\n}\n\n/**\n * Streams a fired top-level event to `EventPluginHub` where plugins have the\n * opportunity to create `ReactEvent`s to be dispatched.\n */\nfunction handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n  runEventQueueInBatch(events);\n}\n\nvar topLevelTypes = BrowserEventConstants.topLevelTypes;\n\n/**\n * Summary of `ReactBrowserEventEmitter` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactDOMEventListener, which is injected and can therefore support\n *    pluggable event sources. This is the only work that occurs in the main\n *    thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginHub` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginHub` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n\nvar alreadyListeningTo = {};\nvar reactTopListenersCounter = 0;\n\n/**\n * To ensure no conflicts with other potential React instances on the page\n */\nvar topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);\n\nfunction getListeningForDocument(mountAt) {\n  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`\n  // directly.\n  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {\n    mountAt[topListenersIDKey] = reactTopListenersCounter++;\n    alreadyListeningTo[mountAt[topListenersIDKey]] = {};\n  }\n  return alreadyListeningTo[mountAt[topListenersIDKey]];\n}\n\n/**\n * We listen for bubbled touch events on the document object.\n *\n * Firefox v8.01 (and possibly others) exhibited strange behavior when\n * mounting `onmousemove` events at some node that was not the document\n * element. The symptoms were that if your mouse is not moving over something\n * contained within that mount point (for example on the background) the\n * top-level listeners for `onmousemove` won't be called. However, if you\n * register the `mousemove` on the document object, then it will of course\n * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n * top-level listeners to the document object only, at least for these\n * movement types of events and possibly all events.\n *\n * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n *\n * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n * they bubble to document.\n *\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @param {object} contentDocumentHandle Document which owns the container\n */\nfunction listenTo(registrationName, contentDocumentHandle) {\n  var mountAt = contentDocumentHandle;\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      if (dependency === 'topWheel') {\n        if (isEventSupported('wheel')) {\n          trapBubbledEvent('topWheel', 'wheel', mountAt);\n        } else if (isEventSupported('mousewheel')) {\n          trapBubbledEvent('topWheel', 'mousewheel', mountAt);\n        } else {\n          // Firefox needs to capture a different mouse scroll event.\n          // @see http://www.quirksmode.org/dom/events/tests/scroll.html\n          trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);\n        }\n      } else if (dependency === 'topScroll') {\n        trapCapturedEvent('topScroll', 'scroll', mountAt);\n      } else if (dependency === 'topFocus' || dependency === 'topBlur') {\n        trapCapturedEvent('topFocus', 'focus', mountAt);\n        trapCapturedEvent('topBlur', 'blur', mountAt);\n\n        // to make sure blur and focus event listeners are only attached once\n        isListening.topBlur = true;\n        isListening.topFocus = true;\n      } else if (dependency === 'topCancel') {\n        if (isEventSupported('cancel', true)) {\n          trapCapturedEvent('topCancel', 'cancel', mountAt);\n        }\n        isListening.topCancel = true;\n      } else if (dependency === 'topClose') {\n        if (isEventSupported('close', true)) {\n          trapCapturedEvent('topClose', 'close', mountAt);\n        }\n        isListening.topClose = true;\n      } else if (topLevelTypes.hasOwnProperty(dependency)) {\n        trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);\n      }\n\n      isListening[dependency] = true;\n    }\n  }\n}\n\nfunction isListeningToAllDependencies(registrationName, mountAt) {\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */\nfunction getLeafNode(node) {\n  while (node && node.firstChild) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */\nfunction getSiblingNode(node) {\n  while (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    node = node.parentNode;\n  }\n}\n\n/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  var nodeStart = 0;\n  var nodeEnd = 0;\n\n  while (node) {\n    if (node.nodeType === TEXT_NODE) {\n      nodeEnd = nodeStart + node.textContent.length;\n\n      if (nodeStart <= offset && nodeEnd >= offset) {\n        return {\n          node: node,\n          offset: offset - nodeStart\n        };\n      }\n\n      nodeStart = nodeEnd;\n    }\n\n    node = getLeafNode(getSiblingNode(node));\n  }\n}\n\n/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */\nfunction getOffsets(outerNode) {\n  var selection = window.getSelection && window.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  var anchorNode = selection.anchorNode;\n  var anchorOffset = selection.anchorOffset;\n  var focusNode$$1 = selection.focusNode;\n  var focusOffset = selection.focusOffset;\n\n  // In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n  // up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n  // expose properties, triggering a \"Permission denied error\" if any of its\n  // properties are accessed. The only seemingly possible way to avoid erroring\n  // is to access a property that typically works for non-anonymous divs and\n  // catch any error that may otherwise arise. See\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n  try {\n    /* eslint-disable no-unused-expressions */\n    anchorNode.nodeType;\n    focusNode$$1.nodeType;\n    /* eslint-enable no-unused-expressions */\n  } catch (e) {\n    return null;\n  }\n\n  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset);\n}\n\n/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */\nfunction getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset) {\n  var length = 0;\n  var start = -1;\n  var end = -1;\n  var indexWithinAnchor = 0;\n  var indexWithinFocus = 0;\n  var node = outerNode;\n  var parentNode = null;\n\n  outer: while (true) {\n    var next = null;\n\n    while (true) {\n      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\n        start = length + anchorOffset;\n      }\n      if (node === focusNode$$1 && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\n        end = length + focusOffset;\n      }\n\n      if (node.nodeType === TEXT_NODE) {\n        length += node.nodeValue.length;\n      }\n\n      if ((next = node.firstChild) === null) {\n        break;\n      }\n      // Moving from `node` to its first child `next`.\n      parentNode = node;\n      node = next;\n    }\n\n    while (true) {\n      if (node === outerNode) {\n        // If `outerNode` has children, this is always the second time visiting\n        // it. If it has no children, this is still the first loop, and the only\n        // valid selection is anchorNode and focusNode both equal to this node\n        // and both offsets 0, in which case we will have handled above.\n        break outer;\n      }\n      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\n        start = length;\n      }\n      if (parentNode === focusNode$$1 && ++indexWithinFocus === focusOffset) {\n        end = length;\n      }\n      if ((next = node.nextSibling) !== null) {\n        break;\n      }\n      node = parentNode;\n      parentNode = node.parentNode;\n    }\n\n    // Moving from `node` to its next sibling `next`.\n    node = next;\n  }\n\n  if (start === -1 || end === -1) {\n    // This should never happen. (Would happen if the anchor/focus nodes aren't\n    // actually inside the passed-in node.)\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\n/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setOffsets(node, offsets) {\n  if (!window.getSelection) {\n    return;\n  }\n\n  var selection = window.getSelection();\n  var length = node[getTextContentAccessor()].length;\n  var start = Math.min(offsets.start, length);\n  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);\n\n  // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n  if (!selection.extend && start > end) {\n    var temp = end;\n    end = start;\n    start = temp;\n  }\n\n  var startMarker = getNodeForCharacterOffset(node, start);\n  var endMarker = getNodeForCharacterOffset(node, end);\n\n  if (startMarker && endMarker) {\n    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\n      return;\n    }\n    var range = document.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}\n\nfunction isInDocument(node) {\n  return containsNode(document.documentElement, node);\n}\n\n/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */\n\nfunction hasSelectionCapabilities(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');\n}\n\nfunction getSelectionInformation() {\n  var focusedElem = getActiveElement();\n  return {\n    focusedElem: focusedElem,\n    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null\n  };\n}\n\n/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */\nfunction restoreSelection(priorSelectionInformation) {\n  var curFocusedElem = getActiveElement();\n  var priorFocusedElem = priorSelectionInformation.focusedElem;\n  var priorSelectionRange = priorSelectionInformation.selectionRange;\n  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n    if (hasSelectionCapabilities(priorFocusedElem)) {\n      setSelection(priorFocusedElem, priorSelectionRange);\n    }\n\n    // Focusing a node can change the scroll position, which is undesirable\n    var ancestors = [];\n    var ancestor = priorFocusedElem;\n    while (ancestor = ancestor.parentNode) {\n      if (ancestor.nodeType === ELEMENT_NODE) {\n        ancestors.push({\n          element: ancestor,\n          left: ancestor.scrollLeft,\n          top: ancestor.scrollTop\n        });\n      }\n    }\n\n    focusNode(priorFocusedElem);\n\n    for (var i = 0; i < ancestors.length; i++) {\n      var info = ancestors[i];\n      info.element.scrollLeft = info.left;\n      info.element.scrollTop = info.top;\n    }\n  }\n}\n\n/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */\nfunction getSelection$1(input) {\n  var selection = void 0;\n\n  if ('selectionStart' in input) {\n    // Modern browser with input or textarea.\n    selection = {\n      start: input.selectionStart,\n      end: input.selectionEnd\n    };\n  } else {\n    // Content editable or old IE textarea.\n    selection = getOffsets(input);\n  }\n\n  return selection || { start: 0, end: 0 };\n}\n\n/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */\nfunction setSelection(input, offsets) {\n  var start = offsets.start,\n      end = offsets.end;\n\n  if (end === undefined) {\n    end = start;\n  }\n\n  if ('selectionStart' in input) {\n    input.selectionStart = start;\n    input.selectionEnd = Math.min(end, input.value.length);\n  } else {\n    setOffsets(input, offsets);\n  }\n}\n\nvar skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;\n\nvar eventTypes$3 = {\n  select: {\n    phasedRegistrationNames: {\n      bubbled: 'onSelect',\n      captured: 'onSelectCapture'\n    },\n    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']\n  }\n};\n\nvar activeElement$1 = null;\nvar activeElementInst$1 = null;\nvar lastSelection = null;\nvar mouseDown = false;\n\n/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n *\n * @param {DOMElement} node\n * @return {object}\n */\nfunction getSelection(node) {\n  if ('selectionStart' in node && hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd\n    };\n  } else if (window.getSelection) {\n    var selection = window.getSelection();\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset\n    };\n  }\n}\n\n/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @return {?SyntheticEvent}\n */\nfunction constructSelectEvent(nativeEvent, nativeEventTarget) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {\n    return null;\n  }\n\n  // Only fire when selection has actually changed.\n  var currentSelection = getSelection(activeElement$1);\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n\n    var syntheticEvent = SyntheticEvent$1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);\n\n    syntheticEvent.type = 'select';\n    syntheticEvent.target = activeElement$1;\n\n    accumulateTwoPhaseDispatches(syntheticEvent);\n\n    return syntheticEvent;\n  }\n\n  return null;\n}\n\n/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */\nvar SelectEventPlugin = {\n  eventTypes: eventTypes$3,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE ? nativeEventTarget : nativeEventTarget.ownerDocument;\n    // Track whether all listeners exists for this plugin. If none exist, we do\n    // not extract events. See #3639.\n    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {\n      return null;\n    }\n\n    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n    switch (topLevelType) {\n      // Track the input node that has focus.\n      case 'topFocus':\n        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {\n          activeElement$1 = targetNode;\n          activeElementInst$1 = targetInst;\n          lastSelection = null;\n        }\n        break;\n      case 'topBlur':\n        activeElement$1 = null;\n        activeElementInst$1 = null;\n        lastSelection = null;\n        break;\n      // Don't fire the event while the user is dragging. This matches the\n      // semantics of the native select event.\n      case 'topMouseDown':\n        mouseDown = true;\n        break;\n      case 'topContextMenu':\n      case 'topMouseUp':\n        mouseDown = false;\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n      // Chrome and IE fire non-standard event when selection is changed (and\n      // sometimes when it hasn't). IE's event fires out of order with respect\n      // to key and input events on deletion, so we discard it.\n      //\n      // Firefox doesn't support selectionchange, so check selection status\n      // after each key entry. The selection changes after keydown and before\n      // keyup, but we check on keydown as well in the case of holding down a\n      // key, when multiple keydown events are fired but only one keyup is.\n      // This is also our approach for IE handling, for the reason above.\n      case 'topSelectionChange':\n        if (skipSelectionChangeEvent) {\n          break;\n        }\n      // falls through\n      case 'topKeyDown':\n      case 'topKeyUp':\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n    }\n\n    return null;\n  }\n};\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */\nvar AnimationEventInterface = {\n  animationName: null,\n  elapsedTime: null,\n  pseudoElement: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */\nvar ClipboardEventInterface = {\n  clipboardData: function (event) {\n    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);\n\n/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar FocusEventInterface = {\n  relatedTarget: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);\n\n/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */\nfunction getEventCharCode(nativeEvent) {\n  var charCode;\n  var keyCode = nativeEvent.keyCode;\n\n  if ('charCode' in nativeEvent) {\n    charCode = nativeEvent.charCode;\n\n    // FF does not set `charCode` for the Enter-key, check against `keyCode`.\n    if (charCode === 0 && keyCode === 13) {\n      charCode = 13;\n    }\n  } else {\n    // IE8 does not implement `charCode`, but `keyCode` has the correct value.\n    charCode = keyCode;\n  }\n\n  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n  // Must not discard the (non-)printable Enter-key.\n  if (charCode >= 32 || charCode === 13) {\n    return charCode;\n  }\n\n  return 0;\n}\n\n/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar normalizeKey = {\n  Esc: 'Escape',\n  Spacebar: ' ',\n  Left: 'ArrowLeft',\n  Up: 'ArrowUp',\n  Right: 'ArrowRight',\n  Down: 'ArrowDown',\n  Del: 'Delete',\n  Win: 'OS',\n  Menu: 'ContextMenu',\n  Apps: 'ContextMenu',\n  Scroll: 'ScrollLock',\n  MozPrintableKey: 'Unidentified'\n};\n\n/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar translateToKey = {\n  '8': 'Backspace',\n  '9': 'Tab',\n  '12': 'Clear',\n  '13': 'Enter',\n  '16': 'Shift',\n  '17': 'Control',\n  '18': 'Alt',\n  '19': 'Pause',\n  '20': 'CapsLock',\n  '27': 'Escape',\n  '32': ' ',\n  '33': 'PageUp',\n  '34': 'PageDown',\n  '35': 'End',\n  '36': 'Home',\n  '37': 'ArrowLeft',\n  '38': 'ArrowUp',\n  '39': 'ArrowRight',\n  '40': 'ArrowDown',\n  '45': 'Insert',\n  '46': 'Delete',\n  '112': 'F1',\n  '113': 'F2',\n  '114': 'F3',\n  '115': 'F4',\n  '116': 'F5',\n  '117': 'F6',\n  '118': 'F7',\n  '119': 'F8',\n  '120': 'F9',\n  '121': 'F10',\n  '122': 'F11',\n  '123': 'F12',\n  '144': 'NumLock',\n  '145': 'ScrollLock',\n  '224': 'Meta'\n};\n\n/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */\nfunction getEventKey(nativeEvent) {\n  if (nativeEvent.key) {\n    // Normalize inconsistent values reported by browsers due to\n    // implementations of a working draft specification.\n\n    // FireFox implements `key` but returns `MozPrintableKey` for all\n    // printable characters (normalized to `Unidentified`), ignore it.\n    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n    if (key !== 'Unidentified') {\n      return key;\n    }\n  }\n\n  // Browser does not implement `key`, polyfill as much of it as we can.\n  if (nativeEvent.type === 'keypress') {\n    var charCode = getEventCharCode(nativeEvent);\n\n    // The enter-key is technically both printable and non-printable and can\n    // thus be captured by `keypress`, no other non-printable key should.\n    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);\n  }\n  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {\n    // While user keyboard layout determines the actual meaning of each\n    // `keyCode` value, almost all function keys have a universal value.\n    return translateToKey[nativeEvent.keyCode] || 'Unidentified';\n  }\n  return '';\n}\n\n/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar KeyboardEventInterface = {\n  key: getEventKey,\n  location: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  repeat: null,\n  locale: null,\n  getModifierState: getEventModifierState,\n  // Legacy Interface\n  charCode: function (event) {\n    // `charCode` is the result of a KeyPress event and represents the value of\n    // the actual printable character.\n\n    // KeyPress is deprecated, but its replacement is not yet final and not\n    // implemented in any major browser. Only KeyPress has charCode.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    return 0;\n  },\n  keyCode: function (event) {\n    // `keyCode` is the result of a KeyDown/Up event and represents the value of\n    // physical keyboard key.\n\n    // The actual meaning of the value depends on the users' keyboard layout\n    // which cannot be detected. Assuming that it is a US keyboard layout\n    // provides a surprisingly accurate mapping for US and European users.\n    // Due to this, it is left to the user to implement at this time.\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  },\n  which: function (event) {\n    // `which` is an alias for either `keyCode` or `charCode` depending on the\n    // type of the event.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);\n\n/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar DragEventInterface = {\n  dataTransfer: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticMouseEvent}\n */\nfunction SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);\n\n/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */\nvar TouchEventInterface = {\n  touches: null,\n  targetTouches: null,\n  changedTouches: null,\n  altKey: null,\n  metaKey: null,\n  ctrlKey: null,\n  shiftKey: null,\n  getModifierState: getEventModifierState\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */\nvar TransitionEventInterface = {\n  propertyName: null,\n  elapsedTime: null,\n  pseudoElement: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);\n\n/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar WheelEventInterface = {\n  deltaX: function (event) {\n    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;\n  },\n  deltaY: function (event) {\n    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n    'wheelDelta' in event ? -event.wheelDelta : 0;\n  },\n  deltaZ: null,\n\n  // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n  // notch on the scroll is always +/- 120, roughly equivalent to pixels.\n  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n  deltaMode: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticMouseEvent}\n */\nfunction SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);\n\n/**\n * Turns\n * ['abort', ...]\n * into\n * eventTypes = {\n *   'abort': {\n *     phasedRegistrationNames: {\n *       bubbled: 'onAbort',\n *       captured: 'onAbortCapture',\n *     },\n *     dependencies: ['topAbort'],\n *   },\n *   ...\n * };\n * topLevelEventsToDispatchConfig = {\n *   'topAbort': { sameConfig }\n * };\n */\nvar eventTypes$4 = {};\nvar topLevelEventsToDispatchConfig = {};\n['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'cancel', 'canPlay', 'canPlayThrough', 'click', 'close', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'toggle', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {\n  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);\n  var onEvent = 'on' + capitalizedEvent;\n  var topEvent = 'top' + capitalizedEvent;\n\n  var type = {\n    phasedRegistrationNames: {\n      bubbled: onEvent,\n      captured: onEvent + 'Capture'\n    },\n    dependencies: [topEvent]\n  };\n  eventTypes$4[event] = type;\n  topLevelEventsToDispatchConfig[topEvent] = type;\n});\n\n// Only used in DEV for exhaustiveness validation.\nvar knownHTMLTopLevelTypes = ['topAbort', 'topCancel', 'topCanPlay', 'topCanPlayThrough', 'topClose', 'topDurationChange', 'topEmptied', 'topEncrypted', 'topEnded', 'topError', 'topInput', 'topInvalid', 'topLoad', 'topLoadedData', 'topLoadedMetadata', 'topLoadStart', 'topPause', 'topPlay', 'topPlaying', 'topProgress', 'topRateChange', 'topReset', 'topSeeked', 'topSeeking', 'topStalled', 'topSubmit', 'topSuspend', 'topTimeUpdate', 'topToggle', 'topVolumeChange', 'topWaiting'];\n\nvar SimpleEventPlugin = {\n  eventTypes: eventTypes$4,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];\n    if (!dispatchConfig) {\n      return null;\n    }\n    var EventConstructor;\n    switch (topLevelType) {\n      case 'topKeyPress':\n        // Firefox creates a keypress event for function keys too. This removes\n        // the unwanted keypress events. Enter is however both printable and\n        // non-printable. One would expect Tab to be as well (but it isn't).\n        if (getEventCharCode(nativeEvent) === 0) {\n          return null;\n        }\n      /* falls through */\n      case 'topKeyDown':\n      case 'topKeyUp':\n        EventConstructor = SyntheticKeyboardEvent;\n        break;\n      case 'topBlur':\n      case 'topFocus':\n        EventConstructor = SyntheticFocusEvent;\n        break;\n      case 'topClick':\n        // Firefox creates a click event on right mouse clicks. This removes the\n        // unwanted click events.\n        if (nativeEvent.button === 2) {\n          return null;\n        }\n      /* falls through */\n      case 'topDoubleClick':\n      case 'topMouseDown':\n      case 'topMouseMove':\n      case 'topMouseUp':\n      // TODO: Disabled elements should not respond to mouse events\n      /* falls through */\n      case 'topMouseOut':\n      case 'topMouseOver':\n      case 'topContextMenu':\n        EventConstructor = SyntheticMouseEvent;\n        break;\n      case 'topDrag':\n      case 'topDragEnd':\n      case 'topDragEnter':\n      case 'topDragExit':\n      case 'topDragLeave':\n      case 'topDragOver':\n      case 'topDragStart':\n      case 'topDrop':\n        EventConstructor = SyntheticDragEvent;\n        break;\n      case 'topTouchCancel':\n      case 'topTouchEnd':\n      case 'topTouchMove':\n      case 'topTouchStart':\n        EventConstructor = SyntheticTouchEvent;\n        break;\n      case 'topAnimationEnd':\n      case 'topAnimationIteration':\n      case 'topAnimationStart':\n        EventConstructor = SyntheticAnimationEvent;\n        break;\n      case 'topTransitionEnd':\n        EventConstructor = SyntheticTransitionEvent;\n        break;\n      case 'topScroll':\n        EventConstructor = SyntheticUIEvent;\n        break;\n      case 'topWheel':\n        EventConstructor = SyntheticWheelEvent;\n        break;\n      case 'topCopy':\n      case 'topCut':\n      case 'topPaste':\n        EventConstructor = SyntheticClipboardEvent;\n        break;\n      default:\n        {\n          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {\n            warning(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);\n          }\n        }\n        // HTML Events\n        // @see http://www.w3.org/TR/html5/index.html#events-0\n        EventConstructor = SyntheticEvent$1;\n        break;\n    }\n    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);\n    accumulateTwoPhaseDispatches(event);\n    return event;\n  }\n};\n\nsetHandleTopLevel(handleTopLevel);\n\n/**\n * Inject modules for resolving DOM hierarchy and plugin ordering.\n */\ninjection$1.injectEventPluginOrder(DOMEventPluginOrder);\ninjection$2.injectComponentTree(ReactDOMComponentTree);\n\n/**\n * Some important event plugins included by default (without having to require\n * them).\n */\ninjection$1.injectEventPluginsByName({\n  SimpleEventPlugin: SimpleEventPlugin,\n  EnterLeaveEventPlugin: EnterLeaveEventPlugin,\n  ChangeEventPlugin: ChangeEventPlugin,\n  SelectEventPlugin: SelectEventPlugin,\n  BeforeInputEventPlugin: BeforeInputEventPlugin\n});\n\nvar enableAsyncSubtreeAPI = true;\nvar enableAsyncSchedulingByDefaultInReactDOM = false;\n// Exports React.Fragment\nvar enableReactFragment = false;\n// Exports ReactDOM.createRoot\nvar enableCreateRoot = false;\nvar enableUserTimingAPI = true;\n\n// Mutating mode (React DOM, React ART, React Native):\nvar enableMutatingReconciler = true;\n// Experimental noop mode (currently unused):\nvar enableNoopReconciler = false;\n// Experimental persistent mode (CS):\nvar enablePersistentReconciler = false;\n\n// Only used in www builds.\n\nvar valueStack = [];\n\n{\n  var fiberStack = [];\n}\n\nvar index = -1;\n\nfunction createCursor(defaultValue) {\n  return {\n    current: defaultValue\n  };\n}\n\n\n\nfunction pop(cursor, fiber) {\n  if (index < 0) {\n    {\n      warning(false, 'Unexpected pop.');\n    }\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      warning(false, 'Unexpected Fiber popped.');\n    }\n  }\n\n  cursor.current = valueStack[index];\n\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n}\n\nfunction push(cursor, value, fiber) {\n  index++;\n\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n}\n\nfunction reset$1() {\n  while (index > -1) {\n    valueStack[index] = null;\n\n    {\n      fiberStack[index] = null;\n    }\n\n    index--;\n  }\n}\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n};\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case ClassComponent:\n    case HostComponent:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName(fiber);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return '';\n  }\n}\n\n// This function can only be called with a work-in-progress fiber and\n// only during begin or complete phase. Do not call it under any other\n// circumstances.\nfunction getStackAddendumByWorkInProgressFiber(workInProgress) {\n  var info = '';\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    // Otherwise this return pointer might point to the wrong tree:\n    node = node['return'];\n  } while (node);\n  return info;\n}\n\nfunction getCurrentFiberOwnerName() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    var owner = fiber._debugOwner;\n    if (owner !== null && typeof owner !== 'undefined') {\n      return getComponentName(owner);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackAddendum() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackAddendumByWorkInProgressFiber(fiber);\n  }\n  return null;\n}\n\nfunction resetCurrentFiber() {\n  ReactDebugCurrentFrame.getCurrentStack = null;\n  ReactDebugCurrentFiber.current = null;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentFiber(fiber) {\n  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;\n  ReactDebugCurrentFiber.current = fiber;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentPhase(phase) {\n  ReactDebugCurrentFiber.phase = phase;\n}\n\nvar ReactDebugCurrentFiber = {\n  current: null,\n  phase: null,\n  resetCurrentFiber: resetCurrentFiber,\n  setCurrentFiber: setCurrentFiber,\n  setCurrentPhase: setCurrentPhase,\n  getCurrentFiberOwnerName: getCurrentFiberOwnerName,\n  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum\n};\n\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nvar reactEmoji = '\\u269B';\nvar warningEmoji = '\\u26D4';\nvar supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\n// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nvar currentFiber = null;\n// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nvar currentPhase = null;\nvar currentPhaseFiber = null;\n// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nvar isCommitting = false;\nvar hasScheduledUpdateInCurrentCommit = false;\nvar hasScheduledUpdateInCurrentPhase = false;\nvar commitCountInCurrentWorkLoop = 0;\nvar effectCountInCurrentCommit = 0;\nvar isWaitingForCallback = false;\n// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nvar labelsInCurrentCommit = new Set();\n\nvar formatMarkName = function (markName) {\n  return reactEmoji + ' ' + markName;\n};\n\nvar formatLabel = function (label, warning$$1) {\n  var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';\n  var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';\n  return '' + prefix + label + suffix;\n};\n\nvar beginMark = function (markName) {\n  performance.mark(formatMarkName(markName));\n};\n\nvar clearMark = function (markName) {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nvar endMark = function (label, markName, warning$$1) {\n  var formattedMarkName = formatMarkName(markName);\n  var formattedLabel = formatLabel(label, warning$$1);\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {}\n  // If previous mark was missing for some reason, this will throw.\n  // This could only happen if React crashed in an unexpected place earlier.\n  // Don't pile on with more errors.\n\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nvar getFiberMarkName = function (label, debugID) {\n  return label + ' (#' + debugID + ')';\n};\n\nvar getFiberLabel = function (componentName, isMounted, phase) {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';\n  } else {\n    // Composite component methods.\n    return componentName + '.' + phase;\n  }\n};\n\nvar beginFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n  labelsInCurrentCommit.add(label);\n\n  var markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nvar clearFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nvar endFiberMark = function (fiber, phase, warning$$1) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning$$1);\n};\n\nvar shouldIgnoreFiber = function (fiber) {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case ReturnComponent:\n    case Fragment:\n      return true;\n    default:\n      return false;\n  }\n};\n\nvar clearPendingPhaseMeasurement = function () {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nvar pauseTimers = function () {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  var fiber = currentFiber;\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n    fiber = fiber['return'];\n  }\n};\n\nvar resumeTimersRecursively = function (fiber) {\n  if (fiber['return'] !== null) {\n    resumeTimersRecursively(fiber['return']);\n  }\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nvar resumeTimers = function () {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nfunction recordEffect() {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\n\nfunction recordScheduleUpdate() {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\n\nfunction startRequestCallbackTimer() {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark('(Waiting for async callback...)');\n    }\n  }\n}\n\nfunction stopRequestCallbackTimer(didExpire) {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      var warning$$1 = didExpire ? 'React was blocked by main thread' : null;\n      endMark('(Waiting for async callback...)', '(Waiting for async callback...)', warning$$1);\n    }\n  }\n}\n\nfunction startWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, this is the fiber to unwind from.\n    currentFiber = fiber;\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\n\nfunction cancelWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\n\nfunction stopWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber['return'];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\n\nfunction stopFailedWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber['return'];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    var warning$$1 = 'An error was thrown inside this error boundary';\n    endFiberMark(fiber, null, warning$$1);\n  }\n}\n\nfunction startPhaseTimer(fiber, phase) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    clearPendingPhaseMeasurement();\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\n\nfunction stopPhaseTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);\n    }\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\n\nfunction startWorkLoopTimer(nextUnitOfWork) {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n    if (!supportsUserTiming) {\n      return;\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // This is top level call.\n    // Any other measurements are performed within.\n    beginMark('(React Tree Reconciliation)');\n    // Resume any measurements that were in progress during the last loop.\n    resumeTimers();\n  }\n}\n\nfunction stopWorkLoopTimer(interruptedBy) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var warning$$1 = null;\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning$$1 = 'A top-level update interrupted the previous render';\n      } else {\n        var componentName = getComponentName(interruptedBy) || 'Unknown';\n        warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning$$1 = 'There were cascading updates';\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // Pause any measurements until the next loop.\n    pauseTimers();\n    endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);\n  }\n}\n\nfunction startCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark('(Committing Changes)');\n  }\n}\n\nfunction stopCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    var warning$$1 = null;\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning$$1 = 'Lifecycle hook scheduled a cascading update';\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning$$1 = 'Caused by a cascading update in earlier commit';\n    }\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n\n    endMark('(Committing Changes)', '(Committing Changes)', warning$$1);\n  }\n}\n\nfunction startCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Host Effects)');\n  }\n}\n\nfunction stopCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);\n  }\n}\n\nfunction startCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Calling Lifecycle Methods)');\n  }\n}\n\nfunction stopCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);\n  }\n}\n\n{\n  var warnedAboutMissingGetChildContext = {};\n}\n\n// A cursor to the current merged context object on the stack.\nvar contextStackCursor = createCursor(emptyObject);\n// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext = emptyObject;\n\nfunction getUnmaskedContext(workInProgress) {\n  var hasOwnContext = isContextProvider(workInProgress);\n  if (hasOwnContext) {\n    // If the fiber is a context provider itself, when we read its context\n    // we have already pushed its own child context on the stack. A context\n    // provider should not \"see\" its own child context. Therefore we read the\n    // previous (parent) context instead for a context provider.\n    return previousContext;\n  }\n  return contextStackCursor.current;\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  var instance = workInProgress.stateNode;\n  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  var type = workInProgress.type;\n  var contextTypes = type.contextTypes;\n  if (!contextTypes) {\n    return emptyObject;\n  }\n\n  // Avoid recreating masked context unless unmasked context has changed.\n  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n  // This may trigger infinite loops if componentWillReceiveProps calls setState.\n  var instance = workInProgress.stateNode;\n  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n    return instance.__reactInternalMemoizedMaskedChildContext;\n  }\n\n  var context = {};\n  for (var key in contextTypes) {\n    context[key] = unmaskedContext[key];\n  }\n\n  {\n    var name = getComponentName(workInProgress) || 'Unknown';\n    checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // Context is created before the class component is instantiated so check for instance.\n  if (instance) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return context;\n}\n\nfunction hasContextChanged() {\n  return didPerformWorkStackCursor.current;\n}\n\nfunction isContextConsumer(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n}\n\nfunction isContextProvider(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n}\n\nfunction popContextProvider(fiber) {\n  if (!isContextProvider(fiber)) {\n    return;\n  }\n\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction popTopLevelContextObject(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  push(contextStackCursor, context, fiber);\n  push(didPerformWorkStackCursor, didChange, fiber);\n}\n\nfunction processChildContext(fiber, parentContext) {\n  var instance = fiber.stateNode;\n  var childContextTypes = fiber.type.childContextTypes;\n\n  // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n  // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n  if (typeof instance.getChildContext !== 'function') {\n    {\n      var componentName = getComponentName(fiber) || 'Unknown';\n\n      if (!warnedAboutMissingGetChildContext[componentName]) {\n        warnedAboutMissingGetChildContext[componentName] = true;\n        warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n      }\n    }\n    return parentContext;\n  }\n\n  var childContext = void 0;\n  {\n    ReactDebugCurrentFiber.setCurrentPhase('getChildContext');\n  }\n  startPhaseTimer(fiber, 'getChildContext');\n  childContext = instance.getChildContext();\n  stopPhaseTimer();\n  {\n    ReactDebugCurrentFiber.setCurrentPhase(null);\n  }\n  for (var contextKey in childContext) {\n    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;\n  }\n  {\n    var name = getComponentName(fiber) || 'Unknown';\n    checkPropTypes(childContextTypes, childContext, 'child context', name,\n    // In practice, there is one case in which we won't get a stack. It's when\n    // somebody calls unstable_renderSubtreeIntoContainer() and we process\n    // context from the parent component instance. The stack will be missing\n    // because it's outside of the reconciliation, and so the pointer has not\n    // been set. This is rare and doesn't matter. We'll also remove that API.\n    ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n  }\n\n  return _assign({}, parentContext, childContext);\n}\n\nfunction pushContextProvider(workInProgress) {\n  if (!isContextProvider(workInProgress)) {\n    return false;\n  }\n\n  var instance = workInProgress.stateNode;\n  // We push the context as early as possible to ensure stack integrity.\n  // If the instance does not exist yet, we will push null at first,\n  // and replace it on the stack later when invalidating the context.\n  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;\n\n  // Remember the parent context so we can merge with it later.\n  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n  previousContext = contextStackCursor.current;\n  push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n\n  return true;\n}\n\nfunction invalidateContextProvider(workInProgress, didChange) {\n  var instance = workInProgress.stateNode;\n  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  if (didChange) {\n    // Merge parent and own context.\n    // Skip this if we're not updating due to sCU.\n    // This avoids unnecessarily recomputing memoized values.\n    var mergedContext = processChildContext(workInProgress, previousContext);\n    instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n    // Replace the old (or empty) context with the new one.\n    // It is important to unwind the context in the reverse order.\n    pop(didPerformWorkStackCursor, workInProgress);\n    pop(contextStackCursor, workInProgress);\n    // Now push the new context and mark that it has changed.\n    push(contextStackCursor, mergedContext, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  } else {\n    pop(didPerformWorkStackCursor, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  }\n}\n\nfunction resetContext() {\n  previousContext = emptyObject;\n  contextStackCursor.current = emptyObject;\n  didPerformWorkStackCursor.current = false;\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n  // makes sense elsewhere\n  !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  var node = fiber;\n  while (node.tag !== HostRoot) {\n    if (isContextProvider(node)) {\n      return node.stateNode.__reactInternalMemoizedMergedChildContext;\n    }\n    var parent = node['return'];\n    !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    node = parent;\n  }\n  return node.stateNode.context;\n}\n\nvar NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax\n\nvar Sync = 1;\nvar Never = 2147483647; // Max int32: Math.pow(2, 31) - 1\n\nvar UNIT_SIZE = 10;\nvar MAGIC_NUMBER_OFFSET = 2;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;\n}\n\nfunction ceiling(num, precision) {\n  return ((num / precision | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\n}\n\nvar NoContext = 0;\nvar AsyncUpdates = 1;\n\n{\n  var hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    /* eslint-disable no-new */\n    new Map([[nonExtensibleObject, null]]);\n    new Set([nonExtensibleObject]);\n    /* eslint-enable no-new */\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\n\n{\n  var debugCounter = 1;\n}\n\nfunction FiberNode(tag, key, internalContextTag) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this['return'] = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = null;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n\n  this.internalContextTag = internalContextTag;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n\n  this.alternate = null;\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function (tag, key, internalContextTag) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, key, internalContextTag);\n};\n\nfunction shouldConstruct(Component) {\n  return !!(Component.prototype && Component.prototype.isReactComponent);\n}\n\n// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current, pendingProps, expirationTime) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(current.tag, current.key, current.internalContextTag);\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n  }\n\n  workInProgress.expirationTime = expirationTime;\n  workInProgress.pendingProps = pendingProps;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  return workInProgress;\n}\n\nfunction createHostRootFiber() {\n  var fiber = createFiber(HostRoot, null, NoContext);\n  return fiber;\n}\n\nfunction createFiberFromElement(element, internalContextTag, expirationTime) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = void 0;\n  var type = element.type,\n      key = element.key;\n\n  if (typeof type === 'function') {\n    fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);\n    fiber.type = type;\n    fiber.pendingProps = element.props;\n  } else if (typeof type === 'string') {\n    fiber = createFiber(HostComponent, key, internalContextTag);\n    fiber.type = type;\n    fiber.pendingProps = element.props;\n  } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {\n    // Currently assumed to be a continuation and therefore is a fiber already.\n    // TODO: The yield system is currently broken for updates in some cases.\n    // The reified yield stores a fiber, but we don't know which fiber that is;\n    // the current or a workInProgress? When the continuation gets rendered here\n    // we don't know if we can reuse that fiber or if we need to clone it.\n    // There is probably a clever way to restructure this.\n    fiber = type;\n    fiber.pendingProps = element.props;\n  } else {\n    var info = '';\n    {\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n      var ownerName = owner ? getComponentName(owner) : null;\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n    }\n    invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);\n  }\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  fiber.expirationTime = expirationTime;\n\n  return fiber;\n}\n\nfunction createFiberFromFragment(elements, internalContextTag, expirationTime, key) {\n  var fiber = createFiber(Fragment, key, internalContextTag);\n  fiber.pendingProps = elements;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromText(content, internalContextTag, expirationTime) {\n  var fiber = createFiber(HostText, null, internalContextTag);\n  fiber.pendingProps = content;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, NoContext);\n  fiber.type = 'DELETED';\n  return fiber;\n}\n\nfunction createFiberFromCall(call, internalContextTag, expirationTime) {\n  var fiber = createFiber(CallComponent, call.key, internalContextTag);\n  fiber.type = call.handler;\n  fiber.pendingProps = call;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromReturn(returnNode, internalContextTag, expirationTime) {\n  var fiber = createFiber(ReturnComponent, null, internalContextTag);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromPortal(portal, internalContextTag, expirationTime) {\n  var fiber = createFiber(HostPortal, portal.key, internalContextTag);\n  fiber.pendingProps = portal.children || [];\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n}\n\nfunction createFiberRoot(containerInfo, hydrate) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber();\n  var root = {\n    current: uninitializedFiber,\n    containerInfo: containerInfo,\n    pendingChildren: null,\n    remainingExpirationTime: NoWork,\n    isReadyForCommit: false,\n    finishedWork: null,\n    context: null,\n    pendingContext: null,\n    hydrate: hydrate,\n    nextScheduledRoot: null\n  };\n  uninitializedFiber.stateNode = root;\n  return root;\n}\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\nvar hasLoggedError = false;\n\nfunction catchErrors(fn) {\n  return function (arg) {\n    try {\n      return fn(arg);\n    } catch (err) {\n      if (true && !hasLoggedError) {\n        hasLoggedError = true;\n        warning(false, 'React DevTools encountered an error: %s', err);\n      }\n    }\n  };\n}\n\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n    // No DevTools\n    return false;\n  }\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n  if (!hook.supportsFiber) {\n    {\n      warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');\n    }\n    // DevTools exists, even though it doesn't support Fiber.\n    return true;\n  }\n  try {\n    var rendererID = hook.inject(internals);\n    // We have successfully injected, so now it is safe to set up hooks.\n    onCommitFiberRoot = catchErrors(function (root) {\n      return hook.onCommitFiberRoot(rendererID, root);\n    });\n    onCommitFiberUnmount = catchErrors(function (fiber) {\n      return hook.onCommitFiberUnmount(rendererID, fiber);\n    });\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      warning(false, 'React DevTools encountered an error: %s.', err);\n    }\n  }\n  // DevTools exists\n  return true;\n}\n\nfunction onCommitRoot(root) {\n  if (typeof onCommitFiberRoot === 'function') {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount(fiber) {\n  if (typeof onCommitFiberUnmount === 'function') {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\n{\n  var didWarnUpdateInsideUpdate = false;\n}\n\n// Callbacks are not validated until invocation\n\n\n// Singly linked-list of updates. When an update is scheduled, it is added to\n// the queue of the current fiber and the work-in-progress fiber. The two queues\n// are separate but they share a persistent structure.\n//\n// During reconciliation, updates are removed from the work-in-progress fiber,\n// but they remain on the current fiber. That ensures that if a work-in-progress\n// is aborted, the aborted updates are recovered by cloning from current.\n//\n// The work-in-progress queue is always a subset of the current queue.\n//\n// When the tree is committed, the work-in-progress becomes the current.\n\n\nfunction createUpdateQueue(baseState) {\n  var queue = {\n    baseState: baseState,\n    expirationTime: NoWork,\n    first: null,\n    last: null,\n    callbackList: null,\n    hasForceUpdate: false,\n    isInitialized: false\n  };\n  {\n    queue.isProcessing = false;\n  }\n  return queue;\n}\n\nfunction insertUpdateIntoQueue(queue, update) {\n  // Append the update to the end of the list.\n  if (queue.last === null) {\n    // Queue is empty\n    queue.first = queue.last = update;\n  } else {\n    queue.last.next = update;\n    queue.last = update;\n  }\n  if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {\n    queue.expirationTime = update.expirationTime;\n  }\n}\n\nfunction insertUpdateIntoFiber(fiber, update) {\n  // We'll have at least one and at most two distinct update queues.\n  var alternateFiber = fiber.alternate;\n  var queue1 = fiber.updateQueue;\n  if (queue1 === null) {\n    // TODO: We don't know what the base state will be until we begin work.\n    // It depends on which fiber is the next current. Initialize with an empty\n    // base state, then set to the memoizedState when rendering. Not super\n    // happy with this approach.\n    queue1 = fiber.updateQueue = createUpdateQueue(null);\n  }\n\n  var queue2 = void 0;\n  if (alternateFiber !== null) {\n    queue2 = alternateFiber.updateQueue;\n    if (queue2 === null) {\n      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);\n    }\n  } else {\n    queue2 = null;\n  }\n  queue2 = queue2 !== queue1 ? queue2 : null;\n\n  // Warn if an update is scheduled from inside an updater function.\n  {\n    if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {\n      warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n\n  // If there's only one queue, add the update to that queue and exit.\n  if (queue2 === null) {\n    insertUpdateIntoQueue(queue1, update);\n    return;\n  }\n\n  // If either queue is empty, we need to add to both queues.\n  if (queue1.last === null || queue2.last === null) {\n    insertUpdateIntoQueue(queue1, update);\n    insertUpdateIntoQueue(queue2, update);\n    return;\n  }\n\n  // If both lists are not empty, the last update is the same for both lists\n  // because of structural sharing. So, we should only append to one of\n  // the lists.\n  insertUpdateIntoQueue(queue1, update);\n  // But we still need to update the `last` pointer of queue2.\n  queue2.last = update;\n}\n\nfunction getUpdateExpirationTime(fiber) {\n  if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {\n    return NoWork;\n  }\n  var updateQueue = fiber.updateQueue;\n  if (updateQueue === null) {\n    return NoWork;\n  }\n  return updateQueue.expirationTime;\n}\n\nfunction getStateFromUpdate(update, instance, prevState, props) {\n  var partialState = update.partialState;\n  if (typeof partialState === 'function') {\n    var updateFn = partialState;\n    return updateFn.call(instance, prevState, props);\n  } else {\n    return partialState;\n  }\n}\n\nfunction processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {\n  if (current !== null && current.updateQueue === queue) {\n    // We need to create a work-in-progress queue, by cloning the current queue.\n    var currentQueue = queue;\n    queue = workInProgress.updateQueue = {\n      baseState: currentQueue.baseState,\n      expirationTime: currentQueue.expirationTime,\n      first: currentQueue.first,\n      last: currentQueue.last,\n      isInitialized: currentQueue.isInitialized,\n      // These fields are no longer valid because they were already committed.\n      // Reset them.\n      callbackList: null,\n      hasForceUpdate: false\n    };\n  }\n\n  {\n    // Set this flag so we can warn if setState is called inside the update\n    // function of another setState.\n    queue.isProcessing = true;\n  }\n\n  // Reset the remaining expiration time. If we skip over any updates, we'll\n  // increase this accordingly.\n  queue.expirationTime = NoWork;\n\n  // TODO: We don't know what the base state will be until we begin work.\n  // It depends on which fiber is the next current. Initialize with an empty\n  // base state, then set to the memoizedState when rendering. Not super\n  // happy with this approach.\n  var state = void 0;\n  if (queue.isInitialized) {\n    state = queue.baseState;\n  } else {\n    state = queue.baseState = workInProgress.memoizedState;\n    queue.isInitialized = true;\n  }\n  var dontMutatePrevState = true;\n  var update = queue.first;\n  var didSkip = false;\n  while (update !== null) {\n    var updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      var remainingExpirationTime = queue.expirationTime;\n      if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {\n        // Update the remaining expiration time.\n        queue.expirationTime = updateExpirationTime;\n      }\n      if (!didSkip) {\n        didSkip = true;\n        queue.baseState = state;\n      }\n      // Continue to the next update.\n      update = update.next;\n      continue;\n    }\n\n    // This update does have sufficient priority.\n\n    // If no previous updates were skipped, drop this update from the queue by\n    // advancing the head of the list.\n    if (!didSkip) {\n      queue.first = update.next;\n      if (queue.first === null) {\n        queue.last = null;\n      }\n    }\n\n    // Process the update\n    var _partialState = void 0;\n    if (update.isReplace) {\n      state = getStateFromUpdate(update, instance, state, props);\n      dontMutatePrevState = true;\n    } else {\n      _partialState = getStateFromUpdate(update, instance, state, props);\n      if (_partialState) {\n        if (dontMutatePrevState) {\n          // $FlowFixMe: Idk how to type this properly.\n          state = _assign({}, state, _partialState);\n        } else {\n          state = _assign(state, _partialState);\n        }\n        dontMutatePrevState = false;\n      }\n    }\n    if (update.isForced) {\n      queue.hasForceUpdate = true;\n    }\n    if (update.callback !== null) {\n      // Append to list of callbacks.\n      var _callbackList = queue.callbackList;\n      if (_callbackList === null) {\n        _callbackList = queue.callbackList = [];\n      }\n      _callbackList.push(update);\n    }\n    update = update.next;\n  }\n\n  if (queue.callbackList !== null) {\n    workInProgress.effectTag |= Callback;\n  } else if (queue.first === null && !queue.hasForceUpdate) {\n    // The queue is empty. We can reset it.\n    workInProgress.updateQueue = null;\n  }\n\n  if (!didSkip) {\n    didSkip = true;\n    queue.baseState = state;\n  }\n\n  {\n    // No longer processing.\n    queue.isProcessing = false;\n  }\n\n  return state;\n}\n\nfunction commitCallbacks(queue, context) {\n  var callbackList = queue.callbackList;\n  if (callbackList === null) {\n    return;\n  }\n  // Set the list to null to make sure they don't get called more than once.\n  queue.callbackList = null;\n  for (var i = 0; i < callbackList.length; i++) {\n    var update = callbackList[i];\n    var _callback = update.callback;\n    // This update might be processed again. Clear the callback so it's only\n    // called once.\n    update.callback = null;\n    !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;\n    _callback.call(context);\n  }\n}\n\nvar fakeInternalInstance = {};\nvar isArray = Array.isArray;\n\n{\n  var didWarnAboutStateAssignmentForComponent = {};\n\n  var warnOnInvalidCallback = function (callback, callerName) {\n    warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nvar ReactFiberClassComponent = function (scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {\n  // Class component state updater\n  var updater = {\n    isMounted: isMounted,\n    enqueueSetState: function (instance, partialState, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: partialState,\n        callback: callback,\n        isReplace: false,\n        isForced: false,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueReplaceState: function (instance, state, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: state,\n        callback: callback,\n        isReplace: true,\n        isForced: false,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueForceUpdate: function (instance, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: null,\n        callback: callback,\n        isReplace: false,\n        isForced: true,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    }\n  };\n\n  function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {\n    if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {\n      // If the workInProgress already has an Update effect, return true\n      return true;\n    }\n\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    if (typeof instance.shouldComponentUpdate === 'function') {\n      startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n      var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);\n      stopPhaseTimer();\n\n      {\n        warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');\n      }\n\n      return shouldUpdate;\n    }\n\n    if (type.prototype && type.prototype.isPureReactComponent) {\n      return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n    }\n\n    return true;\n  }\n\n  function checkClassInstance(workInProgress) {\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    {\n      var name = getComponentName(workInProgress);\n      var renderPresent = instance.render;\n\n      if (!renderPresent) {\n        if (type.prototype && typeof type.prototype.render === 'function') {\n          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n        } else {\n          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n        }\n      }\n\n      var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n      warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n      var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n      warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n      var noInstancePropTypes = !instance.propTypes;\n      warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n      var noInstanceContextTypes = !instance.contextTypes;\n      warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n      var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n      warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n      if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n        warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');\n      }\n      var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n      warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n      var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';\n      warning(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n      var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n      warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n      var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n      warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n      var noInstanceDefaultProps = !instance.defaultProps;\n      warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n    }\n\n    var state = instance.state;\n    if (state && (typeof state !== 'object' || isArray(state))) {\n      invariant(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));\n    }\n    if (typeof instance.getChildContext === 'function') {\n      !(typeof workInProgress.type.childContextTypes === 'object') ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', getComponentName(workInProgress)) : void 0;\n    }\n  }\n\n  function resetInputPointers(workInProgress, instance) {\n    instance.props = workInProgress.memoizedProps;\n    instance.state = workInProgress.memoizedState;\n  }\n\n  function adoptClassInstance(workInProgress, instance) {\n    instance.updater = updater;\n    workInProgress.stateNode = instance;\n    // The instance needs access to the fiber so that it can schedule updates\n    set(instance, workInProgress);\n    {\n      instance._reactInternalInstance = fakeInternalInstance;\n    }\n  }\n\n  function constructClassInstance(workInProgress, props) {\n    var ctor = workInProgress.type;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var needsContext = isContextConsumer(workInProgress);\n    var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;\n    var instance = new ctor(props, context);\n    adoptClassInstance(workInProgress, instance);\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // ReactFiberContext usually updates this cache but can't for newly-created instances.\n    if (needsContext) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return instance;\n  }\n\n  function callComponentWillMount(workInProgress, instance) {\n    startPhaseTimer(workInProgress, 'componentWillMount');\n    var oldState = instance.state;\n    instance.componentWillMount();\n\n    stopPhaseTimer();\n\n    if (oldState !== instance.state) {\n      {\n        warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress));\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {\n    startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n    var oldState = instance.state;\n    instance.componentWillReceiveProps(newProps, newContext);\n    stopPhaseTimer();\n\n    if (instance.state !== oldState) {\n      {\n        var componentName = getComponentName(workInProgress) || 'Component';\n        if (!didWarnAboutStateAssignmentForComponent[componentName]) {\n          warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n          didWarnAboutStateAssignmentForComponent[componentName] = true;\n        }\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  // Invokes the mount life-cycles on a previously never rendered instance.\n  function mountClassInstance(workInProgress, renderExpirationTime) {\n    var current = workInProgress.alternate;\n\n    {\n      checkClassInstance(workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n    var state = instance.state || null;\n\n    var props = workInProgress.pendingProps;\n    !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n\n    instance.props = props;\n    instance.state = workInProgress.memoizedState = state;\n    instance.refs = emptyObject;\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n    if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {\n      workInProgress.internalContextTag |= AsyncUpdates;\n    }\n\n    if (typeof instance.componentWillMount === 'function') {\n      callComponentWillMount(workInProgress, instance);\n      // If we had additional state updates during this life-cycle, let's\n      // process them now.\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null) {\n        instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);\n      }\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  }\n\n  // Called on a preexisting class instance. Returns false if a resumed render\n  // could be reused.\n  // function resumeMountClassInstance(\n  //   workInProgress: Fiber,\n  //   priorityLevel: PriorityLevel,\n  // ): boolean {\n  //   const instance = workInProgress.stateNode;\n  //   resetInputPointers(workInProgress, instance);\n\n  //   let newState = workInProgress.memoizedState;\n  //   let newProps = workInProgress.pendingProps;\n  //   if (!newProps) {\n  //     // If there isn't any new props, then we'll reuse the memoized props.\n  //     // This could be from already completed work.\n  //     newProps = workInProgress.memoizedProps;\n  //     invariant(\n  //       newProps != null,\n  //       'There should always be pending or memoized props. This error is ' +\n  //         'likely caused by a bug in React. Please file an issue.',\n  //     );\n  //   }\n  //   const newUnmaskedContext = getUnmaskedContext(workInProgress);\n  //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n  //   const oldContext = instance.context;\n  //   const oldProps = workInProgress.memoizedProps;\n\n  //   if (\n  //     typeof instance.componentWillReceiveProps === 'function' &&\n  //     (oldProps !== newProps || oldContext !== newContext)\n  //   ) {\n  //     callComponentWillReceiveProps(\n  //       workInProgress,\n  //       instance,\n  //       newProps,\n  //       newContext,\n  //     );\n  //   }\n\n  //   // Process the update queue before calling shouldComponentUpdate\n  //   const updateQueue = workInProgress.updateQueue;\n  //   if (updateQueue !== null) {\n  //     newState = processUpdateQueue(\n  //       workInProgress,\n  //       updateQueue,\n  //       instance,\n  //       newState,\n  //       newProps,\n  //       priorityLevel,\n  //     );\n  //   }\n\n  //   // TODO: Should we deal with a setState that happened after the last\n  //   // componentWillMount and before this componentWillMount? Probably\n  //   // unsupported anyway.\n\n  //   if (\n  //     !checkShouldComponentUpdate(\n  //       workInProgress,\n  //       workInProgress.memoizedProps,\n  //       newProps,\n  //       workInProgress.memoizedState,\n  //       newState,\n  //       newContext,\n  //     )\n  //   ) {\n  //     // Update the existing instance's state, props, and context pointers even\n  //     // though we're bailing out.\n  //     instance.props = newProps;\n  //     instance.state = newState;\n  //     instance.context = newContext;\n  //     return false;\n  //   }\n\n  //   // Update the input pointers now so that they are correct when we call\n  //   // componentWillMount\n  //   instance.props = newProps;\n  //   instance.state = newState;\n  //   instance.context = newContext;\n\n  //   if (typeof instance.componentWillMount === 'function') {\n  //     callComponentWillMount(workInProgress, instance);\n  //     // componentWillMount may have called setState. Process the update queue.\n  //     const newUpdateQueue = workInProgress.updateQueue;\n  //     if (newUpdateQueue !== null) {\n  //       newState = processUpdateQueue(\n  //         workInProgress,\n  //         newUpdateQueue,\n  //         instance,\n  //         newState,\n  //         newProps,\n  //         priorityLevel,\n  //       );\n  //     }\n  //   }\n\n  //   if (typeof instance.componentDidMount === 'function') {\n  //     workInProgress.effectTag |= Update;\n  //   }\n\n  //   instance.state = newState;\n\n  //   return true;\n  // }\n\n  // Invokes the update life-cycles and returns false if it shouldn't rerender.\n  function updateClassInstance(current, workInProgress, renderExpirationTime) {\n    var instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    var oldProps = workInProgress.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n    if (!newProps) {\n      // If there aren't any new props, then we'll reuse the memoized props.\n      // This could be from already completed work.\n      newProps = oldProps;\n      !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    }\n    var oldContext = instance.context;\n    var newUnmaskedContext = getUnmaskedContext(workInProgress);\n    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    var oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    var newState = void 0;\n    if (workInProgress.updateQueue !== null) {\n      newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);\n    } else {\n      newState = oldState;\n    }\n\n    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n      return false;\n    }\n\n    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n\n    if (shouldUpdate) {\n      if (typeof instance.componentWillUpdate === 'function') {\n        startPhaseTimer(workInProgress, 'componentWillUpdate');\n        instance.componentWillUpdate(newProps, newState, newContext);\n        stopPhaseTimer();\n      }\n      if (typeof instance.componentDidUpdate === 'function') {\n        workInProgress.effectTag |= Update;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n  return {\n    adoptClassInstance: adoptClassInstance,\n    constructClassInstance: constructClassInstance,\n    mountClassInstance: mountClassInstance,\n    // resumeMountClassInstance,\n    updateClassInstance: updateClassInstance\n  };\n};\n\n// The Symbol used to tag the special React types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar REACT_PORTAL_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.portal') || 0xeaca;\n\nfunction createPortal$1(children, containerInfo,\n// TODO: figure out the API for cross-renderer implementation.\nimplementation) {\n  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\nvar getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\n\n{\n  var didWarnAboutMaps = false;\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  var ownerHasKeyUseWarning = {};\n  var ownerHasFunctionTypeWarning = {};\n\n  var warnForMissingKey = function (child) {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    child._store.validated = true;\n\n    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning(false, 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());\n  };\n}\n\nvar isArray$1 = Array.isArray;\n\nvar ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar REACT_ELEMENT_TYPE;\nvar REACT_CALL_TYPE;\nvar REACT_RETURN_TYPE;\nvar REACT_FRAGMENT_TYPE;\nif (typeof Symbol === 'function' && Symbol['for']) {\n  REACT_ELEMENT_TYPE = Symbol['for']('react.element');\n  REACT_CALL_TYPE = Symbol['for']('react.call');\n  REACT_RETURN_TYPE = Symbol['for']('react.return');\n  REACT_FRAGMENT_TYPE = Symbol['for']('react.fragment');\n} else {\n  REACT_ELEMENT_TYPE = 0xeac7;\n  REACT_CALL_TYPE = 0xeac8;\n  REACT_RETURN_TYPE = 0xeac9;\n  REACT_FRAGMENT_TYPE = 0xeacb;\n}\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n    return null;\n  }\n  var iteratorFn = ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof iteratorFn === 'function') {\n    return iteratorFn;\n  }\n  return null;\n}\n\nfunction coerceRef(current, element) {\n  var mixedRef = element.ref;\n  if (mixedRef !== null && typeof mixedRef !== 'function') {\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        var ownerFiber = owner;\n        !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;\n        inst = ownerFiber.stateNode;\n      }\n      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;\n      var stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n      var ref = function (value) {\n        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;\n      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== 'textarea') {\n    var addendum = '';\n    {\n      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');\n    }\n    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n  }\n}\n\nfunction warnOnFunctionType() {\n  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldClone, shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    if (!shouldClone) {\n      // When we're reconciling in place we have a work in progress copy. We\n      // actually want the current copy. If there is no current copy, then we\n      // don't need to track deletion side-effects.\n      if (childToDelete.alternate === null) {\n        return;\n      }\n      childToDelete = childToDelete.alternate;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    if (shouldClone) {\n      var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n      clone.index = 0;\n      clone.sibling = null;\n      return clone;\n    } else {\n      // We override the expiration time even if it is earlier, because if\n      // we're reconciling at a later time that means that this was\n      // down-prioritized.\n      fiber.expirationTime = expirationTime;\n      fiber.effectTag = NoEffect;\n      fiber.index = 0;\n      fiber.sibling = null;\n      fiber.pendingProps = pendingProps;\n      return fiber;\n    }\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current = newFiber.alternate;\n    if (current !== null) {\n      var oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, expirationTime) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, textContent, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, expirationTime) {\n    if (current !== null && current.type === element.type) {\n      // Move based on index\n      var existing = useFiber(current, element.props, expirationTime);\n      existing.ref = coerceRef(current, element);\n      existing['return'] = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n      created.ref = coerceRef(current, element);\n      created['return'] = returnFiber;\n      return created;\n    }\n  }\n\n  function updateCall(returnFiber, current, call, expirationTime) {\n    // TODO: Should this also compare handler to determine whether to reuse?\n    if (current === null || current.tag !== CallComponent) {\n      // Insert\n      var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      var existing = useFiber(current, call, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateReturn(returnFiber, current, returnNode, expirationTime) {\n    if (current === null || current.tag !== ReturnComponent) {\n      // Insert\n      var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n      created.type = returnNode.value;\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      var existing = useFiber(current, null, expirationTime);\n      existing.type = returnNode.value;\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updatePortal(returnFiber, current, portal, expirationTime) {\n    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, portal.children || [], expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, fragment, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);\n              _created['return'] = returnFiber;\n              return _created;\n            } else {\n              var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);\n              _created2.ref = coerceRef(null, newChild);\n              _created2['return'] = returnFiber;\n              return _created2;\n            }\n          }\n\n        case REACT_CALL_TYPE:\n          {\n            var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);\n            _created3['return'] = returnFiber;\n            return _created3;\n          }\n\n        case REACT_RETURN_TYPE:\n          {\n            var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);\n            _created4.type = newChild.value;\n            _created4['return'] = returnFiber;\n            return _created4;\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);\n            _created5['return'] = returnFiber;\n            return _created5;\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);\n        _created6['return'] = returnFiber;\n        return _created6;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              if (newChild.type === REACT_FRAGMENT_TYPE) {\n                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n              }\n              return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_CALL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updateCall(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_RETURN_TYPE:\n          {\n            // Returns don't have keys. If the previous node is implicitly keyed\n            // we can continue to replace it without aborting even if it is not a\n            // yield.\n            if (key === null) {\n              return updateReturn(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);\n            }\n            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);\n          }\n\n        case REACT_CALL_TYPE:\n          {\n            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);\n          }\n\n        case REACT_RETURN_TYPE:\n          {\n            // Returns don't have keys, so we neither have to check the old nor\n            // new node for the key. If both are returns, they match.\n            var _matchedFiber3 = existingChildren.get(newIdx) || null;\n            return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber5 = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_CALL_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    {\n      // Warn about using Maps as children\n      if (typeof newChildrenIterable.entries === 'function') {\n        var possibleMap = newChildrenIterable;\n        if (possibleMap.entries === iteratorFn) {\n          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());\n          didWarnAboutMaps = true;\n        }\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);\n          existing.ref = coerceRef(child, element);\n          existing['return'] = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n      _created7.ref = coerceRef(currentFirstChild, element);\n      _created7['return'] = returnFiber;\n      return _created7;\n    }\n  }\n\n  function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {\n    var key = call.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === CallComponent) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, call, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {\n    // There's no need to check for keys on yields since they're stateless.\n    var child = currentFirstChild;\n    if (child !== null) {\n      if (child.tag === ReturnComponent) {\n        deleteRemainingChildren(returnFiber, child.sibling);\n        var existing = useFiber(child, null, expirationTime);\n        existing.type = returnNode.value;\n        existing['return'] = returnFiber;\n        return existing;\n      } else {\n        deleteRemainingChildren(returnFiber, child);\n      }\n    }\n\n    var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n    created.type = returnNode.value;\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || [], expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    if (enableReactFragment && typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    var isObject = typeof newChild === 'object' && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n\n        case REACT_CALL_TYPE:\n          return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));\n        case REACT_RETURN_TYPE:\n          return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n      }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));\n    }\n\n    if (isArray$1(newChild)) {\n      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === 'undefined') {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent:\n          {\n            {\n              var instance = returnFiber.stateNode;\n              if (instance.render._isMockFunction) {\n                // We allow auto-mocks to proceed as if they're returning null.\n                break;\n              }\n            }\n          }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent:\n          {\n            var Component = returnFiber.type;\n            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');\n          }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true, true);\n\nvar reconcileChildFibersInPlace = ChildReconciler(false, true);\n\nvar mountChildFibersInPlace = ChildReconciler(false, false);\n\nfunction cloneChildFibers(current, workInProgress) {\n  !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n  workInProgress.child = newChild;\n\n  newChild['return'] = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n    newChild['return'] = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n{\n  var warnedAboutStatelessRefs = {};\n}\n\nvar ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n      useSyncScheduling = config.useSyncScheduling,\n      shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;\n  var pushHostContext = hostContext.pushHostContext,\n      pushHostContainer = hostContext.pushHostContainer;\n  var enterHydrationState = hydrationContext.enterHydrationState,\n      resetHydrationState = hydrationContext.resetHydrationState,\n      tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;\n\n  var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),\n      adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,\n      constructClassInstance = _ReactFiberClassCompo.constructClassInstance,\n      mountClassInstance = _ReactFiberClassCompo.mountClassInstance,\n      updateClassInstance = _ReactFiberClassCompo.updateClassInstance;\n\n  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\n\n\n  function reconcileChildren(current, workInProgress, nextChildren) {\n    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);\n  }\n\n  function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {\n    if (current === null) {\n      // If this is a fresh new component that hasn't been rendered yet, we\n      // won't update its child set by applying minimal side-effects. Instead,\n      // we will add them all to the child before it gets rendered. That means\n      // we can optimize this reconciliation pass by not tracking side-effects.\n      workInProgress.child = mountChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n    } else if (current.child === workInProgress.child) {\n      // If the current child is the same as the work in progress, it means that\n      // we haven't yet started any work on these children. Therefore, we use\n      // the clone algorithm to create a copy of all the current children.\n\n      // If we had any progressed work already, that is invalid at this point so\n      // let's throw it out.\n      workInProgress.child = reconcileChildFibers(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n    } else {\n      // If, on the other hand, it is already using a clone, that means we've\n      // already begun some work on this tree and we can continue where we left\n      // off by reconciling against the existing children.\n      workInProgress.child = reconcileChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n    }\n  }\n\n  function updateFragment(current, workInProgress) {\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextChildren === null) {\n        nextChildren = workInProgress.memoizedProps;\n      }\n    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function markRef(current, workInProgress) {\n    var ref = workInProgress.ref;\n    if (ref !== null && (!current || current.ref !== ref)) {\n      // Schedule a Ref effect\n      workInProgress.effectTag |= Ref;\n    }\n  }\n\n  function updateFunctionalComponent(current, workInProgress) {\n    var fn = workInProgress.type;\n    var nextProps = workInProgress.pendingProps;\n\n    var memoizedProps = workInProgress.memoizedProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextProps === null) {\n        nextProps = memoizedProps;\n      }\n    } else {\n      if (nextProps === null || memoizedProps === nextProps) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // TODO: consider bringing fn.shouldComponentUpdate() back.\n      // It used to be here.\n    }\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var nextChildren;\n\n    {\n      ReactCurrentOwner.current = workInProgress;\n      ReactDebugCurrentFiber.setCurrentPhase('render');\n      nextChildren = fn(nextProps, context);\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateClassComponent(current, workInProgress, renderExpirationTime) {\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = pushContextProvider(workInProgress);\n\n    var shouldUpdate = void 0;\n    if (current === null) {\n      if (!workInProgress.stateNode) {\n        // In the initial pass we might need to construct the instance.\n        constructClassInstance(workInProgress, workInProgress.pendingProps);\n        mountClassInstance(workInProgress, renderExpirationTime);\n        shouldUpdate = true;\n      } else {\n        invariant(false, 'Resuming work not yet implemented.');\n        // In a resume, we'll already have an instance we can reuse.\n        // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);\n      }\n    } else {\n      shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);\n    }\n    return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);\n  }\n\n  function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {\n    // Refs should update even if shouldComponentUpdate returns false\n    markRef(current, workInProgress);\n\n    if (!shouldUpdate) {\n      // Context providers should defer to sCU for rendering\n      if (hasContext) {\n        invalidateContextProvider(workInProgress, false);\n      }\n\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n\n    // Rerender\n    ReactCurrentOwner.current = workInProgress;\n    var nextChildren = void 0;\n    {\n      ReactDebugCurrentFiber.setCurrentPhase('render');\n      nextChildren = instance.render();\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    reconcileChildren(current, workInProgress, nextChildren);\n    // Memoize props and state using the values we just used to render.\n    // TODO: Restructure so we never read values from the instance.\n    memoizeState(workInProgress, instance.state);\n    memoizeProps(workInProgress, instance.props);\n\n    // The context might have changed so we need to recalculate it.\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, true);\n    }\n\n    return workInProgress.child;\n  }\n\n  function pushHostRootContext(workInProgress) {\n    var root = workInProgress.stateNode;\n    if (root.pendingContext) {\n      pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n    } else if (root.context) {\n      // Should always be set\n      pushTopLevelContextObject(workInProgress, root.context, false);\n    }\n    pushHostContainer(workInProgress, root.containerInfo);\n  }\n\n  function updateHostRoot(current, workInProgress, renderExpirationTime) {\n    pushHostRootContext(workInProgress);\n    var updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      var prevState = workInProgress.memoizedState;\n      var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);\n      if (prevState === state) {\n        // If the state is the same as before, that's a bailout because we had\n        // no work that expires at this time.\n        resetHydrationState();\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      var element = state.element;\n      var root = workInProgress.stateNode;\n      if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {\n        // If we don't have any current children this might be the first pass.\n        // We always try to hydrate. If this isn't a hydration pass there won't\n        // be any children to hydrate which is effectively the same thing as\n        // not hydrating.\n\n        // This is a bit of a hack. We track the host root as a placement to\n        // know that we're currently in a mounting state. That way isMounted\n        // works as expected. We must reset this before committing.\n        // TODO: Delete this when we delete isMounted and findDOMNode.\n        workInProgress.effectTag |= Placement;\n\n        // Ensure that children mount into this root without tracking\n        // side-effects. This ensures that we don't store Placement effects on\n        // nodes that will be hydrated.\n        workInProgress.child = mountChildFibersInPlace(workInProgress, workInProgress.child, element, renderExpirationTime);\n      } else {\n        // Otherwise reset hydration state in case we aborted and resumed another\n        // root.\n        resetHydrationState();\n        reconcileChildren(current, workInProgress, element);\n      }\n      memoizeState(workInProgress, state);\n      return workInProgress.child;\n    }\n    resetHydrationState();\n    // If there is no update queue, that's a bailout because the root has no props.\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  function updateHostComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContext(workInProgress);\n\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n\n    var type = workInProgress.type;\n    var memoizedProps = workInProgress.memoizedProps;\n    var nextProps = workInProgress.pendingProps;\n    if (nextProps === null) {\n      nextProps = memoizedProps;\n      !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    }\n    var prevProps = current !== null ? current.memoizedProps : null;\n\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (nextProps === null || memoizedProps === nextProps) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextProps.children;\n    var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n    if (isDirectTextChild) {\n      // We special case a direct text child of a host node. This is a common\n      // case. We won't handle it as a reified child. We will instead handle\n      // this in the host environment that also have access to this prop. That\n      // avoids allocating another HostText fiber and traversing it.\n      nextChildren = null;\n    } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n      // If we're switching from a direct text child to a normal child, or to\n      // empty, we need to schedule the text content to be reset.\n      workInProgress.effectTag |= ContentReset;\n    }\n\n    markRef(current, workInProgress);\n\n    // Check the host config to see if the children are offscreen/hidden.\n    if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {\n      // Down-prioritize the children.\n      workInProgress.expirationTime = Never;\n      // Bailout and come back to this fiber later.\n      return null;\n    }\n\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateHostText(current, workInProgress) {\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n    var nextProps = workInProgress.pendingProps;\n    if (nextProps === null) {\n      nextProps = workInProgress.memoizedProps;\n    }\n    memoizeProps(workInProgress, nextProps);\n    // Nothing to do here. This is terminal. We'll do the completion step\n    // immediately after.\n    return null;\n  }\n\n  function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {\n    !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    var fn = workInProgress.type;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var value;\n\n    {\n      if (fn.prototype && typeof fn.prototype.render === 'function') {\n        var componentName = getComponentName(workInProgress);\n        warning(false, \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n      }\n      ReactCurrentOwner.current = workInProgress;\n      value = fn(props, context);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n\n    if (typeof value === 'object' && value !== null && typeof value.render === 'function') {\n      // Proceed under the assumption that this is a class instance\n      workInProgress.tag = ClassComponent;\n\n      // Push context providers early to prevent context stack mismatches.\n      // During mounting we don't know the child context yet as the instance doesn't exist.\n      // We will invalidate the child context in finishClassComponent() right after rendering.\n      var hasContext = pushContextProvider(workInProgress);\n      adoptClassInstance(workInProgress, value);\n      mountClassInstance(workInProgress, renderExpirationTime);\n      return finishClassComponent(current, workInProgress, true, hasContext);\n    } else {\n      // Proceed under the assumption that this is a functional component\n      workInProgress.tag = FunctionalComponent;\n      {\n        var Component = workInProgress.type;\n\n        if (Component) {\n          warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');\n        }\n        if (workInProgress.ref !== null) {\n          var info = '';\n          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n\n          var warningKey = ownerName || workInProgress._debugID || '';\n          var debugSource = workInProgress._debugSource;\n          if (debugSource) {\n            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n          }\n          if (!warnedAboutStatelessRefs[warningKey]) {\n            warnedAboutStatelessRefs[warningKey] = true;\n            warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());\n          }\n        }\n      }\n      reconcileChildren(current, workInProgress, value);\n      memoizeProps(workInProgress, props);\n      return workInProgress.child;\n    }\n  }\n\n  function updateCallComponent(current, workInProgress, renderExpirationTime) {\n    var nextCall = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextCall === null) {\n        nextCall = current && current.memoizedProps;\n        !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      }\n    } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {\n      nextCall = workInProgress.memoizedProps;\n      // TODO: When bailing out, we might need to return the stateNode instead\n      // of the child. To check it for work.\n      // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextCall.children;\n\n    // The following is a fork of reconcileChildrenAtExpirationTime but using\n    // stateNode to store the child.\n    if (current === null) {\n      workInProgress.stateNode = mountChildFibersInPlace(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n    } else if (current.child === workInProgress.child) {\n      workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n    } else {\n      workInProgress.stateNode = reconcileChildFibersInPlace(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n    }\n\n    memoizeProps(workInProgress, nextCall);\n    // This doesn't take arbitrary time so we could synchronously just begin\n    // eagerly do the work of workInProgress.child as an optimization.\n    return workInProgress.stateNode;\n  }\n\n  function updatePortalComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextChildren === null) {\n        nextChildren = current && current.memoizedProps;\n        !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      }\n    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    if (current === null) {\n      // Portals are special because we don't append the children during mount\n      // but at commit. Therefore we need to track insertions which the normal\n      // flow doesn't do during mount. This doesn't happen at the root because\n      // the root always starts with a \"current\" with a null child.\n      // TODO: Consider unifying this with how the root works.\n      workInProgress.child = reconcileChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, renderExpirationTime);\n      memoizeProps(workInProgress, nextChildren);\n    } else {\n      reconcileChildren(current, workInProgress, nextChildren);\n      memoizeProps(workInProgress, nextChildren);\n    }\n    return workInProgress.child;\n  }\n\n  /*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\n  function bailoutOnAlreadyFinishedWork(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: We should ideally be able to bail out early if the children have no\n    // more work to do. However, since we don't have a separation of this\n    // Fiber's priority and its children yet - we don't know without doing lots\n    // of the same work we do anyway. Once we have that separation we can just\n    // bail out here if the children has no more work at this priority level.\n    // if (workInProgress.priorityOfChildren <= priorityLevel) {\n    //   // If there are side-effects in these children that have not yet been\n    //   // committed we need to ensure that they get properly transferred up.\n    //   if (current && current.child !== workInProgress.child) {\n    //     reuseChildrenEffects(workInProgress, child);\n    //   }\n    //   return null;\n    // }\n\n    cloneChildFibers(current, workInProgress);\n    return workInProgress.child;\n  }\n\n  function bailoutOnLowPriority(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n    // See PR 8590 discussion for context\n    switch (workInProgress.tag) {\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        break;\n      case ClassComponent:\n        pushContextProvider(workInProgress);\n        break;\n      case HostPortal:\n        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n        break;\n    }\n    // TODO: What if this is currently in progress?\n    // How can that happen? How is this not being cloned?\n    return null;\n  }\n\n  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead\n  function memoizeProps(workInProgress, nextProps) {\n    workInProgress.memoizedProps = nextProps;\n  }\n\n  function memoizeState(workInProgress, nextState) {\n    workInProgress.memoizedState = nextState;\n    // Don't reset the updateQueue, in case there are pending updates. Resetting\n    // is handled by processUpdateQueue.\n  }\n\n  function beginWork(current, workInProgress, renderExpirationTime) {\n    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n        return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);\n      case FunctionalComponent:\n        return updateFunctionalComponent(current, workInProgress);\n      case ClassComponent:\n        return updateClassComponent(current, workInProgress, renderExpirationTime);\n      case HostRoot:\n        return updateHostRoot(current, workInProgress, renderExpirationTime);\n      case HostComponent:\n        return updateHostComponent(current, workInProgress, renderExpirationTime);\n      case HostText:\n        return updateHostText(current, workInProgress);\n      case CallHandlerPhase:\n        // This is a restart. Reset the tag to the initial phase.\n        workInProgress.tag = CallComponent;\n      // Intentionally fall through since this is now the same.\n      case CallComponent:\n        return updateCallComponent(current, workInProgress, renderExpirationTime);\n      case ReturnComponent:\n        // A return component is just a placeholder, we can just run through the\n        // next one immediately.\n        return null;\n      case HostPortal:\n        return updatePortalComponent(current, workInProgress, renderExpirationTime);\n      case Fragment:\n        return updateFragment(current, workInProgress);\n      default:\n        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  function beginFailedWork(current, workInProgress, renderExpirationTime) {\n    // Push context providers here to avoid a push/pop context mismatch.\n    switch (workInProgress.tag) {\n      case ClassComponent:\n        pushContextProvider(workInProgress);\n        break;\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        break;\n      default:\n        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    // Add an error effect so we can handle the error during the commit phase\n    workInProgress.effectTag |= Err;\n\n    // This is a weird case where we do \"resume\" work  work that failed on\n    // our first attempt. Because we no longer have a notion of \"progressed\n    // deletions,\" reset the child to the current child to make sure we delete\n    // it again. TODO: Find a better way to handle this, perhaps during a more\n    // general overhaul of error handling.\n    if (current === null) {\n      workInProgress.child = null;\n    } else if (workInProgress.child !== current.child) {\n      workInProgress.child = current.child;\n    }\n\n    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    // If we don't bail out, we're going be recomputing our children so we need\n    // to drop our effect list.\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    // Unmount the current children as if the component rendered null\n    var nextChildren = null;\n    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);\n\n    if (workInProgress.tag === ClassComponent) {\n      var instance = workInProgress.stateNode;\n      workInProgress.memoizedProps = instance.props;\n      workInProgress.memoizedState = instance.state;\n    }\n\n    return workInProgress.child;\n  }\n\n  return {\n    beginWork: beginWork,\n    beginFailedWork: beginFailedWork\n  };\n};\n\nvar ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {\n  var createInstance = config.createInstance,\n      createTextInstance = config.createTextInstance,\n      appendInitialChild = config.appendInitialChild,\n      finalizeInitialChildren = config.finalizeInitialChildren,\n      prepareUpdate = config.prepareUpdate,\n      mutation = config.mutation,\n      persistence = config.persistence;\n  var getRootHostContainer = hostContext.getRootHostContainer,\n      popHostContext = hostContext.popHostContext,\n      getHostContext = hostContext.getHostContext,\n      popHostContainer = hostContext.popHostContainer;\n  var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,\n      prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,\n      popHydrationState = hydrationContext.popHydrationState;\n\n\n  function markUpdate(workInProgress) {\n    // Tag the fiber with an update effect. This turns a Placement into\n    // an UpdateAndPlacement.\n    workInProgress.effectTag |= Update;\n  }\n\n  function markRef(workInProgress) {\n    workInProgress.effectTag |= Ref;\n  }\n\n  function appendAllReturns(returns, workInProgress) {\n    var node = workInProgress.stateNode;\n    if (node) {\n      node['return'] = workInProgress;\n    }\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {\n        invariant(false, 'A call cannot have host component children.');\n      } else if (node.tag === ReturnComponent) {\n        returns.push(node.type);\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === workInProgress) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {\n    var call = workInProgress.memoizedProps;\n    !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    // First step of the call has completed. Now we need to do the second.\n    // TODO: It would be nice to have a multi stage call represented by a\n    // single component, or at least tail call optimize nested ones. Currently\n    // that requires additional fields that we don't want to add to the fiber.\n    // So this requires nested handlers.\n    // Note: This doesn't mutate the alternate node. I don't think it needs to\n    // since this stage is reset for every pass.\n    workInProgress.tag = CallHandlerPhase;\n\n    // Build up the returns.\n    // TODO: Compare this to a generator or opaque helpers like Children.\n    var returns = [];\n    appendAllReturns(returns, workInProgress);\n    var fn = call.handler;\n    var props = call.props;\n    var nextChildren = fn(props, returns);\n\n    var currentFirstChild = current !== null ? current.child : null;\n    workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);\n    return workInProgress.child;\n  }\n\n  function appendAllChildren(parent, workInProgress) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === workInProgress) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  var updateHostContainer = void 0;\n  var updateHostComponent = void 0;\n  var updateHostText = void 0;\n  if (mutation) {\n    if (enableMutatingReconciler) {\n      // Mutation mode\n      updateHostContainer = function (workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n        // TODO: Type this specific to this type of component.\n        workInProgress.updateQueue = updatePayload;\n        // If the update payload indicates that there is a change or if there\n        // is a new ref we mark this as an update. All the work is done in commitWork.\n        if (updatePayload) {\n          markUpdate(workInProgress);\n        }\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        // If the text differs, mark it as an update. All the work in done in commitWork.\n        if (oldText !== newText) {\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, 'Mutating reconciler is disabled.');\n    }\n  } else if (persistence) {\n    if (enablePersistentReconciler) {\n      // Persistent host tree mode\n      var cloneInstance = persistence.cloneInstance,\n          createContainerChildSet = persistence.createContainerChildSet,\n          appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,\n          finalizeContainerChildren = persistence.finalizeContainerChildren;\n\n      // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n      var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {\n        // We only have the top Fiber that was created but we need recurse down its\n        // children to find all the terminal nodes.\n        var node = workInProgress.child;\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            appendChildToContainerChildSet(containerChildSet, node.stateNode);\n          } else if (node.tag === HostPortal) {\n            // If we have a portal child, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n          if (node === workInProgress) {\n            return;\n          }\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n            node = node['return'];\n          }\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      };\n      updateHostContainer = function (workInProgress) {\n        var portalOrRoot = workInProgress.stateNode;\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        if (childrenUnchanged) {\n          // No changes, just reuse the existing instance.\n        } else {\n          var container = portalOrRoot.containerInfo;\n          var newChildSet = createContainerChildSet(container);\n          if (finalizeContainerChildren(container, newChildSet)) {\n            markUpdate(workInProgress);\n          }\n          portalOrRoot.pendingChildren = newChildSet;\n          // If children might have changed, we have to add them all to the set.\n          appendAllChildrenToContainer(newChildSet, workInProgress);\n          // Schedule an update on the container to swap out the container.\n          markUpdate(workInProgress);\n        }\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n        // If there are no effects associated with this node, then none of our children had any updates.\n        // This guarantees that we can reuse all of them.\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        var currentInstance = current.stateNode;\n        if (childrenUnchanged && updatePayload === null) {\n          // No changes, just reuse the existing instance.\n          // Note that this might release a previous clone.\n          workInProgress.stateNode = currentInstance;\n        } else {\n          var recyclableInstance = workInProgress.stateNode;\n          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {\n            markUpdate(workInProgress);\n          }\n          workInProgress.stateNode = newInstance;\n          if (childrenUnchanged) {\n            // If there are no other effects in this tree, we need to flag this node as having one.\n            // Even though we're not going to use it for anything.\n            // Otherwise parents won't know that there are new children to propagate upwards.\n            markUpdate(workInProgress);\n          } else {\n            // If children might have changed, we have to add them all to the set.\n            appendAllChildren(newInstance, workInProgress);\n          }\n        }\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        if (oldText !== newText) {\n          // If the text content differs, we'll create a new text instance for it.\n          var rootContainerInstance = getRootHostContainer();\n          var currentHostContext = getHostContext();\n          workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);\n          // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n          // This lets the parents know that at least one of their children has changed.\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, 'Persistent reconciler is disabled.');\n    }\n  } else {\n    if (enableNoopReconciler) {\n      // No host operations\n      updateHostContainer = function (workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n        // Noop\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        // Noop\n      };\n    } else {\n      invariant(false, 'Noop reconciler is disabled.');\n    }\n  }\n\n  function completeWork(current, workInProgress, renderExpirationTime) {\n    // Get the latest props.\n    var newProps = workInProgress.pendingProps;\n    if (newProps === null) {\n      newProps = workInProgress.memoizedProps;\n    } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {\n      // Reset the pending props, unless this was a down-prioritization.\n      workInProgress.pendingProps = null;\n    }\n\n    switch (workInProgress.tag) {\n      case FunctionalComponent:\n        return null;\n      case ClassComponent:\n        {\n          // We are leaving this subtree, so pop context if any.\n          popContextProvider(workInProgress);\n          return null;\n        }\n      case HostRoot:\n        {\n          popHostContainer(workInProgress);\n          popTopLevelContextObject(workInProgress);\n          var fiberRoot = workInProgress.stateNode;\n          if (fiberRoot.pendingContext) {\n            fiberRoot.context = fiberRoot.pendingContext;\n            fiberRoot.pendingContext = null;\n          }\n\n          if (current === null || current.child === null) {\n            // If we hydrated, pop so that we can delete any remaining children\n            // that weren't hydrated.\n            popHydrationState(workInProgress);\n            // This resets the hacky state to fix isMounted before committing.\n            // TODO: Delete this when we delete isMounted and findDOMNode.\n            workInProgress.effectTag &= ~Placement;\n          }\n          updateHostContainer(workInProgress);\n          return null;\n        }\n      case HostComponent:\n        {\n          popHostContext(workInProgress);\n          var rootContainerInstance = getRootHostContainer();\n          var type = workInProgress.type;\n          if (current !== null && workInProgress.stateNode != null) {\n            // If we have an alternate, that means this is an update and we need to\n            // schedule a side-effect to do the updates.\n            var oldProps = current.memoizedProps;\n            // If we get updated because one of our children updated, we don't\n            // have newProps so we'll have to reuse them.\n            // TODO: Split the update API as separate for the props vs. children.\n            // Even better would be if children weren't special cased at all tho.\n            var instance = workInProgress.stateNode;\n            var currentHostContext = getHostContext();\n            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n\n            updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);\n\n            if (current.ref !== workInProgress.ref) {\n              markRef(workInProgress);\n            }\n          } else {\n            if (!newProps) {\n              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // This can happen when we abort work.\n              return null;\n            }\n\n            var _currentHostContext = getHostContext();\n            // TODO: Move createInstance to beginWork and keep it on a context\n            // \"stack\" as the parent. Then append children as we go in beginWork\n            // or completeWork depending on we want to add then top->down or\n            // bottom->up. Top->down is faster in IE11.\n            var wasHydrated = popHydrationState(workInProgress);\n            if (wasHydrated) {\n              // TODO: Move this and createInstance step into the beginPhase\n              // to consolidate.\n              if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {\n                // If changes to the hydrated node needs to be applied at the\n                // commit-phase we mark this as such.\n                markUpdate(workInProgress);\n              }\n            } else {\n              var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);\n\n              appendAllChildren(_instance, workInProgress);\n\n              // Certain renderers require commit-time effects for initial mount.\n              // (eg DOM renderer supports auto-focus for certain elements).\n              // Make sure such renderers get scheduled for later work.\n              if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {\n                markUpdate(workInProgress);\n              }\n              workInProgress.stateNode = _instance;\n            }\n\n            if (workInProgress.ref !== null) {\n              // If there is a ref on a host node we need to schedule a callback\n              markRef(workInProgress);\n            }\n          }\n          return null;\n        }\n      case HostText:\n        {\n          var newText = newProps;\n          if (current && workInProgress.stateNode != null) {\n            var oldText = current.memoizedProps;\n            // If we have an alternate, that means this is an update and we need\n            // to schedule a side-effect to do the updates.\n            updateHostText(current, workInProgress, oldText, newText);\n          } else {\n            if (typeof newText !== 'string') {\n              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // This can happen when we abort work.\n              return null;\n            }\n            var _rootContainerInstance = getRootHostContainer();\n            var _currentHostContext2 = getHostContext();\n            var _wasHydrated = popHydrationState(workInProgress);\n            if (_wasHydrated) {\n              if (prepareToHydrateHostTextInstance(workInProgress)) {\n                markUpdate(workInProgress);\n              }\n            } else {\n              workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);\n            }\n          }\n          return null;\n        }\n      case CallComponent:\n        return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);\n      case CallHandlerPhase:\n        // Reset the tag to now be a first phase call.\n        workInProgress.tag = CallComponent;\n        return null;\n      case ReturnComponent:\n        // Does nothing.\n        return null;\n      case Fragment:\n        return null;\n      case HostPortal:\n        popHostContainer(workInProgress);\n        updateHostContainer(workInProgress);\n        return null;\n      // Error cases\n      case IndeterminateComponent:\n        invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');\n      // eslint-disable-next-line no-fallthrough\n      default:\n        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  return {\n    completeWork: completeWork\n  };\n};\n\nvar invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError$1 = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError$1 = ReactErrorUtils.clearCaughtError;\n\n\nvar ReactFiberCommitWork = function (config, captureError) {\n  var getPublicInstance = config.getPublicInstance,\n      mutation = config.mutation,\n      persistence = config.persistence;\n\n\n  var callComponentWillUnmountWithTimer = function (current, instance) {\n    startPhaseTimer(current, 'componentWillUnmount');\n    instance.props = current.memoizedProps;\n    instance.state = current.memoizedState;\n    instance.componentWillUnmount();\n    stopPhaseTimer();\n  };\n\n  // Capture errors so they don't interrupt unmounting.\n  function safelyCallComponentWillUnmount(current, instance) {\n    {\n      invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);\n      if (hasCaughtError$1()) {\n        var unmountError = clearCaughtError$1();\n        captureError(current, unmountError);\n      }\n    }\n  }\n\n  function safelyDetachRef(current) {\n    var ref = current.ref;\n    if (ref !== null) {\n      {\n        invokeGuardedCallback$2(null, ref, null, null);\n        if (hasCaughtError$1()) {\n          var refError = clearCaughtError$1();\n          captureError(current, refError);\n        }\n      }\n    }\n  }\n\n  function commitLifeCycles(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          var instance = finishedWork.stateNode;\n          if (finishedWork.effectTag & Update) {\n            if (current === null) {\n              startPhaseTimer(finishedWork, 'componentDidMount');\n              instance.props = finishedWork.memoizedProps;\n              instance.state = finishedWork.memoizedState;\n              instance.componentDidMount();\n              stopPhaseTimer();\n            } else {\n              var prevProps = current.memoizedProps;\n              var prevState = current.memoizedState;\n              startPhaseTimer(finishedWork, 'componentDidUpdate');\n              instance.props = finishedWork.memoizedProps;\n              instance.state = finishedWork.memoizedState;\n              instance.componentDidUpdate(prevProps, prevState);\n              stopPhaseTimer();\n            }\n          }\n          var updateQueue = finishedWork.updateQueue;\n          if (updateQueue !== null) {\n            commitCallbacks(updateQueue, instance);\n          }\n          return;\n        }\n      case HostRoot:\n        {\n          var _updateQueue = finishedWork.updateQueue;\n          if (_updateQueue !== null) {\n            var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;\n            commitCallbacks(_updateQueue, _instance);\n          }\n          return;\n        }\n      case HostComponent:\n        {\n          var _instance2 = finishedWork.stateNode;\n\n          // Renderers may schedule work to be done after host components are mounted\n          // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n          // These effects should only be committed when components are first mounted,\n          // aka when there is no current/alternate.\n          if (current === null && finishedWork.effectTag & Update) {\n            var type = finishedWork.type;\n            var props = finishedWork.memoizedProps;\n            commitMount(_instance2, type, props, finishedWork);\n          }\n\n          return;\n        }\n      case HostText:\n        {\n          // We have no life-cycles associated with text.\n          return;\n        }\n      case HostPortal:\n        {\n          // We have no life-cycles associated with portals.\n          return;\n        }\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitAttachRef(finishedWork) {\n    var ref = finishedWork.ref;\n    if (ref !== null) {\n      var instance = finishedWork.stateNode;\n      switch (finishedWork.tag) {\n        case HostComponent:\n          ref(getPublicInstance(instance));\n          break;\n        default:\n          ref(instance);\n      }\n    }\n  }\n\n  function commitDetachRef(current) {\n    var currentRef = current.ref;\n    if (currentRef !== null) {\n      currentRef(null);\n    }\n  }\n\n  // User-originating errors (lifecycles and refs) should not interrupt\n  // deletion, so don't let them throw. Host-originating errors should\n  // interrupt deletion, so it's okay\n  function commitUnmount(current) {\n    if (typeof onCommitUnmount === 'function') {\n      onCommitUnmount(current);\n    }\n\n    switch (current.tag) {\n      case ClassComponent:\n        {\n          safelyDetachRef(current);\n          var instance = current.stateNode;\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(current, instance);\n          }\n          return;\n        }\n      case HostComponent:\n        {\n          safelyDetachRef(current);\n          return;\n        }\n      case CallComponent:\n        {\n          commitNestedUnmounts(current.stateNode);\n          return;\n        }\n      case HostPortal:\n        {\n          // TODO: this is recursive.\n          // We are also not using this parent because\n          // the portal will get pushed immediately.\n          if (enableMutatingReconciler && mutation) {\n            unmountHostComponents(current);\n          } else if (enablePersistentReconciler && persistence) {\n            emptyPortalContainer(current);\n          }\n          return;\n        }\n    }\n  }\n\n  function commitNestedUnmounts(root) {\n    // While we're inside a removed host node we don't want to call\n    // removeChild on the inner nodes because they're removed by the top\n    // call anyway. We also want to call componentWillUnmount on all\n    // composites before this host node is removed from the tree. Therefore\n    var node = root;\n    while (true) {\n      commitUnmount(node);\n      // Visit children because they may contain more composite or host nodes.\n      // Skip portals because commitUnmount() currently visits them recursively.\n      if (node.child !== null && (\n      // If we use mutation we drill down into portals using commitUnmount above.\n      // If we don't use mutation we drill down into portals here instead.\n      !mutation || node.tag !== HostPortal)) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === root) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === root) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function detachFiber(current) {\n    // Cut off the return pointers to disconnect it from the tree. Ideally, we\n    // should clear the child pointer of the parent alternate to let this\n    // get GC:ed but we don't know which for sure which parent is the current\n    // one so we'll settle for GC:ing the subtree of this child. This child\n    // itself will be GC:ed when the parent updates the next time.\n    current['return'] = null;\n    current.child = null;\n    if (current.alternate) {\n      current.alternate.child = null;\n      current.alternate['return'] = null;\n    }\n  }\n\n  if (!mutation) {\n    var commitContainer = void 0;\n    if (persistence) {\n      var replaceContainerChildren = persistence.replaceContainerChildren,\n          createContainerChildSet = persistence.createContainerChildSet;\n\n      var emptyPortalContainer = function (current) {\n        var portal = current.stateNode;\n        var containerInfo = portal.containerInfo;\n\n        var emptyChildSet = createContainerChildSet(containerInfo);\n        replaceContainerChildren(containerInfo, emptyChildSet);\n      };\n      commitContainer = function (finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent:\n            {\n              return;\n            }\n          case HostComponent:\n            {\n              return;\n            }\n          case HostText:\n            {\n              return;\n            }\n          case HostRoot:\n          case HostPortal:\n            {\n              var portalOrRoot = finishedWork.stateNode;\n              var containerInfo = portalOrRoot.containerInfo,\n                  _pendingChildren = portalOrRoot.pendingChildren;\n\n              replaceContainerChildren(containerInfo, _pendingChildren);\n              return;\n            }\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      };\n    } else {\n      commitContainer = function (finishedWork) {\n        // Noop\n      };\n    }\n    if (enablePersistentReconciler || enableNoopReconciler) {\n      return {\n        commitResetTextContent: function (finishedWork) {},\n        commitPlacement: function (finishedWork) {},\n        commitDeletion: function (current) {\n          // Detach refs and call componentWillUnmount() on the whole subtree.\n          commitNestedUnmounts(current);\n          detachFiber(current);\n        },\n        commitWork: function (current, finishedWork) {\n          commitContainer(finishedWork);\n        },\n\n        commitLifeCycles: commitLifeCycles,\n        commitAttachRef: commitAttachRef,\n        commitDetachRef: commitDetachRef\n      };\n    } else if (persistence) {\n      invariant(false, 'Persistent reconciler is disabled.');\n    } else {\n      invariant(false, 'Noop reconciler is disabled.');\n    }\n  }\n  var commitMount = mutation.commitMount,\n      commitUpdate = mutation.commitUpdate,\n      resetTextContent = mutation.resetTextContent,\n      commitTextUpdate = mutation.commitTextUpdate,\n      appendChild = mutation.appendChild,\n      appendChildToContainer = mutation.appendChildToContainer,\n      insertBefore = mutation.insertBefore,\n      insertInContainerBefore = mutation.insertInContainerBefore,\n      removeChild = mutation.removeChild,\n      removeChildFromContainer = mutation.removeChildFromContainer;\n\n\n  function getHostParentFiber(fiber) {\n    var parent = fiber['return'];\n    while (parent !== null) {\n      if (isHostParent(parent)) {\n        return parent;\n      }\n      parent = parent['return'];\n    }\n    invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  function isHostParent(fiber) {\n    return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n  }\n\n  function getHostSibling(fiber) {\n    // We're going to search forward into the tree until we find a sibling host\n    // node. Unfortunately, if multiple insertions are done in a row we have to\n    // search past them. This leads to exponential search for the next sibling.\n    var node = fiber;\n    siblings: while (true) {\n      // If we didn't find anything, let's try the next sibling.\n      while (node.sibling === null) {\n        if (node['return'] === null || isHostParent(node['return'])) {\n          // If we pop out of the root or hit the parent the fiber we are the\n          // last sibling.\n          return null;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n      while (node.tag !== HostComponent && node.tag !== HostText) {\n        // If it is not host node and, we might have a host node inside it.\n        // Try to search down until we find one.\n        if (node.effectTag & Placement) {\n          // If we don't have a child, try the siblings instead.\n          continue siblings;\n        }\n        // If we don't have a child, try the siblings instead.\n        // We also skip portals because they are not part of this host tree.\n        if (node.child === null || node.tag === HostPortal) {\n          continue siblings;\n        } else {\n          node.child['return'] = node;\n          node = node.child;\n        }\n      }\n      // Check if this host node is stable or about to be placed.\n      if (!(node.effectTag & Placement)) {\n        // Found it!\n        return node.stateNode;\n      }\n    }\n  }\n\n  function commitPlacement(finishedWork) {\n    // Recursively insert all host nodes into the parent.\n    var parentFiber = getHostParentFiber(finishedWork);\n    var parent = void 0;\n    var isContainer = void 0;\n    switch (parentFiber.tag) {\n      case HostComponent:\n        parent = parentFiber.stateNode;\n        isContainer = false;\n        break;\n      case HostRoot:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      case HostPortal:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      default:\n        invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');\n    }\n    if (parentFiber.effectTag & ContentReset) {\n      // Reset the text content of the parent before doing any insertions\n      resetTextContent(parent);\n      // Clear ContentReset from the effect tag\n      parentFiber.effectTag &= ~ContentReset;\n    }\n\n    var before = getHostSibling(finishedWork);\n    // We only have the top Fiber that was inserted but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = finishedWork;\n    while (true) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        if (before) {\n          if (isContainer) {\n            insertInContainerBefore(parent, node.stateNode, before);\n          } else {\n            insertBefore(parent, node.stateNode, before);\n          }\n        } else {\n          if (isContainer) {\n            appendChildToContainer(parent, node.stateNode);\n          } else {\n            appendChild(parent, node.stateNode);\n          }\n        }\n      } else if (node.tag === HostPortal) {\n        // If the insertion itself is a portal, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === finishedWork) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function unmountHostComponents(current) {\n    // We only have the top Fiber that was inserted but we need recurse down its\n    var node = current;\n\n    // Each iteration, currentParent is populated with node's host parent if not\n    // currentParentIsValid.\n    var currentParentIsValid = false;\n    var currentParent = void 0;\n    var currentParentIsContainer = void 0;\n\n    while (true) {\n      if (!currentParentIsValid) {\n        var parent = node['return'];\n        findParent: while (true) {\n          !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          switch (parent.tag) {\n            case HostComponent:\n              currentParent = parent.stateNode;\n              currentParentIsContainer = false;\n              break findParent;\n            case HostRoot:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n            case HostPortal:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n          }\n          parent = parent['return'];\n        }\n        currentParentIsValid = true;\n      }\n\n      if (node.tag === HostComponent || node.tag === HostText) {\n        commitNestedUnmounts(node);\n        // After all the children have unmounted, it is now safe to remove the\n        // node from the tree.\n        if (currentParentIsContainer) {\n          removeChildFromContainer(currentParent, node.stateNode);\n        } else {\n          removeChild(currentParent, node.stateNode);\n        }\n        // Don't visit children because we already visited them.\n      } else if (node.tag === HostPortal) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        // Visit children because portals might contain host components.\n        if (node.child !== null) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n      } else {\n        commitUnmount(node);\n        // Visit children because we may find more host components below.\n        if (node.child !== null) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n      }\n      if (node === current) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === current) {\n          return;\n        }\n        node = node['return'];\n        if (node.tag === HostPortal) {\n          // When we go out of the portal, we need to restore the parent.\n          // Since we don't keep a stack of them, we will search for it.\n          currentParentIsValid = false;\n        }\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function commitDeletion(current) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current);\n    detachFiber(current);\n  }\n\n  function commitWork(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          return;\n        }\n      case HostComponent:\n        {\n          var instance = finishedWork.stateNode;\n          if (instance != null) {\n            // Commit the work prepared earlier.\n            var newProps = finishedWork.memoizedProps;\n            // For hydration we reuse the update path but we treat the oldProps\n            // as the newProps. The updatePayload will contain the real change in\n            // this case.\n            var oldProps = current !== null ? current.memoizedProps : newProps;\n            var type = finishedWork.type;\n            // TODO: Type the updateQueue to be specific to host components.\n            var updatePayload = finishedWork.updateQueue;\n            finishedWork.updateQueue = null;\n            if (updatePayload !== null) {\n              commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n            }\n          }\n          return;\n        }\n      case HostText:\n        {\n          !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          var textInstance = finishedWork.stateNode;\n          var newText = finishedWork.memoizedProps;\n          // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n          var oldText = current !== null ? current.memoizedProps : newText;\n          commitTextUpdate(textInstance, oldText, newText);\n          return;\n        }\n      case HostRoot:\n        {\n          return;\n        }\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitResetTextContent(current) {\n    resetTextContent(current.stateNode);\n  }\n\n  if (enableMutatingReconciler) {\n    return {\n      commitResetTextContent: commitResetTextContent,\n      commitPlacement: commitPlacement,\n      commitDeletion: commitDeletion,\n      commitWork: commitWork,\n      commitLifeCycles: commitLifeCycles,\n      commitAttachRef: commitAttachRef,\n      commitDetachRef: commitDetachRef\n    };\n  } else {\n    invariant(false, 'Mutating reconciler is disabled.');\n  }\n};\n\nvar NO_CONTEXT = {};\n\nvar ReactFiberHostContext = function (config) {\n  var getChildHostContext = config.getChildHostContext,\n      getRootHostContext = config.getRootHostContext;\n\n\n  var contextStackCursor = createCursor(NO_CONTEXT);\n  var contextFiberStackCursor = createCursor(NO_CONTEXT);\n  var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\n  function requiredContext(c) {\n    !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    return c;\n  }\n\n  function getRootHostContainer() {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    return rootInstance;\n  }\n\n  function pushHostContainer(fiber, nextRootInstance) {\n    // Push current root instance onto the stack;\n    // This allows us to reset root when portals are popped.\n    push(rootInstanceStackCursor, nextRootInstance, fiber);\n\n    var nextRootContext = getRootHostContext(nextRootInstance);\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextRootContext, fiber);\n  }\n\n  function popHostContainer(fiber) {\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n    pop(rootInstanceStackCursor, fiber);\n  }\n\n  function getHostContext() {\n    var context = requiredContext(contextStackCursor.current);\n    return context;\n  }\n\n  function pushHostContext(fiber) {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    var context = requiredContext(contextStackCursor.current);\n    var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n    // Don't push this Fiber's context unless it's unique.\n    if (context === nextContext) {\n      return;\n    }\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextContext, fiber);\n  }\n\n  function popHostContext(fiber) {\n    // Do not pop unless this Fiber provided the current context.\n    // pushHostContext() only pushes Fibers that provide unique contexts.\n    if (contextFiberStackCursor.current !== fiber) {\n      return;\n    }\n\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n  }\n\n  function resetHostContainer() {\n    contextStackCursor.current = NO_CONTEXT;\n    rootInstanceStackCursor.current = NO_CONTEXT;\n  }\n\n  return {\n    getHostContext: getHostContext,\n    getRootHostContainer: getRootHostContainer,\n    popHostContainer: popHostContainer,\n    popHostContext: popHostContext,\n    pushHostContainer: pushHostContainer,\n    pushHostContext: pushHostContext,\n    resetHostContainer: resetHostContainer\n  };\n};\n\nvar ReactFiberHydrationContext = function (config) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n      hydration = config.hydration;\n\n  // If this doesn't have hydration mode.\n\n  if (!hydration) {\n    return {\n      enterHydrationState: function () {\n        return false;\n      },\n      resetHydrationState: function () {},\n      tryToClaimNextHydratableInstance: function () {},\n      prepareToHydrateHostInstance: function () {\n        invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n      },\n      prepareToHydrateHostTextInstance: function () {\n        invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n      },\n      popHydrationState: function (fiber) {\n        return false;\n      }\n    };\n  }\n\n  var canHydrateInstance = hydration.canHydrateInstance,\n      canHydrateTextInstance = hydration.canHydrateTextInstance,\n      getNextHydratableSibling = hydration.getNextHydratableSibling,\n      getFirstHydratableChild = hydration.getFirstHydratableChild,\n      hydrateInstance = hydration.hydrateInstance,\n      hydrateTextInstance = hydration.hydrateTextInstance,\n      didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,\n      didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,\n      didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,\n      didNotHydrateInstance = hydration.didNotHydrateInstance,\n      didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,\n      didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,\n      didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,\n      didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;\n\n  // The deepest Fiber on the stack involved in a hydration context.\n  // This may have been an insertion or a hydration.\n\n  var hydrationParentFiber = null;\n  var nextHydratableInstance = null;\n  var isHydrating = false;\n\n  function enterHydrationState(fiber) {\n    var parentInstance = fiber.stateNode.containerInfo;\n    nextHydratableInstance = getFirstHydratableChild(parentInstance);\n    hydrationParentFiber = fiber;\n    isHydrating = true;\n    return true;\n  }\n\n  function deleteHydratableInstance(returnFiber, instance) {\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\n          break;\n        case HostComponent:\n          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n          break;\n      }\n    }\n\n    var childToDelete = createFiberFromHostInstanceForDeletion();\n    childToDelete.stateNode = instance;\n    childToDelete['return'] = returnFiber;\n    childToDelete.effectTag = Deletion;\n\n    // This might seem like it belongs on progressedFirstDeletion. However,\n    // these children are not part of the reconciliation list of children.\n    // Even if we abort and rereconcile the children, that will try to hydrate\n    // again and the nodes are still in the host tree so these will be\n    // recreated.\n    if (returnFiber.lastEffect !== null) {\n      returnFiber.lastEffect.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n  }\n\n  function insertNonHydratedInstance(returnFiber, fiber) {\n    fiber.effectTag |= Placement;\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          {\n            var parentContainer = returnFiber.stateNode.containerInfo;\n            switch (fiber.tag) {\n              case HostComponent:\n                var type = fiber.type;\n                var props = fiber.pendingProps;\n                didNotFindHydratableContainerInstance(parentContainer, type, props);\n                break;\n              case HostText:\n                var text = fiber.pendingProps;\n                didNotFindHydratableContainerTextInstance(parentContainer, text);\n                break;\n            }\n            break;\n          }\n        case HostComponent:\n          {\n            var parentType = returnFiber.type;\n            var parentProps = returnFiber.memoizedProps;\n            var parentInstance = returnFiber.stateNode;\n            switch (fiber.tag) {\n              case HostComponent:\n                var _type = fiber.type;\n                var _props = fiber.pendingProps;\n                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n                break;\n              case HostText:\n                var _text = fiber.pendingProps;\n                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n                break;\n            }\n            break;\n          }\n        default:\n          return;\n      }\n    }\n  }\n\n  function tryHydrate(fiber, nextInstance) {\n    switch (fiber.tag) {\n      case HostComponent:\n        {\n          var type = fiber.type;\n          var props = fiber.pendingProps;\n          var instance = canHydrateInstance(nextInstance, type, props);\n          if (instance !== null) {\n            fiber.stateNode = instance;\n            return true;\n          }\n          return false;\n        }\n      case HostText:\n        {\n          var text = fiber.pendingProps;\n          var textInstance = canHydrateTextInstance(nextInstance, text);\n          if (textInstance !== null) {\n            fiber.stateNode = textInstance;\n            return true;\n          }\n          return false;\n        }\n      default:\n        return false;\n    }\n  }\n\n  function tryToClaimNextHydratableInstance(fiber) {\n    if (!isHydrating) {\n      return;\n    }\n    var nextInstance = nextHydratableInstance;\n    if (!nextInstance) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    if (!tryHydrate(fiber, nextInstance)) {\n      // If we can't hydrate this instance let's try the next one.\n      // We use this as a heuristic. It's based on intuition and not data so it\n      // might be flawed or unnecessary.\n      nextInstance = getNextHydratableSibling(nextInstance);\n      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n        // Nothing to hydrate. Make it an insertion.\n        insertNonHydratedInstance(hydrationParentFiber, fiber);\n        isHydrating = false;\n        hydrationParentFiber = fiber;\n        return;\n      }\n      // We matched the next one, we'll now assume that the first one was\n      // superfluous and we'll delete it. Since we can't eagerly delete it\n      // we'll have to schedule a deletion. To do that, this node needs a dummy\n      // fiber associated with it.\n      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);\n    }\n    hydrationParentFiber = fiber;\n    nextHydratableInstance = getFirstHydratableChild(nextInstance);\n  }\n\n  function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n    var instance = fiber.stateNode;\n    var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);\n    // TODO: Type this specific to this type of component.\n    fiber.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update.\n    if (updatePayload !== null) {\n      return true;\n    }\n    return false;\n  }\n\n  function prepareToHydrateHostTextInstance(fiber) {\n    var textInstance = fiber.stateNode;\n    var textContent = fiber.memoizedProps;\n    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n    {\n      if (shouldUpdate) {\n        // We assume that prepareToHydrateHostTextInstance is called in a context where the\n        // hydration parent is the parent host component of this host text.\n        var returnFiber = hydrationParentFiber;\n        if (returnFiber !== null) {\n          switch (returnFiber.tag) {\n            case HostRoot:\n              {\n                var parentContainer = returnFiber.stateNode.containerInfo;\n                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n                break;\n              }\n            case HostComponent:\n              {\n                var parentType = returnFiber.type;\n                var parentProps = returnFiber.memoizedProps;\n                var parentInstance = returnFiber.stateNode;\n                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n                break;\n              }\n          }\n        }\n      }\n    }\n    return shouldUpdate;\n  }\n\n  function popToNextHostParent(fiber) {\n    var parent = fiber['return'];\n    while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {\n      parent = parent['return'];\n    }\n    hydrationParentFiber = parent;\n  }\n\n  function popHydrationState(fiber) {\n    if (fiber !== hydrationParentFiber) {\n      // We're deeper than the current hydration context, inside an inserted\n      // tree.\n      return false;\n    }\n    if (!isHydrating) {\n      // If we're not currently hydrating but we're in a hydration context, then\n      // we were an insertion and now need to pop up reenter hydration of our\n      // siblings.\n      popToNextHostParent(fiber);\n      isHydrating = true;\n      return false;\n    }\n\n    var type = fiber.type;\n\n    // If we have any remaining hydratable nodes, we need to delete them now.\n    // We only do this deeper than head and body since they tend to have random\n    // other nodes in them. We also ignore components with pure text content in\n    // side of them.\n    // TODO: Better heuristic.\n    if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n      var nextInstance = nextHydratableInstance;\n      while (nextInstance) {\n        deleteHydratableInstance(fiber, nextInstance);\n        nextInstance = getNextHydratableSibling(nextInstance);\n      }\n    }\n\n    popToNextHostParent(fiber);\n    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n    return true;\n  }\n\n  function resetHydrationState() {\n    hydrationParentFiber = null;\n    nextHydratableInstance = null;\n    isHydrating = false;\n  }\n\n  return {\n    enterHydrationState: enterHydrationState,\n    resetHydrationState: resetHydrationState,\n    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,\n    prepareToHydrateHostInstance: prepareToHydrateHostInstance,\n    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,\n    popHydrationState: popHydrationState\n  };\n};\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\nvar defaultShowDialog = function (capturedError) {\n  return true;\n};\n\nvar showDialog = defaultShowDialog;\n\nfunction logCapturedError(capturedError) {\n  var logError = showDialog(capturedError);\n\n  // Allow injected showDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  {\n    var componentName = capturedError.componentName,\n        componentStack = capturedError.componentStack,\n        errorBoundaryName = capturedError.errorBoundaryName,\n        errorBoundaryFound = capturedError.errorBoundaryFound,\n        willRetry = capturedError.willRetry;\n\n\n    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');\n      } else {\n        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';\n      }\n    } else {\n      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';\n    }\n    var combinedMessage = '' + componentNameMessage + componentStack + '\\n\\n' + ('' + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar invokeGuardedCallback$1 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError = ReactErrorUtils.clearCaughtError;\n\n\n{\n  var didWarnAboutStateTransition = false;\n  var didWarnSetStateChildContext = false;\n  var didWarnStateUpdateForUnmountedComponent = {};\n\n  var warnAboutUpdateOnUnmounted = function (fiber) {\n    var componentName = getComponentName(fiber) || 'ReactClass';\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\\n\\nPlease ' + 'check the code for the %s component.', componentName);\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  var warnAboutInvalidUpdates = function (instance) {\n    switch (ReactDebugCurrentFiber.phase) {\n      case 'getChildContext':\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warning(false, 'setState(...): Cannot call setState() inside getChildContext()');\n        didWarnSetStateChildContext = true;\n        break;\n      case 'render':\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warning(false, 'Cannot update during an existing state transition (such as within ' + \"`render` or another component's constructor). Render methods should \" + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\nvar ReactFiberScheduler = function (config) {\n  var hostContext = ReactFiberHostContext(config);\n  var hydrationContext = ReactFiberHydrationContext(config);\n  var popHostContainer = hostContext.popHostContainer,\n      popHostContext = hostContext.popHostContext,\n      resetHostContainer = hostContext.resetHostContainer;\n\n  var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),\n      beginWork = _ReactFiberBeginWork.beginWork,\n      beginFailedWork = _ReactFiberBeginWork.beginFailedWork;\n\n  var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),\n      completeWork = _ReactFiberCompleteWo.completeWork;\n\n  var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),\n      commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,\n      commitPlacement = _ReactFiberCommitWork.commitPlacement,\n      commitDeletion = _ReactFiberCommitWork.commitDeletion,\n      commitWork = _ReactFiberCommitWork.commitWork,\n      commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,\n      commitAttachRef = _ReactFiberCommitWork.commitAttachRef,\n      commitDetachRef = _ReactFiberCommitWork.commitDetachRef;\n\n  var now = config.now,\n      scheduleDeferredCallback = config.scheduleDeferredCallback,\n      useSyncScheduling = config.useSyncScheduling,\n      prepareForCommit = config.prepareForCommit,\n      resetAfterCommit = config.resetAfterCommit;\n\n  // Represents the current time in ms.\n\n  var startTime = now();\n  var mostRecentCurrentTime = msToExpirationTime(0);\n\n  // Represents the expiration time that incoming updates should use. (If this\n  // is NoWork, use the default strategy: async updates in async mode, sync\n  // updates in sync mode.)\n  var expirationContext = NoWork;\n\n  var isWorking = false;\n\n  // The next work in progress fiber that we're currently working on.\n  var nextUnitOfWork = null;\n  var nextRoot = null;\n  // The time at which we're currently rendering work.\n  var nextRenderExpirationTime = NoWork;\n\n  // The next fiber with an effect that we're currently committing.\n  var nextEffect = null;\n\n  // Keep track of which fibers have captured an error that need to be handled.\n  // Work is removed from this collection after componentDidCatch is called.\n  var capturedErrors = null;\n  // Keep track of which fibers have failed during the current batch of work.\n  // This is a different set than capturedErrors, because it is not reset until\n  // the end of the batch. This is needed to propagate errors correctly if a\n  // subtree fails more than once.\n  var failedBoundaries = null;\n  // Error boundaries that captured an error during the current commit.\n  var commitPhaseBoundaries = null;\n  var firstUncaughtError = null;\n  var didFatal = false;\n\n  var isCommitting = false;\n  var isUnmounting = false;\n\n  // Used for performance tracking.\n  var interruptedBy = null;\n\n  function resetContextStack() {\n    // Reset the stack\n    reset$1();\n    // Reset the cursors\n    resetContext();\n    resetHostContainer();\n  }\n\n  function commitAllHostEffects() {\n    while (nextEffect !== null) {\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n      }\n      recordEffect();\n\n      var effectTag = nextEffect.effectTag;\n      if (effectTag & ContentReset) {\n        commitResetTextContent(nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        var current = nextEffect.alternate;\n        if (current !== null) {\n          commitDetachRef(current);\n        }\n      }\n\n      // The following switch statement is only concerned about placement,\n      // updates, and deletions. To avoid needing to add a case for every\n      // possible bitmap value, we remove the secondary effects from the\n      // effect tag and switch on that value.\n      var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);\n      switch (primaryEffectTag) {\n        case Placement:\n          {\n            commitPlacement(nextEffect);\n            // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n            // any life-cycles like componentDidMount gets called.\n            // TODO: findDOMNode doesn't rely on this any more but isMounted\n            // does and isMounted is deprecated anyway so we should be able\n            // to kill this.\n            nextEffect.effectTag &= ~Placement;\n            break;\n          }\n        case PlacementAndUpdate:\n          {\n            // Placement\n            commitPlacement(nextEffect);\n            // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n            // any life-cycles like componentDidMount gets called.\n            nextEffect.effectTag &= ~Placement;\n\n            // Update\n            var _current = nextEffect.alternate;\n            commitWork(_current, nextEffect);\n            break;\n          }\n        case Update:\n          {\n            var _current2 = nextEffect.alternate;\n            commitWork(_current2, nextEffect);\n            break;\n          }\n        case Deletion:\n          {\n            isUnmounting = true;\n            commitDeletion(nextEffect);\n            isUnmounting = false;\n            break;\n          }\n      }\n      nextEffect = nextEffect.nextEffect;\n    }\n\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n  }\n\n  function commitAllLifeCycles() {\n    while (nextEffect !== null) {\n      var effectTag = nextEffect.effectTag;\n\n      if (effectTag & (Update | Callback)) {\n        recordEffect();\n        var current = nextEffect.alternate;\n        commitLifeCycles(current, nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        recordEffect();\n        commitAttachRef(nextEffect);\n      }\n\n      if (effectTag & Err) {\n        recordEffect();\n        commitErrorHandling(nextEffect);\n      }\n\n      var next = nextEffect.nextEffect;\n      // Ensure that we clean these up so that we don't accidentally keep them.\n      // I'm not actually sure this matters because we can't reset firstEffect\n      // and lastEffect since they're on every node, not just the effectful\n      // ones. So we have to clean everything as we reuse nodes anyway.\n      nextEffect.nextEffect = null;\n      // Ensure that we reset the effectTag here so that we can rely on effect\n      // tags to reason about the current life-cycle.\n      nextEffect = next;\n    }\n  }\n\n  function commitRoot(finishedWork) {\n    // We keep track of this so that captureError can collect any boundaries\n    // that capture an error during the commit phase. The reason these aren't\n    // local to this function is because errors that occur during cWU are\n    // captured elsewhere, to prevent the unmount from being interrupted.\n    isWorking = true;\n    isCommitting = true;\n    startCommitTimer();\n\n    var root = finishedWork.stateNode;\n    !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    root.isReadyForCommit = false;\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    var firstEffect = void 0;\n    if (finishedWork.effectTag > PerformedWork) {\n      // A fiber's effect list consists only of its children, not itself. So if\n      // the root has an effect, we need to add it to the end of the list. The\n      // resulting list is the set that would belong to the root's parent, if\n      // it had one; that is, all the effects in the tree including the root.\n      if (finishedWork.lastEffect !== null) {\n        finishedWork.lastEffect.nextEffect = finishedWork;\n        firstEffect = finishedWork.firstEffect;\n      } else {\n        firstEffect = finishedWork;\n      }\n    } else {\n      // There is no effect on the root.\n      firstEffect = finishedWork.firstEffect;\n    }\n\n    prepareForCommit();\n\n    // Commit all the side-effects within a tree. We'll do this in two passes.\n    // The first pass performs all the host insertions, updates, deletions and\n    // ref unmounts.\n    nextEffect = firstEffect;\n    startCommitHostEffectsTimer();\n    while (nextEffect !== null) {\n      var didError = false;\n      var _error = void 0;\n      {\n        invokeGuardedCallback$1(null, commitAllHostEffects, null);\n        if (hasCaughtError()) {\n          didError = true;\n          _error = clearCaughtError();\n        }\n      }\n      if (didError) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        captureError(nextEffect, _error);\n        // Clean-up\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n    stopCommitHostEffectsTimer();\n\n    resetAfterCommit();\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the first pass of the commit phase, so that the previous tree is still\n    // current during componentWillUnmount, but before the second pass, so that\n    // the finished work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // In the second pass we'll perform all life-cycles and ref callbacks.\n    // Life-cycles happen as a separate pass so that all placements, updates,\n    // and deletions in the entire tree have already been invoked.\n    // This pass also triggers any renderer-specific initial effects.\n    nextEffect = firstEffect;\n    startCommitLifeCyclesTimer();\n    while (nextEffect !== null) {\n      var _didError = false;\n      var _error2 = void 0;\n      {\n        invokeGuardedCallback$1(null, commitAllLifeCycles, null);\n        if (hasCaughtError()) {\n          _didError = true;\n          _error2 = clearCaughtError();\n        }\n      }\n      if (_didError) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        captureError(nextEffect, _error2);\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n\n    isCommitting = false;\n    isWorking = false;\n    stopCommitLifeCyclesTimer();\n    stopCommitTimer();\n    if (typeof onCommitRoot === 'function') {\n      onCommitRoot(finishedWork.stateNode);\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n    }\n\n    // If we caught any errors during this commit, schedule their boundaries\n    // to update.\n    if (commitPhaseBoundaries) {\n      commitPhaseBoundaries.forEach(scheduleErrorRecovery);\n      commitPhaseBoundaries = null;\n    }\n\n    if (firstUncaughtError !== null) {\n      var _error3 = firstUncaughtError;\n      firstUncaughtError = null;\n      onUncaughtError(_error3);\n    }\n\n    var remainingTime = root.current.expirationTime;\n\n    if (remainingTime === NoWork) {\n      capturedErrors = null;\n      failedBoundaries = null;\n    }\n\n    return remainingTime;\n  }\n\n  function resetExpirationTime(workInProgress, renderTime) {\n    if (renderTime !== Never && workInProgress.expirationTime === Never) {\n      // The children of this component are hidden. Don't bubble their\n      // expiration times.\n      return;\n    }\n\n    // Check for pending updates.\n    var newExpirationTime = getUpdateExpirationTime(workInProgress);\n\n    // TODO: Calls need to visit stateNode\n\n    // Bubble up the earliest expiration time.\n    var child = workInProgress.child;\n    while (child !== null) {\n      if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {\n        newExpirationTime = child.expirationTime;\n      }\n      child = child.sibling;\n    }\n    workInProgress.expirationTime = newExpirationTime;\n  }\n\n  function completeUnitOfWork(workInProgress) {\n    while (true) {\n      // The current, flushed, state of this fiber is the alternate.\n      // Ideally nothing should rely on this, but relying on it here\n      // means that we don't need an additional field on the work in\n      // progress.\n      var current = workInProgress.alternate;\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n      }\n      var next = completeWork(current, workInProgress, nextRenderExpirationTime);\n      {\n        ReactDebugCurrentFiber.resetCurrentFiber();\n      }\n\n      var returnFiber = workInProgress['return'];\n      var siblingFiber = workInProgress.sibling;\n\n      resetExpirationTime(workInProgress, nextRenderExpirationTime);\n\n      if (next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        return next;\n      }\n\n      if (returnFiber !== null) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if\n        // needed, by doing multiple passes over the effect list. We don't want\n        // to schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        var effectTag = workInProgress.effectTag;\n        // Skip both NoWork and PerformedWork tags when creating the effect list.\n        // PerformedWork effect is read by React DevTools but shouldn't be committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n\n      stopWorkTimer(workInProgress);\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        // We've reached the root.\n        var root = workInProgress.stateNode;\n        root.isReadyForCommit = true;\n        return null;\n      }\n    }\n\n    // Without this explicit null return Flow complains of invalid return type\n    // TODO Remove the above while(true) loop\n    // eslint-disable-next-line no-unreachable\n    return null;\n  }\n\n  function performUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    startWorkTimer(workInProgress);\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n    var next = beginWork(current, workInProgress, nextRenderExpirationTime);\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n  function performFailedUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    startWorkTimer(workInProgress);\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n    var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n  function workLoop(expirationTime) {\n    if (capturedErrors !== null) {\n      // If there are unhandled errors, switch to the slow work loop.\n      // TODO: How to avoid this check in the fast path? Maybe the renderer\n      // could keep track of which roots have unhandled errors and call a\n      // forked version of renderRoot.\n      slowWorkLoopThatChecksForFailedWork(expirationTime);\n      return;\n    }\n    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n      return;\n    }\n\n    if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n      // Flush all expired work.\n      while (nextUnitOfWork !== null) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    }\n  }\n\n  function slowWorkLoopThatChecksForFailedWork(expirationTime) {\n    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n      return;\n    }\n\n    if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n      // Flush all expired work.\n      while (nextUnitOfWork !== null) {\n        if (hasCapturedError(nextUnitOfWork)) {\n          // Use a forked version of performUnitOfWork\n          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n        } else {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        }\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        if (hasCapturedError(nextUnitOfWork)) {\n          // Use a forked version of performUnitOfWork\n          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n        } else {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        }\n      }\n    }\n  }\n\n  function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {\n    // We're going to restart the error boundary that captured the error.\n    // Conceptually, we're unwinding the stack. We need to unwind the\n    // context stack, too.\n    unwindContexts(failedWork, boundary);\n\n    // Restart the error boundary using a forked version of\n    // performUnitOfWork that deletes the boundary's children. The entire\n    // failed subree will be unmounted. During the commit phase, a special\n    // lifecycle method is called on the error boundary, which triggers\n    // a re-render.\n    nextUnitOfWork = performFailedUnitOfWork(boundary);\n\n    // Continue working.\n    workLoop(expirationTime);\n  }\n\n  function renderRoot(root, expirationTime) {\n    !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    isWorking = true;\n\n    // We're about to mutate the work-in-progress tree. If the root was pending\n    // commit, it no longer is: we'll need to complete it again.\n    root.isReadyForCommit = false;\n\n    // Check if we're starting from a fresh stack, or if we're resuming from\n    // previously yielded work.\n    if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {\n      // Reset the stack and start working from the root.\n      resetContextStack();\n      nextRoot = root;\n      nextRenderExpirationTime = expirationTime;\n      nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);\n    }\n\n    startWorkLoopTimer(nextUnitOfWork);\n\n    var didError = false;\n    var error = null;\n    {\n      invokeGuardedCallback$1(null, workLoop, null, expirationTime);\n      if (hasCaughtError()) {\n        didError = true;\n        error = clearCaughtError();\n      }\n    }\n\n    // An error was thrown during the render phase.\n    while (didError) {\n      if (didFatal) {\n        // This was a fatal error. Don't attempt to recover from it.\n        firstUncaughtError = error;\n        break;\n      }\n\n      var failedWork = nextUnitOfWork;\n      if (failedWork === null) {\n        // An error was thrown but there's no current unit of work. This can\n        // happen during the commit phase if there's a bug in the renderer.\n        didFatal = true;\n        continue;\n      }\n\n      // \"Capture\" the error by finding the nearest boundary. If there is no\n      // error boundary, we use the root.\n      var boundary = captureError(failedWork, error);\n      !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n      if (didFatal) {\n        // The error we just captured was a fatal error. This happens\n        // when the error propagates to the root more than once.\n        continue;\n      }\n\n      didError = false;\n      error = null;\n      {\n        invokeGuardedCallback$1(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);\n        if (hasCaughtError()) {\n          didError = true;\n          error = clearCaughtError();\n          continue;\n        }\n      }\n      // We're finished working. Exit the error loop.\n      break;\n    }\n\n    var uncaughtError = firstUncaughtError;\n\n    // We're done performing work. Time to clean up.\n    stopWorkLoopTimer(interruptedBy);\n    interruptedBy = null;\n    isWorking = false;\n    didFatal = false;\n    firstUncaughtError = null;\n\n    if (uncaughtError !== null) {\n      onUncaughtError(uncaughtError);\n    }\n\n    return root.isReadyForCommit ? root.current.alternate : null;\n  }\n\n  // Returns the boundary that captured the error, or null if the error is ignored\n  function captureError(failedWork, error) {\n    // It is no longer valid because we exited the user code.\n    ReactCurrentOwner.current = null;\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n\n    // Search for the nearest error boundary.\n    var boundary = null;\n\n    // Passed to logCapturedError()\n    var errorBoundaryFound = false;\n    var willRetry = false;\n    var errorBoundaryName = null;\n\n    // Host containers are a special case. If the failed work itself is a host\n    // container, then it acts as its own boundary. In all other cases, we\n    // ignore the work itself and only search through the parents.\n    if (failedWork.tag === HostRoot) {\n      boundary = failedWork;\n\n      if (isFailedBoundary(failedWork)) {\n        // If this root already failed, there must have been an error when\n        // attempting to unmount it. This is a worst-case scenario and\n        // should only be possible if there's a bug in the renderer.\n        didFatal = true;\n      }\n    } else {\n      var node = failedWork['return'];\n      while (node !== null && boundary === null) {\n        if (node.tag === ClassComponent) {\n          var instance = node.stateNode;\n          if (typeof instance.componentDidCatch === 'function') {\n            errorBoundaryFound = true;\n            errorBoundaryName = getComponentName(node);\n\n            // Found an error boundary!\n            boundary = node;\n            willRetry = true;\n          }\n        } else if (node.tag === HostRoot) {\n          // Treat the root like a no-op error boundary\n          boundary = node;\n        }\n\n        if (isFailedBoundary(node)) {\n          // This boundary is already in a failed state.\n\n          // If we're currently unmounting, that means this error was\n          // thrown while unmounting a failed subtree. We should ignore\n          // the error.\n          if (isUnmounting) {\n            return null;\n          }\n\n          // If we're in the commit phase, we should check to see if\n          // this boundary already captured an error during this commit.\n          // This case exists because multiple errors can be thrown during\n          // a single commit without interruption.\n          if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {\n            // If so, we should ignore this error.\n            return null;\n          }\n\n          // The error should propagate to the next boundary - we keep looking.\n          boundary = null;\n          willRetry = false;\n        }\n\n        node = node['return'];\n      }\n    }\n\n    if (boundary !== null) {\n      // Add to the collection of failed boundaries. This lets us know that\n      // subsequent errors in this subtree should propagate to the next boundary.\n      if (failedBoundaries === null) {\n        failedBoundaries = new Set();\n      }\n      failedBoundaries.add(boundary);\n\n      // This method is unsafe outside of the begin and complete phases.\n      // We might be in the commit phase when an error is captured.\n      // The risk is that the return path from this Fiber may not be accurate.\n      // That risk is acceptable given the benefit of providing users more context.\n      var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);\n      var _componentName = getComponentName(failedWork);\n\n      // Add to the collection of captured errors. This is stored as a global\n      // map of errors and their component stack location keyed by the boundaries\n      // that capture them. We mostly use this Map as a Set; it's a Map only to\n      // avoid adding a field to Fiber to store the error.\n      if (capturedErrors === null) {\n        capturedErrors = new Map();\n      }\n\n      var capturedError = {\n        componentName: _componentName,\n        componentStack: _componentStack,\n        error: error,\n        errorBoundary: errorBoundaryFound ? boundary.stateNode : null,\n        errorBoundaryFound: errorBoundaryFound,\n        errorBoundaryName: errorBoundaryName,\n        willRetry: willRetry\n      };\n\n      capturedErrors.set(boundary, capturedError);\n\n      try {\n        logCapturedError(capturedError);\n      } catch (e) {\n        // Prevent cycle if logCapturedError() throws.\n        // A cycle may still occur if logCapturedError renders a component that throws.\n        console.error(e);\n      }\n\n      // If we're in the commit phase, defer scheduling an update on the\n      // boundary until after the commit is complete\n      if (isCommitting) {\n        if (commitPhaseBoundaries === null) {\n          commitPhaseBoundaries = new Set();\n        }\n        commitPhaseBoundaries.add(boundary);\n      } else {\n        // Otherwise, schedule an update now.\n        // TODO: Is this actually necessary during the render phase? Is it\n        // possible to unwind and continue rendering at the same priority,\n        // without corrupting internal state?\n        scheduleErrorRecovery(boundary);\n      }\n      return boundary;\n    } else if (firstUncaughtError === null) {\n      // If no boundary is found, we'll need to throw the error\n      firstUncaughtError = error;\n    }\n    return null;\n  }\n\n  function hasCapturedError(fiber) {\n    // TODO: capturedErrors should store the boundary instance, to avoid needing\n    // to check the alternate.\n    return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));\n  }\n\n  function isFailedBoundary(fiber) {\n    // TODO: failedBoundaries should store the boundary instance, to avoid\n    // needing to check the alternate.\n    return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));\n  }\n\n  function commitErrorHandling(effectfulFiber) {\n    var capturedError = void 0;\n    if (capturedErrors !== null) {\n      capturedError = capturedErrors.get(effectfulFiber);\n      capturedErrors['delete'](effectfulFiber);\n      if (capturedError == null) {\n        if (effectfulFiber.alternate !== null) {\n          effectfulFiber = effectfulFiber.alternate;\n          capturedError = capturedErrors.get(effectfulFiber);\n          capturedErrors['delete'](effectfulFiber);\n        }\n      }\n    }\n\n    !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    switch (effectfulFiber.tag) {\n      case ClassComponent:\n        var instance = effectfulFiber.stateNode;\n\n        var info = {\n          componentStack: capturedError.componentStack\n        };\n\n        // Allow the boundary to handle the error, usually by scheduling\n        // an update to itself\n        instance.componentDidCatch(capturedError.error, info);\n        return;\n      case HostRoot:\n        if (firstUncaughtError === null) {\n          firstUncaughtError = capturedError.error;\n        }\n        return;\n      default:\n        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  function unwindContexts(from, to) {\n    var node = from;\n    while (node !== null) {\n      switch (node.tag) {\n        case ClassComponent:\n          popContextProvider(node);\n          break;\n        case HostComponent:\n          popHostContext(node);\n          break;\n        case HostRoot:\n          popHostContainer(node);\n          break;\n        case HostPortal:\n          popHostContainer(node);\n          break;\n      }\n      if (node === to || node.alternate === to) {\n        stopFailedWorkTimer(node);\n        break;\n      } else {\n        stopWorkTimer(node);\n      }\n      node = node['return'];\n    }\n  }\n\n  function computeAsyncExpiration() {\n    // Given the current clock time, returns an expiration time. We use rounding\n    // to batch like updates together.\n    // Should complete within ~1000ms. 1200ms max.\n    var currentTime = recalculateCurrentTime();\n    var expirationMs = 1000;\n    var bucketSizeMs = 200;\n    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n  }\n\n  function computeExpirationForFiber(fiber) {\n    var expirationTime = void 0;\n    if (expirationContext !== NoWork) {\n      // An explicit expiration context was set;\n      expirationTime = expirationContext;\n    } else if (isWorking) {\n      if (isCommitting) {\n        // Updates that occur during the commit phase should have sync priority\n        // by default.\n        expirationTime = Sync;\n      } else {\n        // Updates during the render phase should expire at the same time as\n        // the work that is being rendered.\n        expirationTime = nextRenderExpirationTime;\n      }\n    } else {\n      // No explicit expiration context was set, and we're not currently\n      // performing work. Calculate a new expiration time.\n      if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {\n        // This is a sync update\n        expirationTime = Sync;\n      } else {\n        // This is an async update\n        expirationTime = computeAsyncExpiration();\n      }\n    }\n    return expirationTime;\n  }\n\n  function scheduleWork(fiber, expirationTime) {\n    return scheduleWorkImpl(fiber, expirationTime, false);\n  }\n\n  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {\n    recordScheduleUpdate();\n\n    {\n      if (!isErrorRecovery && fiber.tag === ClassComponent) {\n        var instance = fiber.stateNode;\n        warnAboutInvalidUpdates(instance);\n      }\n    }\n\n    var node = fiber;\n    while (node !== null) {\n      // Walk the parent path to the root and update each node's\n      // expiration time.\n      if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {\n        node.expirationTime = expirationTime;\n      }\n      if (node.alternate !== null) {\n        if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {\n          node.alternate.expirationTime = expirationTime;\n        }\n      }\n      if (node['return'] === null) {\n        if (node.tag === HostRoot) {\n          var root = node.stateNode;\n          if (!isWorking && root === nextRoot && expirationTime <= nextRenderExpirationTime) {\n            // Restart the root from the top.\n            if (nextUnitOfWork !== null) {\n              // This is an interruption. (Used for performance tracking.)\n              interruptedBy = fiber;\n            }\n            nextRoot = null;\n            nextUnitOfWork = null;\n            nextRenderExpirationTime = NoWork;\n          }\n          requestWork(root, expirationTime);\n        } else {\n          {\n            if (!isErrorRecovery && fiber.tag === ClassComponent) {\n              warnAboutUpdateOnUnmounted(fiber);\n            }\n          }\n          return;\n        }\n      }\n      node = node['return'];\n    }\n  }\n\n  function scheduleErrorRecovery(fiber) {\n    scheduleWorkImpl(fiber, Sync, true);\n  }\n\n  function recalculateCurrentTime() {\n    // Subtract initial time so it fits inside 32bits\n    var ms = now() - startTime;\n    mostRecentCurrentTime = msToExpirationTime(ms);\n    return mostRecentCurrentTime;\n  }\n\n  function deferredUpdates(fn) {\n    var previousExpirationContext = expirationContext;\n    expirationContext = computeAsyncExpiration();\n    try {\n      return fn();\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n\n  function syncUpdates(fn) {\n    var previousExpirationContext = expirationContext;\n    expirationContext = Sync;\n    try {\n      return fn();\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n\n  // TODO: Everything below this is written as if it has been lifted to the\n  // renderers. I'll do this in a follow-up.\n\n  // Linked-list of roots\n  var firstScheduledRoot = null;\n  var lastScheduledRoot = null;\n\n  var isCallbackScheduled = false;\n  var isRendering = false;\n  var nextFlushedRoot = null;\n  var nextFlushedExpirationTime = NoWork;\n  var deadlineDidExpire = false;\n  var hasUnhandledError = false;\n  var unhandledError = null;\n  var deadline = null;\n\n  var isBatchingUpdates = false;\n  var isUnbatchingUpdates = false;\n\n  // Use these to prevent an infinite loop of nested updates\n  var NESTED_UPDATE_LIMIT = 1000;\n  var nestedUpdateCount = 0;\n\n  var timeHeuristicForUnitOfWork = 1;\n\n  // requestWork is called by the scheduler whenever a root receives an update.\n  // It's up to the renderer to call renderRoot at some point in the future.\n  function requestWork(root, expirationTime) {\n    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n      invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');\n    }\n\n    // Add the root to the schedule.\n    // Check if this root is already part of the schedule.\n    if (root.nextScheduledRoot === null) {\n      // This root is not already scheduled. Add it.\n      root.remainingExpirationTime = expirationTime;\n      if (lastScheduledRoot === null) {\n        firstScheduledRoot = lastScheduledRoot = root;\n        root.nextScheduledRoot = root;\n      } else {\n        lastScheduledRoot.nextScheduledRoot = root;\n        lastScheduledRoot = root;\n        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n      }\n    } else {\n      // This root is already scheduled, but its priority may have increased.\n      var remainingExpirationTime = root.remainingExpirationTime;\n      if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {\n        // Update the priority.\n        root.remainingExpirationTime = expirationTime;\n      }\n    }\n\n    if (isRendering) {\n      // Prevent reentrancy. Remaining work will be scheduled at the end of\n      // the currently rendering batch.\n      return;\n    }\n\n    if (isBatchingUpdates) {\n      // Flush work at the end of the batch.\n      if (isUnbatchingUpdates) {\n        // ...unless we're inside unbatchedUpdates, in which case we should\n        // flush it now.\n        performWorkOnRoot(root, Sync);\n      }\n      return;\n    }\n\n    // TODO: Get rid of Sync and use current time?\n    if (expirationTime === Sync) {\n      performWork(Sync, null);\n    } else if (!isCallbackScheduled) {\n      isCallbackScheduled = true;\n      startRequestCallbackTimer();\n      scheduleDeferredCallback(performAsyncWork);\n    }\n  }\n\n  function findHighestPriorityRoot() {\n    var highestPriorityWork = NoWork;\n    var highestPriorityRoot = null;\n\n    if (lastScheduledRoot !== null) {\n      var previousScheduledRoot = lastScheduledRoot;\n      var root = firstScheduledRoot;\n      while (root !== null) {\n        var remainingExpirationTime = root.remainingExpirationTime;\n        if (remainingExpirationTime === NoWork) {\n          // This root no longer has work. Remove it from the scheduler.\n\n          // TODO: This check is redudant, but Flow is confused by the branch\n          // below where we set lastScheduledRoot to null, even though we break\n          // from the loop right after.\n          !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          if (root === root.nextScheduledRoot) {\n            // This is the only root in the list.\n            root.nextScheduledRoot = null;\n            firstScheduledRoot = lastScheduledRoot = null;\n            break;\n          } else if (root === firstScheduledRoot) {\n            // This is the first root in the list.\n            var next = root.nextScheduledRoot;\n            firstScheduledRoot = next;\n            lastScheduledRoot.nextScheduledRoot = next;\n            root.nextScheduledRoot = null;\n          } else if (root === lastScheduledRoot) {\n            // This is the last root in the list.\n            lastScheduledRoot = previousScheduledRoot;\n            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n            root.nextScheduledRoot = null;\n            break;\n          } else {\n            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n            root.nextScheduledRoot = null;\n          }\n          root = previousScheduledRoot.nextScheduledRoot;\n        } else {\n          if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {\n            // Update the priority, if it's higher\n            highestPriorityWork = remainingExpirationTime;\n            highestPriorityRoot = root;\n          }\n          if (root === lastScheduledRoot) {\n            break;\n          }\n          previousScheduledRoot = root;\n          root = root.nextScheduledRoot;\n        }\n      }\n    }\n\n    // If the next root is the same as the previous root, this is a nested\n    // update. To prevent an infinite loop, increment the nested update count.\n    var previousFlushedRoot = nextFlushedRoot;\n    if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {\n      nestedUpdateCount++;\n    } else {\n      // Reset whenever we switch roots.\n      nestedUpdateCount = 0;\n    }\n    nextFlushedRoot = highestPriorityRoot;\n    nextFlushedExpirationTime = highestPriorityWork;\n  }\n\n  function performAsyncWork(dl) {\n    performWork(NoWork, dl);\n  }\n\n  function performWork(minExpirationTime, dl) {\n    deadline = dl;\n\n    // Keep working on roots until there's no more work, or until the we reach\n    // the deadline.\n    findHighestPriorityRoot();\n\n    if (enableUserTimingAPI && deadline !== null) {\n      var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();\n      stopRequestCallbackTimer(didExpire);\n    }\n\n    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);\n      // Find the next highest priority work.\n      findHighestPriorityRoot();\n    }\n\n    // We're done flushing work. Either we ran out of time in this callback,\n    // or there's no more work left with sufficient priority.\n\n    // If we're inside a callback, set this to false since we just completed it.\n    if (deadline !== null) {\n      isCallbackScheduled = false;\n    }\n    // If there's work left over, schedule a new callback.\n    if (nextFlushedRoot !== null && !isCallbackScheduled) {\n      isCallbackScheduled = true;\n      startRequestCallbackTimer();\n      scheduleDeferredCallback(performAsyncWork);\n    }\n\n    // Clean-up.\n    deadline = null;\n    deadlineDidExpire = false;\n    nestedUpdateCount = 0;\n\n    if (hasUnhandledError) {\n      var _error4 = unhandledError;\n      unhandledError = null;\n      hasUnhandledError = false;\n      throw _error4;\n    }\n  }\n\n  function performWorkOnRoot(root, expirationTime) {\n    !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    isRendering = true;\n\n    // Check if this is async work or sync/expired work.\n    // TODO: Pass current time as argument to renderRoot, commitRoot\n    if (expirationTime <= recalculateCurrentTime()) {\n      // Flush sync work.\n      var finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        root.finishedWork = null;\n        root.remainingExpirationTime = commitRoot(finishedWork);\n      } else {\n        root.finishedWork = null;\n        finishedWork = renderRoot(root, expirationTime);\n        if (finishedWork !== null) {\n          // We've completed the root. Commit it.\n          root.remainingExpirationTime = commitRoot(finishedWork);\n        }\n      }\n    } else {\n      // Flush async work.\n      var _finishedWork = root.finishedWork;\n      if (_finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        root.finishedWork = null;\n        root.remainingExpirationTime = commitRoot(_finishedWork);\n      } else {\n        root.finishedWork = null;\n        _finishedWork = renderRoot(root, expirationTime);\n        if (_finishedWork !== null) {\n          // We've completed the root. Check the deadline one more time\n          // before committing.\n          if (!shouldYield()) {\n            // Still time left. Commit the root.\n            root.remainingExpirationTime = commitRoot(_finishedWork);\n          } else {\n            // There's no time left. Mark this root as complete. We'll come\n            // back and commit it later.\n            root.finishedWork = _finishedWork;\n          }\n        }\n      }\n    }\n\n    isRendering = false;\n  }\n\n  // When working on async work, the reconciler asks the renderer if it should\n  // yield execution. For DOM, we implement this with requestIdleCallback.\n  function shouldYield() {\n    if (deadline === null) {\n      return false;\n    }\n    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n      return false;\n    }\n    deadlineDidExpire = true;\n    return true;\n  }\n\n  // TODO: Not happy about this hook. Conceptually, renderRoot should return a\n  // tuple of (isReadyForCommit, didError, error)\n  function onUncaughtError(error) {\n    !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    // Unschedule this root so we don't work on it again until there's\n    // another update.\n    nextFlushedRoot.remainingExpirationTime = NoWork;\n    if (!hasUnhandledError) {\n      hasUnhandledError = true;\n      unhandledError = error;\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function batchedUpdates(fn, a) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performWork(Sync, null);\n      }\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function unbatchedUpdates(fn) {\n    if (isBatchingUpdates && !isUnbatchingUpdates) {\n      isUnbatchingUpdates = true;\n      try {\n        return fn();\n      } finally {\n        isUnbatchingUpdates = false;\n      }\n    }\n    return fn();\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not within\n  // the reconciler.\n  function flushSync(fn) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return syncUpdates(fn);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;\n      performWork(Sync, null);\n    }\n  }\n\n  return {\n    computeAsyncExpiration: computeAsyncExpiration,\n    computeExpirationForFiber: computeExpirationForFiber,\n    scheduleWork: scheduleWork,\n    batchedUpdates: batchedUpdates,\n    unbatchedUpdates: unbatchedUpdates,\n    flushSync: flushSync,\n    deferredUpdates: deferredUpdates\n  };\n};\n\n{\n  var didWarnAboutNestedUpdates = false;\n}\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\n\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyObject;\n  }\n\n  var fiber = get(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n  return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;\n}\n\nvar ReactFiberReconciler$1 = function (config) {\n  var getPublicInstance = config.getPublicInstance;\n\n  var _ReactFiberScheduler = ReactFiberScheduler(config),\n      computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,\n      computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,\n      scheduleWork = _ReactFiberScheduler.scheduleWork,\n      batchedUpdates = _ReactFiberScheduler.batchedUpdates,\n      unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,\n      flushSync = _ReactFiberScheduler.flushSync,\n      deferredUpdates = _ReactFiberScheduler.deferredUpdates;\n\n  function scheduleTopLevelUpdate(current, element, callback) {\n    {\n      if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {\n        didWarnAboutNestedUpdates = true;\n        warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');\n      }\n    }\n\n    callback = callback === undefined ? null : callback;\n    {\n      warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n    }\n\n    var expirationTime = void 0;\n    // Check if the top-level element is an async wrapper component. If so,\n    // treat updates to the root as async. This is a bit weird but lets us\n    // avoid a separate `renderAsync` API.\n    if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {\n      expirationTime = computeAsyncExpiration();\n    } else {\n      expirationTime = computeExpirationForFiber(current);\n    }\n\n    var update = {\n      expirationTime: expirationTime,\n      partialState: { element: element },\n      callback: callback,\n      isReplace: false,\n      isForced: false,\n      nextCallback: null,\n      next: null\n    };\n    insertUpdateIntoFiber(current, update);\n    scheduleWork(current, expirationTime);\n  }\n\n  function findHostInstance(fiber) {\n    var hostFiber = findCurrentHostFiber(fiber);\n    if (hostFiber === null) {\n      return null;\n    }\n    return hostFiber.stateNode;\n  }\n\n  return {\n    createContainer: function (containerInfo, hydrate) {\n      return createFiberRoot(containerInfo, hydrate);\n    },\n    updateContainer: function (element, container, parentComponent, callback) {\n      // TODO: If this is a nested container, this won't be the root.\n      var current = container.current;\n\n      {\n        if (ReactFiberInstrumentation_1.debugTool) {\n          if (current.alternate === null) {\n            ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n          } else if (element === null) {\n            ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n          } else {\n            ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n          }\n        }\n      }\n\n      var context = getContextForSubtree(parentComponent);\n      if (container.context === null) {\n        container.context = context;\n      } else {\n        container.pendingContext = context;\n      }\n\n      scheduleTopLevelUpdate(current, element, callback);\n    },\n\n\n    batchedUpdates: batchedUpdates,\n\n    unbatchedUpdates: unbatchedUpdates,\n\n    deferredUpdates: deferredUpdates,\n\n    flushSync: flushSync,\n\n    getPublicRootInstance: function (container) {\n      var containerFiber = container.current;\n      if (!containerFiber.child) {\n        return null;\n      }\n      switch (containerFiber.child.tag) {\n        case HostComponent:\n          return getPublicInstance(containerFiber.child.stateNode);\n        default:\n          return containerFiber.child.stateNode;\n      }\n    },\n\n\n    findHostInstance: findHostInstance,\n\n    findHostInstanceWithNoPortals: function (fiber) {\n      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    injectIntoDevTools: function (devToolsConfig) {\n      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n\n      return injectInternals(_assign({}, devToolsConfig, {\n        findHostInstanceByFiber: function (fiber) {\n          return findHostInstance(fiber);\n        },\n        findFiberByHostInstance: function (instance) {\n          if (!findFiberByHostInstance) {\n            // Might not be implemented by the renderer.\n            return null;\n          }\n          return findFiberByHostInstance(instance);\n        }\n      }));\n    }\n  };\n};\n\nvar ReactFiberReconciler$2 = Object.freeze({\n\tdefault: ReactFiberReconciler$1\n});\n\nvar ReactFiberReconciler$3 = ( ReactFiberReconciler$2 && ReactFiberReconciler$1 ) || ReactFiberReconciler$2;\n\n// TODO: bundle Flow types with the package.\n\n\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactReconciler = ReactFiberReconciler$3['default'] ? ReactFiberReconciler$3['default'] : ReactFiberReconciler$3;\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = '16.1.1';\n\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n{\n  if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== 'function') {\n    warning(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');\n  }\n}\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nvar now = void 0;\nif (hasNativePerformanceNow) {\n  now = function () {\n    return performance.now();\n  };\n} else {\n  now = function () {\n    return Date.now();\n  };\n}\n\n// TODO: There's no way to cancel, because Fiber doesn't atm.\nvar rIC = void 0;\n\nif (!ExecutionEnvironment.canUseDOM) {\n  rIC = function (frameCallback) {\n    setTimeout(function () {\n      frameCallback({\n        timeRemaining: function () {\n          return Infinity;\n        }\n      });\n    });\n    return 0;\n  };\n} else if (typeof requestIdleCallback !== 'function') {\n  // Polyfill requestIdleCallback.\n\n  var scheduledRICCallback = null;\n\n  var isIdleScheduled = false;\n  var isAnimationFrameScheduled = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  var frameDeadlineObject;\n  if (hasNativePerformanceNow) {\n    frameDeadlineObject = {\n      timeRemaining: function () {\n        // We assume that if we have a performance timer that the rAF callback\n        // gets a performance timer value. Not sure if this is always true.\n        return frameDeadline - performance.now();\n      }\n    };\n  } else {\n    frameDeadlineObject = {\n      timeRemaining: function () {\n        // Fallback to Date.now()\n        return frameDeadline - Date.now();\n      }\n    };\n  }\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n    isIdleScheduled = false;\n    var callback = scheduledRICCallback;\n    scheduledRICCallback = null;\n    if (callback !== null) {\n      callback(frameDeadlineObject);\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  rIC = function (callback) {\n    // This assumes that we only schedule one callback at a time because that's\n    // how Fiber uses it.\n    scheduledRICCallback = callback;\n    if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrame(animationTick);\n    }\n    return 0;\n  };\n} else {\n  rIC = requestIdleCallback;\n}\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\n// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.\n// TODO: Find a better place for this.\nvar VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');\nvar illegalAttributeNameCache = {};\nvar validatedAttributeNameCache = {};\nfunction isAttributeNameSafe(attributeName) {\n  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {\n    return true;\n  }\n  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {\n    return false;\n  }\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n    validatedAttributeNameCache[attributeName] = true;\n    return true;\n  }\n  illegalAttributeNameCache[attributeName] = true;\n  {\n    warning(false, 'Invalid attribute name: `%s`', attributeName);\n  }\n  return false;\n}\n\n// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.\n// TODO: Find a better place for this.\nfunction shouldIgnoreValue(propertyInfo, value) {\n  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;\n}\n\n/**\n * Operations for dealing with DOM properties.\n */\n\n\n\n\n\n/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */\nfunction getValueForProperty(node, name, expected) {\n  {\n    var propertyInfo = getPropertyInfo(name);\n    if (propertyInfo) {\n      var mutationMethod = propertyInfo.mutationMethod;\n      if (mutationMethod || propertyInfo.mustUseProperty) {\n        return node[propertyInfo.propertyName];\n      } else {\n        var attributeName = propertyInfo.attributeName;\n\n        var stringValue = null;\n\n        if (propertyInfo.hasOverloadedBooleanValue) {\n          if (node.hasAttribute(attributeName)) {\n            var value = node.getAttribute(attributeName);\n            if (value === '') {\n              return true;\n            }\n            if (shouldIgnoreValue(propertyInfo, expected)) {\n              return value;\n            }\n            if (value === '' + expected) {\n              return expected;\n            }\n            return value;\n          }\n        } else if (node.hasAttribute(attributeName)) {\n          if (shouldIgnoreValue(propertyInfo, expected)) {\n            // We had an attribute but shouldn't have had one, so read it\n            // for the error message.\n            return node.getAttribute(attributeName);\n          }\n          if (propertyInfo.hasBooleanValue) {\n            // If this was a boolean, it doesn't matter what the value is\n            // the fact that we have it is the same as the expected.\n            return expected;\n          }\n          // Even if this property uses a namespace we use getAttribute\n          // because we assume its namespaced name is the same as our config.\n          // To use getAttributeNS we need the local name which we don't have\n          // in our config atm.\n          stringValue = node.getAttribute(attributeName);\n        }\n\n        if (shouldIgnoreValue(propertyInfo, expected)) {\n          return stringValue === null ? expected : stringValue;\n        } else if (stringValue === '' + expected) {\n          return expected;\n        } else {\n          return stringValue;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */\nfunction getValueForAttribute(node, name, expected) {\n  {\n    if (!isAttributeNameSafe(name)) {\n      return;\n    }\n    if (!node.hasAttribute(name)) {\n      return expected === undefined ? undefined : null;\n    }\n    var value = node.getAttribute(name);\n    if (value === '' + expected) {\n      return expected;\n    }\n    return value;\n  }\n}\n\n/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */\nfunction setValueForProperty(node, name, value) {\n  var propertyInfo = getPropertyInfo(name);\n\n  if (propertyInfo && shouldSetAttribute(name, value)) {\n    var mutationMethod = propertyInfo.mutationMethod;\n    if (mutationMethod) {\n      mutationMethod(node, value);\n    } else if (shouldIgnoreValue(propertyInfo, value)) {\n      deleteValueForProperty(node, name);\n      return;\n    } else if (propertyInfo.mustUseProperty) {\n      // Contrary to `setAttribute`, object properties are properly\n      // `toString`ed by IE8/9.\n      node[propertyInfo.propertyName] = value;\n    } else {\n      var attributeName = propertyInfo.attributeName;\n      var namespace = propertyInfo.attributeNamespace;\n      // `setAttribute` with objects becomes only `[object]` in IE8/9,\n      // ('' + value) makes it output the correct toString()-value.\n      if (namespace) {\n        node.setAttributeNS(namespace, attributeName, '' + value);\n      } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {\n        node.setAttribute(attributeName, '');\n      } else {\n        node.setAttribute(attributeName, '' + value);\n      }\n    }\n  } else {\n    setValueForAttribute(node, name, shouldSetAttribute(name, value) ? value : null);\n    return;\n  }\n\n  {\n    \n  }\n}\n\nfunction setValueForAttribute(node, name, value) {\n  if (!isAttributeNameSafe(name)) {\n    return;\n  }\n  if (value == null) {\n    node.removeAttribute(name);\n  } else {\n    node.setAttribute(name, '' + value);\n  }\n\n  {\n    \n  }\n}\n\n/**\n * Deletes an attributes from a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n */\nfunction deleteValueForAttribute(node, name) {\n  node.removeAttribute(name);\n}\n\n/**\n * Deletes the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n */\nfunction deleteValueForProperty(node, name) {\n  var propertyInfo = getPropertyInfo(name);\n  if (propertyInfo) {\n    var mutationMethod = propertyInfo.mutationMethod;\n    if (mutationMethod) {\n      mutationMethod(node, undefined);\n    } else if (propertyInfo.mustUseProperty) {\n      var propName = propertyInfo.propertyName;\n      if (propertyInfo.hasBooleanValue) {\n        node[propName] = false;\n      } else {\n        node[propName] = '';\n      }\n    } else {\n      node.removeAttribute(propertyInfo.attributeName);\n    }\n  } else {\n    node.removeAttribute(name);\n  }\n}\n\nvar ReactControlledValuePropTypes = {\n  checkPropTypes: null\n};\n\n{\n  var hasReadOnlyValue = {\n    button: true,\n    checkbox: true,\n    image: true,\n    hidden: true,\n    radio: true,\n    reset: true,\n    submit: true\n  };\n\n  var propTypes = {\n    value: function (props, propName, componentName) {\n      if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {\n        return null;\n      }\n      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    },\n    checked: function (props, propName, componentName) {\n      if (!props[propName] || props.onChange || props.readOnly || props.disabled) {\n        return null;\n      }\n      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    }\n  };\n\n  /**\n   * Provide a linked `value` attribute for controlled forms. You should not use\n   * this outside of the ReactDOM controlled form components.\n   */\n  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {\n    checkPropTypes(propTypes, props, 'prop', tagName, getStack);\n  };\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$2 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum$3 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnValueDefaultValue = false;\nvar didWarnCheckedDefaultChecked = false;\nvar didWarnControlledToUncontrolled = false;\nvar didWarnUncontrolledToControlled = false;\n\nfunction isControlled(props) {\n  var usesChecked = props.type === 'checkbox' || props.type === 'radio';\n  return usesChecked ? props.checked != null : props.value != null;\n}\n\n/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */\n\nfunction getHostProps(element, props) {\n  var node = element;\n  var value = props.value;\n  var checked = props.checked;\n\n  var hostProps = _assign({\n    // Make sure we set .type before any other properties (setting .value\n    // before .type means .value is lost in IE11 and below)\n    type: undefined,\n    // Make sure we set .step before .value (setting .value before .step\n    // means .value is rounded on mount, based upon step precision)\n    step: undefined,\n    // Make sure we set .min & .max before .value (to ensure proper order\n    // in corner cases such as min or max deriving from value, e.g. Issue #7170)\n    min: undefined,\n    max: undefined\n  }, props, {\n    defaultChecked: undefined,\n    defaultValue: undefined,\n    value: value != null ? value : node._wrapperState.initialValue,\n    checked: checked != null ? checked : node._wrapperState.initialChecked\n  });\n\n  return hostProps;\n}\n\nfunction initWrapperState(element, props) {\n  {\n    ReactControlledValuePropTypes.checkPropTypes('input', props, getCurrentFiberStackAddendum$3);\n\n    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {\n      warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);\n      didWarnCheckedDefaultChecked = true;\n    }\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {\n      warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);\n      didWarnValueDefaultValue = true;\n    }\n  }\n\n  var defaultValue = props.defaultValue;\n  var node = element;\n  node._wrapperState = {\n    initialChecked: props.checked != null ? props.checked : props.defaultChecked,\n    initialValue: props.value != null ? props.value : defaultValue,\n    controlled: isControlled(props)\n  };\n}\n\nfunction updateWrapper(element, props) {\n  var node = element;\n  {\n    var controlled = isControlled(props);\n\n    if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {\n      warning(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());\n      didWarnUncontrolledToControlled = true;\n    }\n    if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {\n      warning(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());\n      didWarnControlledToUncontrolled = true;\n    }\n  }\n\n  var checked = props.checked;\n  if (checked != null) {\n    setValueForProperty(node, 'checked', checked || false);\n  }\n\n  var value = props.value;\n  if (value != null) {\n    if (value === 0 && node.value === '') {\n      node.value = '0';\n      // Note: IE9 reports a number inputs as 'text', so check props instead.\n    } else if (props.type === 'number') {\n      // Simulate `input.valueAsNumber`. IE9 does not support it\n      var valueAsNumber = parseFloat(node.value) || 0;\n\n      if (\n      // eslint-disable-next-line\n      value != valueAsNumber ||\n      // eslint-disable-next-line\n      value == valueAsNumber && node.value != value) {\n        // Cast `value` to a string to ensure the value is set correctly. While\n        // browsers typically do this as necessary, jsdom doesn't.\n        node.value = '' + value;\n      }\n    } else if (node.value !== '' + value) {\n      // Cast `value` to a string to ensure the value is set correctly. While\n      // browsers typically do this as necessary, jsdom doesn't.\n      node.value = '' + value;\n    }\n  } else {\n    if (props.value == null && props.defaultValue != null) {\n      // In Chrome, assigning defaultValue to certain input types triggers input validation.\n      // For number inputs, the display value loses trailing decimal points. For email inputs,\n      // Chrome raises \"The specified value <x> is not a valid email address\".\n      //\n      // Here we check to see if the defaultValue has actually changed, avoiding these problems\n      // when the user is inputting text\n      //\n      // https://github.com/facebook/react/issues/7253\n      if (node.defaultValue !== '' + props.defaultValue) {\n        node.defaultValue = '' + props.defaultValue;\n      }\n    }\n    if (props.checked == null && props.defaultChecked != null) {\n      node.defaultChecked = !!props.defaultChecked;\n    }\n  }\n}\n\nfunction postMountWrapper(element, props) {\n  var node = element;\n\n  // Detach value from defaultValue. We won't do anything if we're working on\n  // submit or reset inputs as those values & defaultValues are linked. They\n  // are not resetable nodes so this operation doesn't matter and actually\n  // removes browser-default values (eg \"Submit Query\") when no value is\n  // provided.\n\n  switch (props.type) {\n    case 'submit':\n    case 'reset':\n      break;\n    case 'color':\n    case 'date':\n    case 'datetime':\n    case 'datetime-local':\n    case 'month':\n    case 'time':\n    case 'week':\n      // This fixes the no-show issue on iOS Safari and Android Chrome:\n      // https://github.com/facebook/react/issues/7233\n      node.value = '';\n      node.value = node.defaultValue;\n      break;\n    default:\n      node.value = node.value;\n      break;\n  }\n\n  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n  // this is needed to work around a chrome bug where setting defaultChecked\n  // will sometimes influence the value of checked (even after detachment).\n  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n  // We need to temporarily unset name to avoid disrupting radio button groups.\n  var name = node.name;\n  if (name !== '') {\n    node.name = '';\n  }\n  node.defaultChecked = !node.defaultChecked;\n  node.defaultChecked = !node.defaultChecked;\n  if (name !== '') {\n    node.name = name;\n  }\n}\n\nfunction restoreControlledState$1(element, props) {\n  var node = element;\n  updateWrapper(node, props);\n  updateNamedCousins(node, props);\n}\n\nfunction updateNamedCousins(rootNode, props) {\n  var name = props.name;\n  if (props.type === 'radio' && name != null) {\n    var queryRoot = rootNode;\n\n    while (queryRoot.parentNode) {\n      queryRoot = queryRoot.parentNode;\n    }\n\n    // If `rootNode.form` was non-null, then we could try `form.elements`,\n    // but that sometimes behaves strangely in IE8. We could also try using\n    // `form.getElementsByName`, but that will only return direct children\n    // and won't include inputs that use the HTML5 `form=` attribute. Since\n    // the input might not even be in a form. It might not even be in the\n    // document. Let's just use the local `querySelectorAll` to ensure we don't\n    // miss anything.\n    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]');\n\n    for (var i = 0; i < group.length; i++) {\n      var otherNode = group[i];\n      if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n        continue;\n      }\n      // This will throw if radio buttons rendered by different copies of React\n      // and the same name are rendered into the same form (same as #1939).\n      // That's probably okay; we don't support it just as we don't support\n      // mixing React radio buttons with non-React ones.\n      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);\n      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;\n      // If this is a controlled radio button group, forcing the input that\n      // was previously checked to update will cause it to be come re-checked\n      // as appropriate.\n      updateWrapper(otherNode, otherProps);\n    }\n  }\n}\n\nfunction flattenChildren(children) {\n  var content = '';\n\n  // Flatten children and warn if they aren't strings or numbers;\n  // invalid types are ignored.\n  // We can silently skip them because invalid DOM nesting warning\n  // catches these cases in Fiber.\n  React.Children.forEach(children, function (child) {\n    if (child == null) {\n      return;\n    }\n    if (typeof child === 'string' || typeof child === 'number') {\n      content += child;\n    }\n  });\n\n  return content;\n}\n\n/**\n * Implements an <option> host component that warns when `selected` is set.\n */\n\nfunction validateProps(element, props) {\n  // TODO (yungsters): Remove support for `selected` in <option>.\n  {\n    warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');\n  }\n}\n\nfunction postMountWrapper$1(element, props) {\n  // value=\"\" should make a value attribute (#6219)\n  if (props.value != null) {\n    element.setAttribute('value', props.value);\n  }\n}\n\nfunction getHostProps$1(element, props) {\n  var hostProps = _assign({ children: undefined }, props);\n\n  var content = flattenChildren(props.children);\n\n  if (content) {\n    hostProps.children = content;\n  }\n\n  return hostProps;\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum$4 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\n\n{\n  var didWarnValueDefaultValue$1 = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  var ownerName = getCurrentFiberOwnerName$3();\n  if (ownerName) {\n    return '\\n\\nCheck the render method of `' + ownerName + '`.';\n  }\n  return '';\n}\n\nvar valuePropNames = ['value', 'defaultValue'];\n\n/**\n * Validation function for `value` and `defaultValue`.\n */\nfunction checkSelectPropTypes(props) {\n  ReactControlledValuePropTypes.checkPropTypes('select', props, getCurrentFiberStackAddendum$4);\n\n  for (var i = 0; i < valuePropNames.length; i++) {\n    var propName = valuePropNames[i];\n    if (props[propName] == null) {\n      continue;\n    }\n    var isArray = Array.isArray(props[propName]);\n    if (props.multiple && !isArray) {\n      warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());\n    } else if (!props.multiple && isArray) {\n      warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());\n    }\n  }\n}\n\nfunction updateOptions(node, multiple, propValue, setDefaultSelected) {\n  var options = node.options;\n\n  if (multiple) {\n    var selectedValues = propValue;\n    var selectedValue = {};\n    for (var i = 0; i < selectedValues.length; i++) {\n      // Prefix to avoid chaos with special keys.\n      selectedValue['$' + selectedValues[i]] = true;\n    }\n    for (var _i = 0; _i < options.length; _i++) {\n      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);\n      if (options[_i].selected !== selected) {\n        options[_i].selected = selected;\n      }\n      if (selected && setDefaultSelected) {\n        options[_i].defaultSelected = true;\n      }\n    }\n  } else {\n    // Do not set `select.value` as exact behavior isn't consistent across all\n    // browsers for all cases.\n    var _selectedValue = '' + propValue;\n    var defaultSelected = null;\n    for (var _i2 = 0; _i2 < options.length; _i2++) {\n      if (options[_i2].value === _selectedValue) {\n        options[_i2].selected = true;\n        if (setDefaultSelected) {\n          options[_i2].defaultSelected = true;\n        }\n        return;\n      }\n      if (defaultSelected === null && !options[_i2].disabled) {\n        defaultSelected = options[_i2];\n      }\n    }\n    if (defaultSelected !== null) {\n      defaultSelected.selected = true;\n    }\n  }\n}\n\n/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */\n\nfunction getHostProps$2(element, props) {\n  return _assign({}, props, {\n    value: undefined\n  });\n}\n\nfunction initWrapperState$1(element, props) {\n  var node = element;\n  {\n    checkSelectPropTypes(props);\n  }\n\n  var value = props.value;\n  node._wrapperState = {\n    initialValue: value != null ? value : props.defaultValue,\n    wasMultiple: !!props.multiple\n  };\n\n  {\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {\n      warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n      didWarnValueDefaultValue$1 = true;\n    }\n  }\n}\n\nfunction postMountWrapper$2(element, props) {\n  var node = element;\n  node.multiple = !!props.multiple;\n  var value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (props.defaultValue != null) {\n    updateOptions(node, !!props.multiple, props.defaultValue, true);\n  }\n}\n\nfunction postUpdateWrapper(element, props) {\n  var node = element;\n  // After the initial mount, we control selected-ness manually so don't pass\n  // this value down\n  node._wrapperState.initialValue = undefined;\n\n  var wasMultiple = node._wrapperState.wasMultiple;\n  node._wrapperState.wasMultiple = !!props.multiple;\n\n  var value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (wasMultiple !== !!props.multiple) {\n    // For simplicity, reapply `defaultValue` if `multiple` is toggled.\n    if (props.defaultValue != null) {\n      updateOptions(node, !!props.multiple, props.defaultValue, true);\n    } else {\n      // Revert the select back to its default unselected state.\n      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);\n    }\n  }\n}\n\nfunction restoreControlledState$2(element, props) {\n  var node = element;\n  var value = props.value;\n\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  }\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberStackAddendum$5 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnValDefaultVal = false;\n\n/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */\n\nfunction getHostProps$3(element, props) {\n  var node = element;\n  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;\n\n  // Always set children to the same thing. In IE9, the selection range will\n  // get reset if `textContent` is mutated.  We could add a check in setTextContent\n  // to only set the value if/when the value differs from the node value (which would\n  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n  // solution. The value can be a boolean or object so that's why it's forced\n  // to be a string.\n  var hostProps = _assign({}, props, {\n    value: undefined,\n    defaultValue: undefined,\n    children: '' + node._wrapperState.initialValue\n  });\n\n  return hostProps;\n}\n\nfunction initWrapperState$2(element, props) {\n  var node = element;\n  {\n    ReactControlledValuePropTypes.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$5);\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {\n      warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n      didWarnValDefaultVal = true;\n    }\n  }\n\n  var value = props.value;\n  var initialValue = value;\n\n  // Only bother fetching default value if we're going to use it\n  if (value == null) {\n    var defaultValue = props.defaultValue;\n    // TODO (yungsters): Remove support for children content in <textarea>.\n    var children = props.children;\n    if (children != null) {\n      {\n        warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');\n      }\n      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;\n      if (Array.isArray(children)) {\n        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;\n        children = children[0];\n      }\n\n      defaultValue = '' + children;\n    }\n    if (defaultValue == null) {\n      defaultValue = '';\n    }\n    initialValue = defaultValue;\n  }\n\n  node._wrapperState = {\n    initialValue: '' + initialValue\n  };\n}\n\nfunction updateWrapper$1(element, props) {\n  var node = element;\n  var value = props.value;\n  if (value != null) {\n    // Cast `value` to a string to ensure the value is set correctly. While\n    // browsers typically do this as necessary, jsdom doesn't.\n    var newValue = '' + value;\n\n    // To avoid side effects (such as losing text selection), only set value if changed\n    if (newValue !== node.value) {\n      node.value = newValue;\n    }\n    if (props.defaultValue == null) {\n      node.defaultValue = newValue;\n    }\n  }\n  if (props.defaultValue != null) {\n    node.defaultValue = props.defaultValue;\n  }\n}\n\nfunction postMountWrapper$3(element, props) {\n  var node = element;\n  // This is in postMount because we need access to the DOM node, which is not\n  // available until after the component has mounted.\n  var textContent = node.textContent;\n\n  // Only set node.value if textContent is equal to the expected\n  // initial value. In IE10/IE11 there is a bug where the placeholder attribute\n  // will populate textContent as well.\n  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\n  if (textContent === node._wrapperState.initialValue) {\n    node.value = textContent;\n  }\n}\n\nfunction restoreControlledState$3(element, props) {\n  // DOM component is still mounted; update\n  updateWrapper$1(element, props);\n}\n\nvar HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';\nvar MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\nvar SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nvar Namespaces = {\n  html: HTML_NAMESPACE$1,\n  mathml: MATH_NAMESPACE,\n  svg: SVG_NAMESPACE\n};\n\n// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type) {\n  switch (type) {\n    case 'svg':\n      return SVG_NAMESPACE;\n    case 'math':\n      return MATH_NAMESPACE;\n    default:\n      return HTML_NAMESPACE$1;\n  }\n}\n\nfunction getChildNamespace(parentNamespace, type) {\n  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {\n    // No (or default) parent namespace: potential entry point.\n    return getIntrinsicNamespace(type);\n  }\n  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {\n    // We're leaving SVG.\n    return HTML_NAMESPACE$1;\n  }\n  // By default, pass namespace below.\n  return parentNamespace;\n}\n\n/* globals MSApp */\n\n/**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */\nvar createMicrosoftUnsafeLocalFunction = function (func) {\n  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {\n    return function (arg0, arg1, arg2, arg3) {\n      MSApp.execUnsafeLocalFunction(function () {\n        return func(arg0, arg1, arg2, arg3);\n      });\n    };\n  } else {\n    return func;\n  }\n};\n\n// SVG temp container for IE lacking innerHTML\nvar reusableSVGContainer = void 0;\n\n/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\nvar setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {\n  // IE does not have innerHTML for SVG nodes, so instead we inject the\n  // new markup in a temp node and then move the child nodes across into\n  // the target node\n\n  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {\n    reusableSVGContainer = reusableSVGContainer || document.createElement('div');\n    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';\n    var svgNode = reusableSVGContainer.firstChild;\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n    while (svgNode.firstChild) {\n      node.appendChild(svgNode.firstChild);\n    }\n  } else {\n    node.innerHTML = html;\n  }\n});\n\n// code copied and modified from escape-html\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        // \"\n        escape = '&quot;';\n        break;\n      case 38:\n        // &\n        escape = '&amp;';\n        break;\n      case 39:\n        // '\n        escape = '&#x27;'; // modified from escape-html; used to be '&#39'\n        break;\n      case 60:\n        // <\n        escape = '&lt;';\n        break;\n      case 62:\n        // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\n}\n// end code copied and modified from escape-html\n\n/**\n * Escapes text to prevent scripting attacks.\n *\n * @param {*} text Text value to escape.\n * @return {string} An escaped string.\n */\nfunction escapeTextContentForBrowser(text) {\n  if (typeof text === 'boolean' || typeof text === 'number') {\n    // this shortcircuit helps perf for types that we know will never have\n    // special characters, especially given that this function is used often\n    // for numeric dom ids.\n    return '' + text;\n  }\n  return escapeHtml(text);\n}\n\n/**\n * Set the textContent property of a node, ensuring that whitespace is preserved\n * even in IE8. innerText is a poor substitute for textContent and, among many\n * issues, inserts <br> instead of the literal newline chars. innerHTML behaves\n * as it should.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */\nvar setTextContent = function (node, text) {\n  if (text) {\n    var firstChild = node.firstChild;\n\n    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {\n      firstChild.nodeValue = text;\n      return;\n    }\n  }\n  node.textContent = text;\n};\n\nif (ExecutionEnvironment.canUseDOM) {\n  if (!('textContent' in document.documentElement)) {\n    setTextContent = function (node, text) {\n      if (node.nodeType === TEXT_NODE) {\n        node.nodeValue = text;\n        return;\n      }\n      setInnerHTML(node, escapeTextContentForBrowser(text));\n    };\n  }\n}\n\nvar setTextContent$1 = setTextContent;\n\n/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */\nvar isUnitlessNumber = {\n  animationIterationCount: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowSpan: true,\n  gridRowStart: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnSpan: true,\n  gridColumnStart: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n\n  // SVG-related properties\n  fillOpacity: true,\n  floodOpacity: true,\n  stopOpacity: true,\n  strokeDasharray: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n\n/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */\nfunction prefixKey(prefix, key) {\n  return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n}\n\n/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */\nvar prefixes = ['Webkit', 'ms', 'Moz', 'O'];\n\n// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function (prop) {\n  prefixes.forEach(function (prefix) {\n    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n  });\n});\n\n/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */\nfunction dangerousStyleValue(name, value, isCustomProperty) {\n  // Note that we've removed escapeTextForBrowser() calls here since the\n  // whole string will be escaped when the attribute is injected into\n  // the markup. If you provide unsafe user data here they can inject\n  // arbitrary CSS which may be problematic (I couldn't repro this):\n  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n  // This is not an XSS hole but instead a potential CSS injection issue\n  // which has lead to a greater discussion about how we're going to\n  // trust URLs moving forward. See #2115901\n\n  var isEmpty = value == null || typeof value === 'boolean' || value === '';\n  if (isEmpty) {\n    return '';\n  }\n\n  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {\n    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n  }\n\n  return ('' + value).trim();\n}\n\nvar warnValidStyle = emptyFunction$1;\n\n{\n  // 'msTransform' is correct, but the other prefixes should be capitalized\n  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n\n  // style values shouldn't contain a semicolon\n  var badStyleValueWithSemicolonPattern = /;\\s*$/;\n\n  var warnedStyleNames = {};\n  var warnedStyleValues = {};\n  var warnedForNaNValue = false;\n  var warnedForInfinityValue = false;\n\n  var warnHyphenatedStyleName = function (name, getStack) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), getStack());\n  };\n\n  var warnBadVendoredStyleName = function (name, getStack) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), getStack());\n  };\n\n  var warnStyleValueWithSemicolon = function (name, value, getStack) {\n    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n      return;\n    }\n\n    warnedStyleValues[value] = true;\n    warning(false, \"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.%s', name, value.replace(badStyleValueWithSemicolonPattern, ''), getStack());\n  };\n\n  var warnStyleValueIsNaN = function (name, value, getStack) {\n    if (warnedForNaNValue) {\n      return;\n    }\n\n    warnedForNaNValue = true;\n    warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, getStack());\n  };\n\n  var warnStyleValueIsInfinity = function (name, value, getStack) {\n    if (warnedForInfinityValue) {\n      return;\n    }\n\n    warnedForInfinityValue = true;\n    warning(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, getStack());\n  };\n\n  warnValidStyle = function (name, value, getStack) {\n    if (name.indexOf('-') > -1) {\n      warnHyphenatedStyleName(name, getStack);\n    } else if (badVendoredStyleNamePattern.test(name)) {\n      warnBadVendoredStyleName(name, getStack);\n    } else if (badStyleValueWithSemicolonPattern.test(value)) {\n      warnStyleValueWithSemicolon(name, value, getStack);\n    }\n\n    if (typeof value === 'number') {\n      if (isNaN(value)) {\n        warnStyleValueIsNaN(name, value, getStack);\n      } else if (!isFinite(value)) {\n        warnStyleValueIsInfinity(name, value, getStack);\n      }\n    }\n  };\n}\n\nvar warnValidStyle$1 = warnValidStyle;\n\n/**\n * Operations for dealing with CSS properties.\n */\n\n/**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */\nfunction createDangerousStringForStyles(styles) {\n  {\n    var serialized = '';\n    var delimiter = '';\n    for (var styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      var styleValue = styles[styleName];\n      if (styleValue != null) {\n        var isCustomProperty = styleName.indexOf('--') === 0;\n        serialized += delimiter + hyphenateStyleName(styleName) + ':';\n        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);\n\n        delimiter = ';';\n      }\n    }\n    return serialized || null;\n  }\n}\n\n/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */\nfunction setValueForStyles(node, styles, getStack) {\n  var style = node.style;\n  for (var styleName in styles) {\n    if (!styles.hasOwnProperty(styleName)) {\n      continue;\n    }\n    var isCustomProperty = styleName.indexOf('--') === 0;\n    {\n      if (!isCustomProperty) {\n        warnValidStyle$1(styleName, styles[styleName], getStack);\n      }\n    }\n    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\n    if (styleName === 'float') {\n      styleName = 'cssFloat';\n    }\n    if (isCustomProperty) {\n      style.setProperty(styleName, styleValue);\n    } else {\n      style[styleName] = styleValue;\n    }\n  }\n}\n\n// For HTML, certain tags should omit their close tag. We keep a whitelist for\n// those special-case tags.\n\nvar omittedCloseTags = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  embed: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\n\n// For HTML, certain tags cannot have children. This has the same purpose as\n// `omittedCloseTags` except that `menuitem` should still have its closing tag.\n\nvar voidElementTags = _assign({\n  menuitem: true\n}, omittedCloseTags);\n\nvar HTML$1 = '__html';\n\nfunction assertValidProps(tag, props, getStack) {\n  if (!props) {\n    return;\n  }\n  // Note the use of `==` which checks for null or undefined.\n  if (voidElementTags[tag]) {\n    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getStack()) : void 0;\n  }\n  if (props.dangerouslySetInnerHTML != null) {\n    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;\n    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;\n  }\n  {\n    warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.%s', getStack());\n  }\n  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \\'em\\'}} when using JSX.%s', getStack()) : void 0;\n}\n\nfunction isCustomComponent(tagName, props) {\n  if (tagName.indexOf('-') === -1) {\n    return typeof props.is === 'string';\n  }\n  switch (tagName) {\n    // These are reserved SVG and MathML elements.\n    // We don't mind this whitelist too much because we expect it to never grow.\n    // The alternative is to track the namespace in a few places which is convoluted.\n    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n    case 'annotation-xml':\n    case 'color-profile':\n    case 'font-face':\n    case 'font-face-src':\n    case 'font-face-uri':\n    case 'font-face-format':\n    case 'font-face-name':\n    case 'missing-glyph':\n      return false;\n    default:\n      return true;\n  }\n}\n\nvar ariaProperties = {\n  'aria-current': 0, // state\n  'aria-details': 0,\n  'aria-disabled': 0, // state\n  'aria-hidden': 0, // state\n  'aria-invalid': 0, // state\n  'aria-keyshortcuts': 0,\n  'aria-label': 0,\n  'aria-roledescription': 0,\n  // Widget Attributes\n  'aria-autocomplete': 0,\n  'aria-checked': 0,\n  'aria-expanded': 0,\n  'aria-haspopup': 0,\n  'aria-level': 0,\n  'aria-modal': 0,\n  'aria-multiline': 0,\n  'aria-multiselectable': 0,\n  'aria-orientation': 0,\n  'aria-placeholder': 0,\n  'aria-pressed': 0,\n  'aria-readonly': 0,\n  'aria-required': 0,\n  'aria-selected': 0,\n  'aria-sort': 0,\n  'aria-valuemax': 0,\n  'aria-valuemin': 0,\n  'aria-valuenow': 0,\n  'aria-valuetext': 0,\n  // Live Region Attributes\n  'aria-atomic': 0,\n  'aria-busy': 0,\n  'aria-live': 0,\n  'aria-relevant': 0,\n  // Drag-and-Drop Attributes\n  'aria-dropeffect': 0,\n  'aria-grabbed': 0,\n  // Relationship Attributes\n  'aria-activedescendant': 0,\n  'aria-colcount': 0,\n  'aria-colindex': 0,\n  'aria-colspan': 0,\n  'aria-controls': 0,\n  'aria-describedby': 0,\n  'aria-errormessage': 0,\n  'aria-flowto': 0,\n  'aria-labelledby': 0,\n  'aria-owns': 0,\n  'aria-posinset': 0,\n  'aria-rowcount': 0,\n  'aria-rowindex': 0,\n  'aria-rowspan': 0,\n  'aria-setsize': 0\n};\n\nvar warnedProperties = {};\nvar rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\nvar rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getStackAddendum() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\nfunction validateProperty(tagName, name) {\n  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n    return true;\n  }\n\n  if (rARIACamel.test(name)) {\n    var ariaName = 'aria-' + name.slice(4).toLowerCase();\n    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (correctName == null) {\n      warning(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== correctName) {\n      warning(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  if (rARIA.test(name)) {\n    var lowerCasedName = name.toLowerCase();\n    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (standardName == null) {\n      warnedProperties[name] = true;\n      return false;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== standardName) {\n      warning(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  return true;\n}\n\nfunction warnInvalidARIAProps(type, props) {\n  var invalidProps = [];\n\n  for (var key in props) {\n    var isValid = validateProperty(type, key);\n    if (!isValid) {\n      invalidProps.push(key);\n    }\n  }\n\n  var unknownPropString = invalidProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n\n  if (invalidProps.length === 1) {\n    warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());\n  } else if (invalidProps.length > 1) {\n    warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());\n  }\n}\n\nfunction validateProperties(type, props) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnInvalidARIAProps(type, props);\n}\n\nvar didWarnValueNull = false;\n\nfunction getStackAddendum$1() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\nfunction validateProperties$1(type, props) {\n  if (type !== 'input' && type !== 'textarea' && type !== 'select') {\n    return;\n  }\n\n  if (props != null && props.value === null && !didWarnValueNull) {\n    didWarnValueNull = true;\n    if (type === 'select' && props.multiple) {\n      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.%s', type, getStackAddendum$1());\n    } else {\n      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1());\n    }\n  }\n}\n\n// When adding attributes to the HTML or SVG whitelist, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames = {\n  // HTML\n  accept: 'accept',\n  acceptcharset: 'acceptCharset',\n  'accept-charset': 'acceptCharset',\n  accesskey: 'accessKey',\n  action: 'action',\n  allowfullscreen: 'allowFullScreen',\n  alt: 'alt',\n  as: 'as',\n  async: 'async',\n  autocapitalize: 'autoCapitalize',\n  autocomplete: 'autoComplete',\n  autocorrect: 'autoCorrect',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  autosave: 'autoSave',\n  capture: 'capture',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  challenge: 'challenge',\n  charset: 'charSet',\n  checked: 'checked',\n  children: 'children',\n  cite: 'cite',\n  'class': 'className',\n  classid: 'classID',\n  classname: 'className',\n  cols: 'cols',\n  colspan: 'colSpan',\n  content: 'content',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  controls: 'controls',\n  controlslist: 'controlsList',\n  coords: 'coords',\n  crossorigin: 'crossOrigin',\n  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',\n  data: 'data',\n  datetime: 'dateTime',\n  'default': 'default',\n  defaultchecked: 'defaultChecked',\n  defaultvalue: 'defaultValue',\n  defer: 'defer',\n  dir: 'dir',\n  disabled: 'disabled',\n  download: 'download',\n  draggable: 'draggable',\n  enctype: 'encType',\n  'for': 'htmlFor',\n  form: 'form',\n  formmethod: 'formMethod',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  headers: 'headers',\n  height: 'height',\n  hidden: 'hidden',\n  high: 'high',\n  href: 'href',\n  hreflang: 'hrefLang',\n  htmlfor: 'htmlFor',\n  httpequiv: 'httpEquiv',\n  'http-equiv': 'httpEquiv',\n  icon: 'icon',\n  id: 'id',\n  innerhtml: 'innerHTML',\n  inputmode: 'inputMode',\n  integrity: 'integrity',\n  is: 'is',\n  itemid: 'itemID',\n  itemprop: 'itemProp',\n  itemref: 'itemRef',\n  itemscope: 'itemScope',\n  itemtype: 'itemType',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  kind: 'kind',\n  label: 'label',\n  lang: 'lang',\n  list: 'list',\n  loop: 'loop',\n  low: 'low',\n  manifest: 'manifest',\n  marginwidth: 'marginWidth',\n  marginheight: 'marginHeight',\n  max: 'max',\n  maxlength: 'maxLength',\n  media: 'media',\n  mediagroup: 'mediaGroup',\n  method: 'method',\n  min: 'min',\n  minlength: 'minLength',\n  multiple: 'multiple',\n  muted: 'muted',\n  name: 'name',\n  nonce: 'nonce',\n  novalidate: 'noValidate',\n  open: 'open',\n  optimum: 'optimum',\n  pattern: 'pattern',\n  placeholder: 'placeholder',\n  playsinline: 'playsInline',\n  poster: 'poster',\n  preload: 'preload',\n  profile: 'profile',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  referrerpolicy: 'referrerPolicy',\n  rel: 'rel',\n  required: 'required',\n  reversed: 'reversed',\n  role: 'role',\n  rows: 'rows',\n  rowspan: 'rowSpan',\n  sandbox: 'sandbox',\n  scope: 'scope',\n  scoped: 'scoped',\n  scrolling: 'scrolling',\n  seamless: 'seamless',\n  selected: 'selected',\n  shape: 'shape',\n  size: 'size',\n  sizes: 'sizes',\n  span: 'span',\n  spellcheck: 'spellCheck',\n  src: 'src',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  start: 'start',\n  step: 'step',\n  style: 'style',\n  summary: 'summary',\n  tabindex: 'tabIndex',\n  target: 'target',\n  title: 'title',\n  type: 'type',\n  usemap: 'useMap',\n  value: 'value',\n  width: 'width',\n  wmode: 'wmode',\n  wrap: 'wrap',\n\n  // SVG\n  about: 'about',\n  accentheight: 'accentHeight',\n  'accent-height': 'accentHeight',\n  accumulate: 'accumulate',\n  additive: 'additive',\n  alignmentbaseline: 'alignmentBaseline',\n  'alignment-baseline': 'alignmentBaseline',\n  allowreorder: 'allowReorder',\n  alphabetic: 'alphabetic',\n  amplitude: 'amplitude',\n  arabicform: 'arabicForm',\n  'arabic-form': 'arabicForm',\n  ascent: 'ascent',\n  attributename: 'attributeName',\n  attributetype: 'attributeType',\n  autoreverse: 'autoReverse',\n  azimuth: 'azimuth',\n  basefrequency: 'baseFrequency',\n  baselineshift: 'baselineShift',\n  'baseline-shift': 'baselineShift',\n  baseprofile: 'baseProfile',\n  bbox: 'bbox',\n  begin: 'begin',\n  bias: 'bias',\n  by: 'by',\n  calcmode: 'calcMode',\n  capheight: 'capHeight',\n  'cap-height': 'capHeight',\n  clip: 'clip',\n  clippath: 'clipPath',\n  'clip-path': 'clipPath',\n  clippathunits: 'clipPathUnits',\n  cliprule: 'clipRule',\n  'clip-rule': 'clipRule',\n  color: 'color',\n  colorinterpolation: 'colorInterpolation',\n  'color-interpolation': 'colorInterpolation',\n  colorinterpolationfilters: 'colorInterpolationFilters',\n  'color-interpolation-filters': 'colorInterpolationFilters',\n  colorprofile: 'colorProfile',\n  'color-profile': 'colorProfile',\n  colorrendering: 'colorRendering',\n  'color-rendering': 'colorRendering',\n  contentscripttype: 'contentScriptType',\n  contentstyletype: 'contentStyleType',\n  cursor: 'cursor',\n  cx: 'cx',\n  cy: 'cy',\n  d: 'd',\n  datatype: 'datatype',\n  decelerate: 'decelerate',\n  descent: 'descent',\n  diffuseconstant: 'diffuseConstant',\n  direction: 'direction',\n  display: 'display',\n  divisor: 'divisor',\n  dominantbaseline: 'dominantBaseline',\n  'dominant-baseline': 'dominantBaseline',\n  dur: 'dur',\n  dx: 'dx',\n  dy: 'dy',\n  edgemode: 'edgeMode',\n  elevation: 'elevation',\n  enablebackground: 'enableBackground',\n  'enable-background': 'enableBackground',\n  end: 'end',\n  exponent: 'exponent',\n  externalresourcesrequired: 'externalResourcesRequired',\n  fill: 'fill',\n  fillopacity: 'fillOpacity',\n  'fill-opacity': 'fillOpacity',\n  fillrule: 'fillRule',\n  'fill-rule': 'fillRule',\n  filter: 'filter',\n  filterres: 'filterRes',\n  filterunits: 'filterUnits',\n  floodopacity: 'floodOpacity',\n  'flood-opacity': 'floodOpacity',\n  floodcolor: 'floodColor',\n  'flood-color': 'floodColor',\n  focusable: 'focusable',\n  fontfamily: 'fontFamily',\n  'font-family': 'fontFamily',\n  fontsize: 'fontSize',\n  'font-size': 'fontSize',\n  fontsizeadjust: 'fontSizeAdjust',\n  'font-size-adjust': 'fontSizeAdjust',\n  fontstretch: 'fontStretch',\n  'font-stretch': 'fontStretch',\n  fontstyle: 'fontStyle',\n  'font-style': 'fontStyle',\n  fontvariant: 'fontVariant',\n  'font-variant': 'fontVariant',\n  fontweight: 'fontWeight',\n  'font-weight': 'fontWeight',\n  format: 'format',\n  from: 'from',\n  fx: 'fx',\n  fy: 'fy',\n  g1: 'g1',\n  g2: 'g2',\n  glyphname: 'glyphName',\n  'glyph-name': 'glyphName',\n  glyphorientationhorizontal: 'glyphOrientationHorizontal',\n  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',\n  glyphorientationvertical: 'glyphOrientationVertical',\n  'glyph-orientation-vertical': 'glyphOrientationVertical',\n  glyphref: 'glyphRef',\n  gradienttransform: 'gradientTransform',\n  gradientunits: 'gradientUnits',\n  hanging: 'hanging',\n  horizadvx: 'horizAdvX',\n  'horiz-adv-x': 'horizAdvX',\n  horizoriginx: 'horizOriginX',\n  'horiz-origin-x': 'horizOriginX',\n  ideographic: 'ideographic',\n  imagerendering: 'imageRendering',\n  'image-rendering': 'imageRendering',\n  in2: 'in2',\n  'in': 'in',\n  inlist: 'inlist',\n  intercept: 'intercept',\n  k1: 'k1',\n  k2: 'k2',\n  k3: 'k3',\n  k4: 'k4',\n  k: 'k',\n  kernelmatrix: 'kernelMatrix',\n  kernelunitlength: 'kernelUnitLength',\n  kerning: 'kerning',\n  keypoints: 'keyPoints',\n  keysplines: 'keySplines',\n  keytimes: 'keyTimes',\n  lengthadjust: 'lengthAdjust',\n  letterspacing: 'letterSpacing',\n  'letter-spacing': 'letterSpacing',\n  lightingcolor: 'lightingColor',\n  'lighting-color': 'lightingColor',\n  limitingconeangle: 'limitingConeAngle',\n  local: 'local',\n  markerend: 'markerEnd',\n  'marker-end': 'markerEnd',\n  markerheight: 'markerHeight',\n  markermid: 'markerMid',\n  'marker-mid': 'markerMid',\n  markerstart: 'markerStart',\n  'marker-start': 'markerStart',\n  markerunits: 'markerUnits',\n  markerwidth: 'markerWidth',\n  mask: 'mask',\n  maskcontentunits: 'maskContentUnits',\n  maskunits: 'maskUnits',\n  mathematical: 'mathematical',\n  mode: 'mode',\n  numoctaves: 'numOctaves',\n  offset: 'offset',\n  opacity: 'opacity',\n  operator: 'operator',\n  order: 'order',\n  orient: 'orient',\n  orientation: 'orientation',\n  origin: 'origin',\n  overflow: 'overflow',\n  overlineposition: 'overlinePosition',\n  'overline-position': 'overlinePosition',\n  overlinethickness: 'overlineThickness',\n  'overline-thickness': 'overlineThickness',\n  paintorder: 'paintOrder',\n  'paint-order': 'paintOrder',\n  panose1: 'panose1',\n  'panose-1': 'panose1',\n  pathlength: 'pathLength',\n  patterncontentunits: 'patternContentUnits',\n  patterntransform: 'patternTransform',\n  patternunits: 'patternUnits',\n  pointerevents: 'pointerEvents',\n  'pointer-events': 'pointerEvents',\n  points: 'points',\n  pointsatx: 'pointsAtX',\n  pointsaty: 'pointsAtY',\n  pointsatz: 'pointsAtZ',\n  prefix: 'prefix',\n  preservealpha: 'preserveAlpha',\n  preserveaspectratio: 'preserveAspectRatio',\n  primitiveunits: 'primitiveUnits',\n  property: 'property',\n  r: 'r',\n  radius: 'radius',\n  refx: 'refX',\n  refy: 'refY',\n  renderingintent: 'renderingIntent',\n  'rendering-intent': 'renderingIntent',\n  repeatcount: 'repeatCount',\n  repeatdur: 'repeatDur',\n  requiredextensions: 'requiredExtensions',\n  requiredfeatures: 'requiredFeatures',\n  resource: 'resource',\n  restart: 'restart',\n  result: 'result',\n  results: 'results',\n  rotate: 'rotate',\n  rx: 'rx',\n  ry: 'ry',\n  scale: 'scale',\n  security: 'security',\n  seed: 'seed',\n  shaperendering: 'shapeRendering',\n  'shape-rendering': 'shapeRendering',\n  slope: 'slope',\n  spacing: 'spacing',\n  specularconstant: 'specularConstant',\n  specularexponent: 'specularExponent',\n  speed: 'speed',\n  spreadmethod: 'spreadMethod',\n  startoffset: 'startOffset',\n  stddeviation: 'stdDeviation',\n  stemh: 'stemh',\n  stemv: 'stemv',\n  stitchtiles: 'stitchTiles',\n  stopcolor: 'stopColor',\n  'stop-color': 'stopColor',\n  stopopacity: 'stopOpacity',\n  'stop-opacity': 'stopOpacity',\n  strikethroughposition: 'strikethroughPosition',\n  'strikethrough-position': 'strikethroughPosition',\n  strikethroughthickness: 'strikethroughThickness',\n  'strikethrough-thickness': 'strikethroughThickness',\n  string: 'string',\n  stroke: 'stroke',\n  strokedasharray: 'strokeDasharray',\n  'stroke-dasharray': 'strokeDasharray',\n  strokedashoffset: 'strokeDashoffset',\n  'stroke-dashoffset': 'strokeDashoffset',\n  strokelinecap: 'strokeLinecap',\n  'stroke-linecap': 'strokeLinecap',\n  strokelinejoin: 'strokeLinejoin',\n  'stroke-linejoin': 'strokeLinejoin',\n  strokemiterlimit: 'strokeMiterlimit',\n  'stroke-miterlimit': 'strokeMiterlimit',\n  strokewidth: 'strokeWidth',\n  'stroke-width': 'strokeWidth',\n  strokeopacity: 'strokeOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  suppresscontenteditablewarning: 'suppressContentEditableWarning',\n  suppresshydrationwarning: 'suppressHydrationWarning',\n  surfacescale: 'surfaceScale',\n  systemlanguage: 'systemLanguage',\n  tablevalues: 'tableValues',\n  targetx: 'targetX',\n  targety: 'targetY',\n  textanchor: 'textAnchor',\n  'text-anchor': 'textAnchor',\n  textdecoration: 'textDecoration',\n  'text-decoration': 'textDecoration',\n  textlength: 'textLength',\n  textrendering: 'textRendering',\n  'text-rendering': 'textRendering',\n  to: 'to',\n  transform: 'transform',\n  'typeof': 'typeof',\n  u1: 'u1',\n  u2: 'u2',\n  underlineposition: 'underlinePosition',\n  'underline-position': 'underlinePosition',\n  underlinethickness: 'underlineThickness',\n  'underline-thickness': 'underlineThickness',\n  unicode: 'unicode',\n  unicodebidi: 'unicodeBidi',\n  'unicode-bidi': 'unicodeBidi',\n  unicoderange: 'unicodeRange',\n  'unicode-range': 'unicodeRange',\n  unitsperem: 'unitsPerEm',\n  'units-per-em': 'unitsPerEm',\n  unselectable: 'unselectable',\n  valphabetic: 'vAlphabetic',\n  'v-alphabetic': 'vAlphabetic',\n  values: 'values',\n  vectoreffect: 'vectorEffect',\n  'vector-effect': 'vectorEffect',\n  version: 'version',\n  vertadvy: 'vertAdvY',\n  'vert-adv-y': 'vertAdvY',\n  vertoriginx: 'vertOriginX',\n  'vert-origin-x': 'vertOriginX',\n  vertoriginy: 'vertOriginY',\n  'vert-origin-y': 'vertOriginY',\n  vhanging: 'vHanging',\n  'v-hanging': 'vHanging',\n  videographic: 'vIdeographic',\n  'v-ideographic': 'vIdeographic',\n  viewbox: 'viewBox',\n  viewtarget: 'viewTarget',\n  visibility: 'visibility',\n  vmathematical: 'vMathematical',\n  'v-mathematical': 'vMathematical',\n  vocab: 'vocab',\n  widths: 'widths',\n  wordspacing: 'wordSpacing',\n  'word-spacing': 'wordSpacing',\n  writingmode: 'writingMode',\n  'writing-mode': 'writingMode',\n  x1: 'x1',\n  x2: 'x2',\n  x: 'x',\n  xchannelselector: 'xChannelSelector',\n  xheight: 'xHeight',\n  'x-height': 'xHeight',\n  xlinkactuate: 'xlinkActuate',\n  'xlink:actuate': 'xlinkActuate',\n  xlinkarcrole: 'xlinkArcrole',\n  'xlink:arcrole': 'xlinkArcrole',\n  xlinkhref: 'xlinkHref',\n  'xlink:href': 'xlinkHref',\n  xlinkrole: 'xlinkRole',\n  'xlink:role': 'xlinkRole',\n  xlinkshow: 'xlinkShow',\n  'xlink:show': 'xlinkShow',\n  xlinktitle: 'xlinkTitle',\n  'xlink:title': 'xlinkTitle',\n  xlinktype: 'xlinkType',\n  'xlink:type': 'xlinkType',\n  xmlbase: 'xmlBase',\n  'xml:base': 'xmlBase',\n  xmllang: 'xmlLang',\n  'xml:lang': 'xmlLang',\n  xmlns: 'xmlns',\n  'xml:space': 'xmlSpace',\n  xmlnsxlink: 'xmlnsXlink',\n  'xmlns:xlink': 'xmlnsXlink',\n  xmlspace: 'xmlSpace',\n  y1: 'y1',\n  y2: 'y2',\n  y: 'y',\n  ychannelselector: 'yChannelSelector',\n  z: 'z',\n  zoomandpan: 'zoomAndPan'\n};\n\nfunction getStackAddendum$2() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\n{\n  var warnedProperties$1 = {};\n  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n  var EVENT_NAME_REGEX = /^on[A-Z]/;\n  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\n  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\n  var validateProperty$1 = function (tagName, name, value) {\n    if (hasOwnProperty$1.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n      return true;\n    }\n\n    if (registrationNameModules.hasOwnProperty(name)) {\n      return true;\n    }\n\n    if (plugins.length === 0 && EVENT_NAME_REGEX.test(name)) {\n      // If no event plugins have been injected, we might be in a server environment.\n      // Don't check events in this case.\n      return true;\n    }\n\n    var lowerCasedName = name.toLowerCase();\n    var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n\n    if (registrationName != null) {\n      warning(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName.indexOf('on') === 0 && lowerCasedName.length > 2) {\n      warning(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Let the ARIA attribute hook validate ARIA attributes\n    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\n      return true;\n    }\n\n    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {\n      warning(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'innerhtml') {\n      warning(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'aria') {\n      warning(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {\n      warning(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'number' && isNaN(value)) {\n      warning(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    var isReserved = isReservedProp(name);\n\n    // Known attributes should match the casing specified in the property config.\n    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n      var standardName = possibleStandardNames[lowerCasedName];\n      if (standardName !== name) {\n        warning(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2());\n        warnedProperties$1[name] = true;\n        return true;\n      }\n    } else if (!isReserved && name !== lowerCasedName) {\n      // Unknown attributes should have lowercase casing since that's how they\n      // will be cased anyway with server rendering.\n      warning(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'boolean' && !shouldAttributeAcceptBooleanValue(name)) {\n      if (value) {\n        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.%s', value, name, name, value, name, getStackAddendum$2());\n      } else {\n        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', value, name, name, value, name, name, name, getStackAddendum$2());\n      }\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Now that we've validated casing, do not validate\n    // data types for reserved props\n    if (isReserved) {\n      return true;\n    }\n\n    // Warn when a known attribute is a bad type\n    if (!shouldSetAttribute(name, value)) {\n      warnedProperties$1[name] = true;\n      return false;\n    }\n\n    return true;\n  };\n}\n\nvar warnUnknownProperties = function (type, props) {\n  var unknownProps = [];\n  for (var key in props) {\n    var isValid = validateProperty$1(type, key, props[key]);\n    if (!isValid) {\n      unknownProps.push(key);\n    }\n  }\n\n  var unknownPropString = unknownProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n  if (unknownProps.length === 1) {\n    warning(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());\n  } else if (unknownProps.length > 1) {\n    warning(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());\n  }\n};\n\nfunction validateProperties$2(type, props) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnUnknownProperties(type, props);\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$1 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum$2 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnInvalidHydration = false;\nvar didWarnShadyDOM = false;\n\nvar DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';\nvar SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';\nvar SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';\nvar AUTOFOCUS = 'autoFocus';\nvar CHILDREN = 'children';\nvar STYLE = 'style';\nvar HTML = '__html';\n\nvar HTML_NAMESPACE = Namespaces.html;\n\n\nvar getStack = emptyFunction$1.thatReturns('');\n\n{\n  getStack = getCurrentFiberStackAddendum$2;\n\n  var warnedUnknownTags = {\n    // Chrome is the only major browser not shipping <time>. But as of July\n    // 2017 it intends to ship it due to widespread usage. We intentionally\n    // *don't* warn for <time> even if it's unrecognized by Chrome because\n    // it soon will be, and many apps have been using it anyway.\n    time: true,\n    // There are working polyfills for <dialog>. Let people use it.\n    dialog: true\n  };\n\n  var validatePropertiesInDevelopment = function (type, props) {\n    validateProperties(type, props);\n    validateProperties$1(type, props);\n    validateProperties$2(type, props);\n  };\n\n  // HTML parsing normalizes CR and CRLF to LF.\n  // It also can turn \\u0000 into \\uFFFD inside attributes.\n  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n  // If we have a mismatch, it might be caused by that.\n  // We will still patch up in this case but not fire the warning.\n  var NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g;\n  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\n\n  var normalizeMarkupForTextOrAttribute = function (markup) {\n    var markupString = typeof markup === 'string' ? markup : '' + markup;\n    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');\n  };\n\n  var warnForTextDifference = function (serverText, clientText) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);\n    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);\n    if (normalizedServerText === normalizedClientText) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Text content did not match. Server: \"%s\" Client: \"%s\"', normalizedServerText, normalizedClientText);\n  };\n\n  var warnForPropDifference = function (propName, serverValue, clientValue) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);\n    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);\n    if (normalizedServerValue === normalizedClientValue) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));\n  };\n\n  var warnForExtraAttributes = function (attributeNames) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    var names = [];\n    attributeNames.forEach(function (name) {\n      names.push(name);\n    });\n    warning(false, 'Extra attributes from the server: %s', names);\n  };\n\n  var warnForInvalidEventListener = function (registrationName, listener) {\n    if (listener === false) {\n      warning(false, 'Expected `%s` listener to be a function, instead got `false`.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', registrationName, registrationName, registrationName, getCurrentFiberStackAddendum$2());\n    } else {\n      warning(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum$2());\n    }\n  };\n\n  // Parse the HTML and read it back to normalize the HTML string so that it\n  // can be used for comparison.\n  var normalizeHTML = function (parent, html) {\n    // We could have created a separate document here to avoid\n    // re-initializing custom elements if they exist. But this breaks\n    // how <noscript> is being handled. So we use the same document.\n    // See the discussion in https://github.com/facebook/react/pull/11157.\n    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);\n    testElement.innerHTML = html;\n    return testElement.innerHTML;\n  };\n}\n\nfunction ensureListeningTo(rootContainerElement, registrationName) {\n  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;\n  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;\n  listenTo(registrationName, doc);\n}\n\nfunction getOwnerDocumentFromRootContainer(rootContainerElement) {\n  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n}\n\n// There are so many media events, it makes sense to just\n// maintain a list rather than create a `trapBubbledEvent` for each\nvar mediaEvents = {\n  topAbort: 'abort',\n  topCanPlay: 'canplay',\n  topCanPlayThrough: 'canplaythrough',\n  topDurationChange: 'durationchange',\n  topEmptied: 'emptied',\n  topEncrypted: 'encrypted',\n  topEnded: 'ended',\n  topError: 'error',\n  topLoadedData: 'loadeddata',\n  topLoadedMetadata: 'loadedmetadata',\n  topLoadStart: 'loadstart',\n  topPause: 'pause',\n  topPlay: 'play',\n  topPlaying: 'playing',\n  topProgress: 'progress',\n  topRateChange: 'ratechange',\n  topSeeked: 'seeked',\n  topSeeking: 'seeking',\n  topStalled: 'stalled',\n  topSuspend: 'suspend',\n  topTimeUpdate: 'timeupdate',\n  topVolumeChange: 'volumechange',\n  topWaiting: 'waiting'\n};\n\nfunction trapClickOnNonInteractiveElement(node) {\n  // Mobile Safari does not fire properly bubble click events on\n  // non-interactive elements, which means delegated click listeners do not\n  // fire. The workaround for this bug involves attaching an empty click\n  // listener on the target node.\n  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n  // Just set it using the onclick property so that we don't have to manage any\n  // bookkeeping for it. Not sure if we need to clear it when the listener is\n  // removed.\n  // TODO: Only do this for the relevant Safaris maybe?\n  node.onclick = emptyFunction$1;\n}\n\nfunction setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {\n  for (var propKey in nextProps) {\n    if (!nextProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = nextProps[propKey];\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      // Relies on `updateStylesByID` not mutating `styleUpdates`.\n      setValueForStyles(domElement, nextProp, getStack);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      if (nextHtml != null) {\n        setInnerHTML(domElement, nextHtml);\n      }\n    } else if (propKey === CHILDREN) {\n      if (typeof nextProp === 'string') {\n        // Avoid setting initial textContent when the text is empty. In IE11 setting\n        // textContent on a <textarea> will cause the placeholder to not\n        // show within the <textarea> until it has been focused and blurred again.\n        // https://github.com/facebook/react/issues/6731#issuecomment-254874553\n        var canSetTextContent = tag !== 'textarea' || nextProp !== '';\n        if (canSetTextContent) {\n          setTextContent$1(domElement, nextProp);\n        }\n      } else if (typeof nextProp === 'number') {\n        setTextContent$1(domElement, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (propKey === AUTOFOCUS) {\n      // We polyfill it separately on the client during commit.\n      // We blacklist it here rather than in the property list because we emit it in SSR.\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else if (isCustomComponentTag) {\n      setValueForAttribute(domElement, propKey, nextProp);\n    } else if (nextProp != null) {\n      // If we're updating to null or undefined, we should remove the property\n      // from the DOM node instead of inadvertently setting to a string. This\n      // brings us in line with the same behavior we have on initial render.\n      setValueForProperty(domElement, propKey, nextProp);\n    }\n  }\n}\n\nfunction updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {\n  // TODO: Handle wasCustomComponentTag\n  for (var i = 0; i < updatePayload.length; i += 2) {\n    var propKey = updatePayload[i];\n    var propValue = updatePayload[i + 1];\n    if (propKey === STYLE) {\n      setValueForStyles(domElement, propValue, getStack);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      setInnerHTML(domElement, propValue);\n    } else if (propKey === CHILDREN) {\n      setTextContent$1(domElement, propValue);\n    } else if (isCustomComponentTag) {\n      if (propValue != null) {\n        setValueForAttribute(domElement, propKey, propValue);\n      } else {\n        deleteValueForAttribute(domElement, propKey);\n      }\n    } else if (propValue != null) {\n      setValueForProperty(domElement, propKey, propValue);\n    } else {\n      // If we're updating to null or undefined, we should remove the property\n      // from the DOM node instead of inadvertently setting to a string. This\n      // brings us in line with the same behavior we have on initial render.\n      deleteValueForProperty(domElement, propKey);\n    }\n  }\n}\n\nfunction createElement$1(type, props, rootContainerElement, parentNamespace) {\n  // We create tags in the namespace of their parent container, except HTML\n  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);\n  var domElement;\n  var namespaceURI = parentNamespace;\n  if (namespaceURI === HTML_NAMESPACE) {\n    namespaceURI = getIntrinsicNamespace(type);\n  }\n  if (namespaceURI === HTML_NAMESPACE) {\n    {\n      var isCustomComponentTag = isCustomComponent(type, props);\n      // Should this check be gated by parent namespace? Not sure we want to\n      // allow <SVG> or <mATH>.\n      warning(isCustomComponentTag || type === type.toLowerCase(), '<%s /> is using uppercase HTML. Always use lowercase HTML tags ' + 'in React.', type);\n    }\n\n    if (type === 'script') {\n      // Create the script via .innerHTML so its \"parser-inserted\" flag is\n      // set to true and it does not execute\n      var div = ownerDocument.createElement('div');\n      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line\n      // This is guaranteed to yield a script element.\n      var firstChild = div.firstChild;\n      domElement = div.removeChild(firstChild);\n    } else if (typeof props.is === 'string') {\n      // $FlowIssue `createElement` should be updated for Web Components\n      domElement = ownerDocument.createElement(type, { is: props.is });\n    } else {\n      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n      // See discussion in https://github.com/facebook/react/pull/6896\n      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\n      domElement = ownerDocument.createElement(type);\n    }\n  } else {\n    domElement = ownerDocument.createElementNS(namespaceURI, type);\n  }\n\n  {\n    if (namespaceURI === HTML_NAMESPACE) {\n      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {\n        warnedUnknownTags[type] = true;\n        warning(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);\n      }\n    }\n  }\n\n  return domElement;\n}\n\nfunction createTextNode$1(text, rootContainerElement) {\n  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);\n}\n\nfunction setInitialProperties$1(domElement, tag, rawProps, rootContainerElement) {\n  var isCustomComponentTag = isCustomComponent(tag, rawProps);\n  {\n    validatePropertiesInDevelopment(tag, rawProps);\n    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');\n      didWarnShadyDOM = true;\n    }\n  }\n\n  // TODO: Make sure that we check isMounted before firing any of these events.\n  var props;\n  switch (tag) {\n    case 'iframe':\n    case 'object':\n      trapBubbledEvent('topLoad', 'load', domElement);\n      props = rawProps;\n      break;\n    case 'video':\n    case 'audio':\n      // Create listener for each media event\n      for (var event in mediaEvents) {\n        if (mediaEvents.hasOwnProperty(event)) {\n          trapBubbledEvent(event, mediaEvents[event], domElement);\n        }\n      }\n      props = rawProps;\n      break;\n    case 'source':\n      trapBubbledEvent('topError', 'error', domElement);\n      props = rawProps;\n      break;\n    case 'img':\n    case 'image':\n      trapBubbledEvent('topError', 'error', domElement);\n      trapBubbledEvent('topLoad', 'load', domElement);\n      props = rawProps;\n      break;\n    case 'form':\n      trapBubbledEvent('topReset', 'reset', domElement);\n      trapBubbledEvent('topSubmit', 'submit', domElement);\n      props = rawProps;\n      break;\n    case 'details':\n      trapBubbledEvent('topToggle', 'toggle', domElement);\n      props = rawProps;\n      break;\n    case 'input':\n      initWrapperState(domElement, rawProps);\n      props = getHostProps(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'option':\n      validateProps(domElement, rawProps);\n      props = getHostProps$1(domElement, rawProps);\n      break;\n    case 'select':\n      initWrapperState$1(domElement, rawProps);\n      props = getHostProps$2(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'textarea':\n      initWrapperState$2(domElement, rawProps);\n      props = getHostProps$3(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    default:\n      props = rawProps;\n  }\n\n  assertValidProps(tag, props, getStack);\n\n  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);\n\n  switch (tag) {\n    case 'input':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper(domElement, rawProps);\n      break;\n    case 'textarea':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper$3(domElement, rawProps);\n      break;\n    case 'option':\n      postMountWrapper$1(domElement, rawProps);\n      break;\n    case 'select':\n      postMountWrapper$2(domElement, rawProps);\n      break;\n    default:\n      if (typeof props.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n}\n\n// Calculate the diff between the two objects.\nfunction diffProperties$1(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {\n  {\n    validatePropertiesInDevelopment(tag, nextRawProps);\n  }\n\n  var updatePayload = null;\n\n  var lastProps;\n  var nextProps;\n  switch (tag) {\n    case 'input':\n      lastProps = getHostProps(domElement, lastRawProps);\n      nextProps = getHostProps(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'option':\n      lastProps = getHostProps$1(domElement, lastRawProps);\n      nextProps = getHostProps$1(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'select':\n      lastProps = getHostProps$2(domElement, lastRawProps);\n      nextProps = getHostProps$2(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'textarea':\n      lastProps = getHostProps$3(domElement, lastRawProps);\n      nextProps = getHostProps$3(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    default:\n      lastProps = lastRawProps;\n      nextProps = nextRawProps;\n      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n\n  assertValidProps(tag, nextProps, getStack);\n\n  var propKey;\n  var styleName;\n  var styleUpdates = null;\n  for (propKey in lastProps) {\n    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {\n      continue;\n    }\n    if (propKey === STYLE) {\n      var lastStyle = lastProps[propKey];\n      for (styleName in lastStyle) {\n        if (lastStyle.hasOwnProperty(styleName)) {\n          if (!styleUpdates) {\n            styleUpdates = {};\n          }\n          styleUpdates[styleName] = '';\n        }\n      }\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {\n      // Noop. This is handled by the clear text mechanism.\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (propKey === AUTOFOCUS) {\n      // Noop. It doesn't work on updates anyway.\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      // This is a special case. If any listener updates we need to ensure\n      // that the \"current\" fiber pointer gets updated so we need a commit\n      // to update this element.\n      if (!updatePayload) {\n        updatePayload = [];\n      }\n    } else {\n      // For all other deleted properties we add it to the queue. We use\n      // the whitelist in the commit phase instead.\n      (updatePayload = updatePayload || []).push(propKey, null);\n    }\n  }\n  for (propKey in nextProps) {\n    var nextProp = nextProps[propKey];\n    var lastProp = lastProps != null ? lastProps[propKey] : undefined;\n    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {\n      continue;\n    }\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      if (lastProp) {\n        // Unset styles on `lastProp` but not on `nextProp`.\n        for (styleName in lastProp) {\n          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = '';\n          }\n        }\n        // Update styles that changed since `lastProp`.\n        for (styleName in nextProp) {\n          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = nextProp[styleName];\n          }\n        }\n      } else {\n        // Relies on `updateStylesByID` not mutating `styleUpdates`.\n        if (!styleUpdates) {\n          if (!updatePayload) {\n            updatePayload = [];\n          }\n          updatePayload.push(propKey, styleUpdates);\n        }\n        styleUpdates = nextProp;\n      }\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      var lastHtml = lastProp ? lastProp[HTML] : undefined;\n      if (nextHtml != null) {\n        if (lastHtml !== nextHtml) {\n          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);\n        }\n      } else {\n        // TODO: It might be too late to clear this if we have children\n        // inserted already.\n      }\n    } else if (propKey === CHILDREN) {\n      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {\n        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        // We eagerly listen to this even though we haven't committed yet.\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n      if (!updatePayload && lastProp !== nextProp) {\n        // This is a special case. If any listener updates we need to ensure\n        // that the \"current\" props pointer gets updated so we need a commit\n        // to update this element.\n        updatePayload = [];\n      }\n    } else {\n      // For any other property we always add it to the queue and then we\n      // filter it out using the whitelist during the commit.\n      (updatePayload = updatePayload || []).push(propKey, nextProp);\n    }\n  }\n  if (styleUpdates) {\n    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);\n  }\n  return updatePayload;\n}\n\n// Apply the diff.\nfunction updateProperties$1(domElement, updatePayload, tag, lastRawProps, nextRawProps) {\n  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);\n  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);\n  // Apply the diff.\n  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);\n\n  // TODO: Ensure that an update gets scheduled if any of the special props\n  // changed.\n  switch (tag) {\n    case 'input':\n      // Update the wrapper around inputs *after* updating props. This has to\n      // happen after `updateDOMProperties`. Otherwise HTML5 input validations\n      // raise warnings and prevent the new value from being assigned.\n      updateWrapper(domElement, nextRawProps);\n\n      // We also check that we haven't missed a value update, such as a\n      // Radio group shifting the checked value to another named radio input.\n      updateValueIfChanged(domElement);\n      break;\n    case 'textarea':\n      updateWrapper$1(domElement, nextRawProps);\n      break;\n    case 'select':\n      // <select> value update needs to occur after <option> children\n      // reconciliation\n      postUpdateWrapper(domElement, nextRawProps);\n      break;\n  }\n}\n\nfunction diffHydratedProperties$1(domElement, tag, rawProps, parentNamespace, rootContainerElement) {\n  {\n    var suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;\n    var isCustomComponentTag = isCustomComponent(tag, rawProps);\n    validatePropertiesInDevelopment(tag, rawProps);\n    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');\n      didWarnShadyDOM = true;\n    }\n  }\n\n  // TODO: Make sure that we check isMounted before firing any of these events.\n  switch (tag) {\n    case 'iframe':\n    case 'object':\n      trapBubbledEvent('topLoad', 'load', domElement);\n      break;\n    case 'video':\n    case 'audio':\n      // Create listener for each media event\n      for (var event in mediaEvents) {\n        if (mediaEvents.hasOwnProperty(event)) {\n          trapBubbledEvent(event, mediaEvents[event], domElement);\n        }\n      }\n      break;\n    case 'source':\n      trapBubbledEvent('topError', 'error', domElement);\n      break;\n    case 'img':\n    case 'image':\n      trapBubbledEvent('topError', 'error', domElement);\n      trapBubbledEvent('topLoad', 'load', domElement);\n      break;\n    case 'form':\n      trapBubbledEvent('topReset', 'reset', domElement);\n      trapBubbledEvent('topSubmit', 'submit', domElement);\n      break;\n    case 'details':\n      trapBubbledEvent('topToggle', 'toggle', domElement);\n      break;\n    case 'input':\n      initWrapperState(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'option':\n      validateProps(domElement, rawProps);\n      break;\n    case 'select':\n      initWrapperState$1(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'textarea':\n      initWrapperState$2(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n  }\n\n  assertValidProps(tag, rawProps, getStack);\n\n  {\n    var extraAttributeNames = new Set();\n    var attributes = domElement.attributes;\n    for (var i = 0; i < attributes.length; i++) {\n      var name = attributes[i].name.toLowerCase();\n      switch (name) {\n        // Built-in SSR attribute is whitelisted\n        case 'data-reactroot':\n          break;\n        // Controlled attributes are not validated\n        // TODO: Only ignore them on controlled tags.\n        case 'value':\n          break;\n        case 'checked':\n          break;\n        case 'selected':\n          break;\n        default:\n          // Intentionally use the original name.\n          // See discussion in https://github.com/facebook/react/pull/10676.\n          extraAttributeNames.add(attributes[i].name);\n      }\n    }\n  }\n\n  var updatePayload = null;\n  for (var propKey in rawProps) {\n    if (!rawProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = rawProps[propKey];\n    if (propKey === CHILDREN) {\n      // For text content children we compare against textContent. This\n      // might match additional HTML that is hidden when we read it using\n      // textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n      // satisfies our requirement. Our requirement is not to produce perfect\n      // HTML and attributes. Ideally we should preserve structure but it's\n      // ok not to if the visible content is still enough to indicate what\n      // even listeners these nodes might be wired up to.\n      // TODO: Warn if there is more than a single textNode as a child.\n      // TODO: Should we use domElement.firstChild.nodeValue to compare?\n      if (typeof nextProp === 'string') {\n        if (domElement.textContent !== nextProp) {\n          if (true && !suppressHydrationWarning) {\n            warnForTextDifference(domElement.textContent, nextProp);\n          }\n          updatePayload = [CHILDREN, nextProp];\n        }\n      } else if (typeof nextProp === 'number') {\n        if (domElement.textContent !== '' + nextProp) {\n          if (true && !suppressHydrationWarning) {\n            warnForTextDifference(domElement.textContent, nextProp);\n          }\n          updatePayload = [CHILDREN, '' + nextProp];\n        }\n      }\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else {\n      // Validate that the properties correspond to their expected values.\n      var serverValue;\n      var propertyInfo;\n      if (suppressHydrationWarning) {\n        // Don't bother comparing. We're ignoring all these warnings.\n      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||\n      // Controlled attributes are not validated\n      // TODO: Only ignore them on controlled tags.\n      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {\n        // Noop\n      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n        var rawHtml = nextProp ? nextProp[HTML] || '' : '';\n        var serverHTML = domElement.innerHTML;\n        var expectedHTML = normalizeHTML(domElement, rawHtml);\n        if (expectedHTML !== serverHTML) {\n          warnForPropDifference(propKey, serverHTML, expectedHTML);\n        }\n      } else if (propKey === STYLE) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        extraAttributeNames['delete'](propKey);\n        var expectedStyle = createDangerousStringForStyles(nextProp);\n        serverValue = domElement.getAttribute('style');\n        if (expectedStyle !== serverValue) {\n          warnForPropDifference(propKey, serverValue, expectedStyle);\n        }\n      } else if (isCustomComponentTag) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        extraAttributeNames['delete'](propKey.toLowerCase());\n        serverValue = getValueForAttribute(domElement, propKey, nextProp);\n\n        if (nextProp !== serverValue) {\n          warnForPropDifference(propKey, serverValue, nextProp);\n        }\n      } else if (shouldSetAttribute(propKey, nextProp)) {\n        if (propertyInfo = getPropertyInfo(propKey)) {\n          // $FlowFixMe - Should be inferred as not undefined.\n          extraAttributeNames['delete'](propertyInfo.attributeName);\n          serverValue = getValueForProperty(domElement, propKey, nextProp);\n        } else {\n          var ownNamespace = parentNamespace;\n          if (ownNamespace === HTML_NAMESPACE) {\n            ownNamespace = getIntrinsicNamespace(tag);\n          }\n          if (ownNamespace === HTML_NAMESPACE) {\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames['delete'](propKey.toLowerCase());\n          } else {\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames['delete'](propKey);\n          }\n          serverValue = getValueForAttribute(domElement, propKey, nextProp);\n        }\n\n        if (nextProp !== serverValue) {\n          warnForPropDifference(propKey, serverValue, nextProp);\n        }\n      }\n    }\n  }\n\n  {\n    // $FlowFixMe - Should be inferred as not undefined.\n    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {\n      // $FlowFixMe - Should be inferred as not undefined.\n      warnForExtraAttributes(extraAttributeNames);\n    }\n  }\n\n  switch (tag) {\n    case 'input':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper(domElement, rawProps);\n      break;\n    case 'textarea':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper$3(domElement, rawProps);\n      break;\n    case 'select':\n    case 'option':\n      // For input and textarea we current always set the value property at\n      // post mount to force it to diverge from attributes. However, for\n      // option and select we don't quite do the same thing and select\n      // is not resilient to the DOM state changing so we don't do that here.\n      // TODO: Consider not doing this for input and textarea.\n      break;\n    default:\n      if (typeof rawProps.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n\n  return updatePayload;\n}\n\nfunction diffHydratedText$1(textNode, text) {\n  var isDifferent = textNode.nodeValue !== text;\n  return isDifferent;\n}\n\nfunction warnForUnmatchedText$1(textNode, text) {\n  {\n    warnForTextDifference(textNode.nodeValue, text);\n  }\n}\n\nfunction warnForDeletedHydratableElement$1(parentNode, child) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForDeletedHydratableText$1(parentNode, child) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Did not expect server HTML to contain the text node \"%s\" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForInsertedHydratedElement$1(parentNode, tag, props) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForInsertedHydratedText$1(parentNode, text) {\n  {\n    if (text === '') {\n      // We expect to insert empty text nodes since they're not represented in\n      // the HTML.\n      // TODO: Remove this special case if we can just avoid inserting empty\n      // text nodes.\n      return;\n    }\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Expected server HTML to contain a matching text node for \"%s\" in <%s>.', text, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction restoreControlledState(domElement, tag, props) {\n  switch (tag) {\n    case 'input':\n      restoreControlledState$1(domElement, props);\n      return;\n    case 'textarea':\n      restoreControlledState$3(domElement, props);\n      return;\n    case 'select':\n      restoreControlledState$2(domElement, props);\n      return;\n  }\n}\n\nvar ReactDOMFiberComponent = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateTextNode: createTextNode$1,\n\tsetInitialProperties: setInitialProperties$1,\n\tdiffProperties: diffProperties$1,\n\tupdateProperties: updateProperties$1,\n\tdiffHydratedProperties: diffHydratedProperties$1,\n\tdiffHydratedText: diffHydratedText$1,\n\twarnForUnmatchedText: warnForUnmatchedText$1,\n\twarnForDeletedHydratableElement: warnForDeletedHydratableElement$1,\n\twarnForDeletedHydratableText: warnForDeletedHydratableText$1,\n\twarnForInsertedHydratedElement: warnForInsertedHydratedElement$1,\n\twarnForInsertedHydratedText: warnForInsertedHydratedText$1,\n\trestoreControlledState: restoreControlledState\n});\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberStackAddendum$6 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar validateDOMNesting = emptyFunction$1;\n\n{\n  // This validation code was written based on the HTML5 parsing spec:\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  //\n  // Note: this does not catch all invalid nesting, nor does it try to (as it's\n  // not clear what practical benefit doing so provides); instead, we warn only\n  // for cases where the parser will give a parse tree differing from what React\n  // intended. For example, <b><div></div></b> is invalid but we don't warn\n  // because it still parses correctly; we do warn for other cases like nested\n  // <p> tags where the beginning of the second element implicitly closes the\n  // first, causing a confusing mess.\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#special\n  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n  // TODO: Distinguish by namespace here -- for <title>, including it here\n  // errs on the side of fewer warnings\n  'foreignObject', 'desc', 'title'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\n  var buttonScopeTags = inScopeTags.concat(['button']);\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\n  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n\n  var emptyAncestorInfo = {\n    current: null,\n\n    formTag: null,\n    aTagInScope: null,\n    buttonTagInScope: null,\n    nobrTagInScope: null,\n    pTagInButtonScope: null,\n\n    listItemTagAutoclosing: null,\n    dlItemTagAutoclosing: null\n  };\n\n  var updatedAncestorInfo$1 = function (oldInfo, tag, instance) {\n    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);\n    var info = { tag: tag, instance: instance };\n\n    if (inScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.aTagInScope = null;\n      ancestorInfo.buttonTagInScope = null;\n      ancestorInfo.nobrTagInScope = null;\n    }\n    if (buttonScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.pTagInButtonScope = null;\n    }\n\n    // See rules for 'li', 'dd', 'dt' start tags in\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {\n      ancestorInfo.listItemTagAutoclosing = null;\n      ancestorInfo.dlItemTagAutoclosing = null;\n    }\n\n    ancestorInfo.current = info;\n\n    if (tag === 'form') {\n      ancestorInfo.formTag = info;\n    }\n    if (tag === 'a') {\n      ancestorInfo.aTagInScope = info;\n    }\n    if (tag === 'button') {\n      ancestorInfo.buttonTagInScope = info;\n    }\n    if (tag === 'nobr') {\n      ancestorInfo.nobrTagInScope = info;\n    }\n    if (tag === 'p') {\n      ancestorInfo.pTagInButtonScope = info;\n    }\n    if (tag === 'li') {\n      ancestorInfo.listItemTagAutoclosing = info;\n    }\n    if (tag === 'dd' || tag === 'dt') {\n      ancestorInfo.dlItemTagAutoclosing = info;\n    }\n\n    return ancestorInfo;\n  };\n\n  /**\n   * Returns whether\n   */\n  var isTagValidWithParent = function (tag, parentTag) {\n    // First, let's check if we're in an unusual parsing mode...\n    switch (parentTag) {\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n      case 'select':\n        return tag === 'option' || tag === 'optgroup' || tag === '#text';\n      case 'optgroup':\n        return tag === 'option' || tag === '#text';\n      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n      // but\n      case 'option':\n        return tag === '#text';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n      // No special behavior since these rules fall back to \"in body\" mode for\n      // all except special table nodes which cause bad parsing behavior anyway.\n\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n      case 'tr':\n        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n      case 'tbody':\n      case 'thead':\n      case 'tfoot':\n        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n      case 'colgroup':\n        return tag === 'col' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n      case 'table':\n        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n      case 'head':\n        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n      case 'html':\n        return tag === 'head' || tag === 'body';\n      case '#document':\n        return tag === 'html';\n    }\n\n    // Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n    // where the parsing rules cause implicit opens or closes to be added.\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    switch (tag) {\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';\n\n      case 'rp':\n      case 'rt':\n        return impliedEndTags.indexOf(parentTag) === -1;\n\n      case 'body':\n      case 'caption':\n      case 'col':\n      case 'colgroup':\n      case 'frame':\n      case 'head':\n      case 'html':\n      case 'tbody':\n      case 'td':\n      case 'tfoot':\n      case 'th':\n      case 'thead':\n      case 'tr':\n        // These tags are only valid with a few parents that have special child\n        // parsing rules -- if we're down here, then none of those matched and\n        // so we allow it only if we don't know what the parent is, as all other\n        // cases are invalid.\n        return parentTag == null;\n    }\n\n    return true;\n  };\n\n  /**\n   * Returns whether\n   */\n  var findInvalidAncestorForTag = function (tag, ancestorInfo) {\n    switch (tag) {\n      case 'address':\n      case 'article':\n      case 'aside':\n      case 'blockquote':\n      case 'center':\n      case 'details':\n      case 'dialog':\n      case 'dir':\n      case 'div':\n      case 'dl':\n      case 'fieldset':\n      case 'figcaption':\n      case 'figure':\n      case 'footer':\n      case 'header':\n      case 'hgroup':\n      case 'main':\n      case 'menu':\n      case 'nav':\n      case 'ol':\n      case 'p':\n      case 'section':\n      case 'summary':\n      case 'ul':\n      case 'pre':\n      case 'listing':\n      case 'table':\n      case 'hr':\n      case 'xmp':\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return ancestorInfo.pTagInButtonScope;\n\n      case 'form':\n        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\n\n      case 'li':\n        return ancestorInfo.listItemTagAutoclosing;\n\n      case 'dd':\n      case 'dt':\n        return ancestorInfo.dlItemTagAutoclosing;\n\n      case 'button':\n        return ancestorInfo.buttonTagInScope;\n\n      case 'a':\n        // Spec says something about storing a list of markers, but it sounds\n        // equivalent to this check.\n        return ancestorInfo.aTagInScope;\n\n      case 'nobr':\n        return ancestorInfo.nobrTagInScope;\n    }\n\n    return null;\n  };\n\n  var didWarn = {};\n\n  validateDOMNesting = function (childTag, childText, ancestorInfo) {\n    ancestorInfo = ancestorInfo || emptyAncestorInfo;\n    var parentInfo = ancestorInfo.current;\n    var parentTag = parentInfo && parentInfo.tag;\n\n    if (childText != null) {\n      warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null');\n      childTag = '#text';\n    }\n\n    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\n    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\n    var invalidParentOrAncestor = invalidParent || invalidAncestor;\n    if (!invalidParentOrAncestor) {\n      return;\n    }\n\n    var ancestorTag = invalidParentOrAncestor.tag;\n    var addendum = getCurrentFiberStackAddendum$6();\n\n    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;\n    if (didWarn[warnKey]) {\n      return;\n    }\n    didWarn[warnKey] = true;\n\n    var tagDisplayName = childTag;\n    var whitespaceInfo = '';\n    if (childTag === '#text') {\n      if (/\\S/.test(childText)) {\n        tagDisplayName = 'Text nodes';\n      } else {\n        tagDisplayName = 'Whitespace text nodes';\n        whitespaceInfo = \" Make sure you don't have any extra whitespace between tags on \" + 'each line of your source code.';\n      }\n    } else {\n      tagDisplayName = '<' + childTag + '>';\n    }\n\n    if (invalidParent) {\n      var info = '';\n      if (ancestorTag === 'table' && childTag === 'tr') {\n        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';\n      }\n      warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);\n    } else {\n      warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);\n    }\n  };\n\n  // TODO: turn this into a named export\n  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1;\n\n  // For testing\n  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {\n    ancestorInfo = ancestorInfo || emptyAncestorInfo;\n    var parentInfo = ancestorInfo.current;\n    var parentTag = parentInfo && parentInfo.tag;\n    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);\n  };\n}\n\nvar validateDOMNesting$1 = validateDOMNesting;\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar createElement = createElement$1;\nvar createTextNode = createTextNode$1;\nvar setInitialProperties = setInitialProperties$1;\nvar diffProperties = diffProperties$1;\nvar updateProperties = updateProperties$1;\nvar diffHydratedProperties = diffHydratedProperties$1;\nvar diffHydratedText = diffHydratedText$1;\nvar warnForUnmatchedText = warnForUnmatchedText$1;\nvar warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;\nvar warnForDeletedHydratableText = warnForDeletedHydratableText$1;\nvar warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;\nvar warnForInsertedHydratedText = warnForInsertedHydratedText$1;\nvar updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;\nvar precacheFiberNode = precacheFiberNode$1;\nvar updateFiberProps = updateFiberProps$1;\n\n\n{\n  var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n  if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {\n    warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');\n  }\n}\n\ninjection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);\n\nvar eventsEnabled = null;\nvar selectionInformation = null;\n\n/**\n * True if the supplied DOM node is a valid node element.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM is a valid DOM node.\n * @internal\n */\nfunction isValidContainer(node) {\n  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));\n}\n\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nfunction shouldHydrateDueToLegacyHeuristic(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));\n}\n\nfunction shouldAutoFocusHostComponent(type, props) {\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n  }\n  return false;\n}\n\nvar DOMRenderer = reactReconciler({\n  getRootHostContext: function (rootContainerInstance) {\n    var type = void 0;\n    var namespace = void 0;\n    var nodeType = rootContainerInstance.nodeType;\n    switch (nodeType) {\n      case DOCUMENT_NODE:\n      case DOCUMENT_FRAGMENT_NODE:\n        {\n          type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n          var root = rootContainerInstance.documentElement;\n          namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n          break;\n        }\n      default:\n        {\n          var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n          var ownNamespace = container.namespaceURI || null;\n          type = container.tagName;\n          namespace = getChildNamespace(ownNamespace, type);\n          break;\n        }\n    }\n    {\n      var validatedTag = type.toLowerCase();\n      var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);\n      return { namespace: namespace, ancestorInfo: _ancestorInfo };\n    }\n    return namespace;\n  },\n  getChildHostContext: function (parentHostContext, type) {\n    {\n      var parentHostContextDev = parentHostContext;\n      var _namespace = getChildNamespace(parentHostContextDev.namespace, type);\n      var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);\n      return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };\n    }\n    var parentNamespace = parentHostContext;\n    return getChildNamespace(parentNamespace, type);\n  },\n  getPublicInstance: function (instance) {\n    return instance;\n  },\n  prepareForCommit: function () {\n    eventsEnabled = isEnabled();\n    selectionInformation = getSelectionInformation();\n    setEnabled(false);\n  },\n  resetAfterCommit: function () {\n    restoreSelection(selectionInformation);\n    selectionInformation = null;\n    setEnabled(eventsEnabled);\n    eventsEnabled = null;\n  },\n  createInstance: function (type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n    var parentNamespace = void 0;\n    {\n      // TODO: take namespace into account when validating.\n      var hostContextDev = hostContext;\n      validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);\n      if (typeof props.children === 'string' || typeof props.children === 'number') {\n        var string = '' + props.children;\n        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n        validateDOMNesting$1(null, string, ownAncestorInfo);\n      }\n      parentNamespace = hostContextDev.namespace;\n    }\n    var domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n    precacheFiberNode(internalInstanceHandle, domElement);\n    updateFiberProps(domElement, props);\n    return domElement;\n  },\n  appendInitialChild: function (parentInstance, child) {\n    parentInstance.appendChild(child);\n  },\n  finalizeInitialChildren: function (domElement, type, props, rootContainerInstance) {\n    setInitialProperties(domElement, type, props, rootContainerInstance);\n    return shouldAutoFocusHostComponent(type, props);\n  },\n  prepareUpdate: function (domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n    {\n      var hostContextDev = hostContext;\n      if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\n        var string = '' + newProps.children;\n        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n        validateDOMNesting$1(null, string, ownAncestorInfo);\n      }\n    }\n    return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);\n  },\n  shouldSetTextContent: function (type, props) {\n    return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';\n  },\n  shouldDeprioritizeSubtree: function (type, props) {\n    return !!props.hidden;\n  },\n  createTextInstance: function (text, rootContainerInstance, hostContext, internalInstanceHandle) {\n    {\n      var hostContextDev = hostContext;\n      validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);\n    }\n    var textNode = createTextNode(text, rootContainerInstance);\n    precacheFiberNode(internalInstanceHandle, textNode);\n    return textNode;\n  },\n\n\n  now: now,\n\n  mutation: {\n    commitMount: function (domElement, type, newProps, internalInstanceHandle) {\n      domElement.focus();\n    },\n    commitUpdate: function (domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n      // Update the props handle so that we know which props are the ones with\n      // with current event handlers.\n      updateFiberProps(domElement, newProps);\n      // Apply the diff to the DOM node.\n      updateProperties(domElement, updatePayload, type, oldProps, newProps);\n    },\n    resetTextContent: function (domElement) {\n      domElement.textContent = '';\n    },\n    commitTextUpdate: function (textInstance, oldText, newText) {\n      textInstance.nodeValue = newText;\n    },\n    appendChild: function (parentInstance, child) {\n      parentInstance.appendChild(child);\n    },\n    appendChildToContainer: function (container, child) {\n      if (container.nodeType === COMMENT_NODE) {\n        container.parentNode.insertBefore(child, container);\n      } else {\n        container.appendChild(child);\n      }\n    },\n    insertBefore: function (parentInstance, child, beforeChild) {\n      parentInstance.insertBefore(child, beforeChild);\n    },\n    insertInContainerBefore: function (container, child, beforeChild) {\n      if (container.nodeType === COMMENT_NODE) {\n        container.parentNode.insertBefore(child, beforeChild);\n      } else {\n        container.insertBefore(child, beforeChild);\n      }\n    },\n    removeChild: function (parentInstance, child) {\n      parentInstance.removeChild(child);\n    },\n    removeChildFromContainer: function (container, child) {\n      if (container.nodeType === COMMENT_NODE) {\n        container.parentNode.removeChild(child);\n      } else {\n        container.removeChild(child);\n      }\n    }\n  },\n\n  hydration: {\n    canHydrateInstance: function (instance, type, props) {\n      if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n        return null;\n      }\n      // This has now been refined to an element node.\n      return instance;\n    },\n    canHydrateTextInstance: function (instance, text) {\n      if (text === '' || instance.nodeType !== TEXT_NODE) {\n        // Empty strings are not parsed by HTML so there won't be a correct match here.\n        return null;\n      }\n      // This has now been refined to a text node.\n      return instance;\n    },\n    getNextHydratableSibling: function (instance) {\n      var node = instance.nextSibling;\n      // Skip non-hydratable nodes.\n      while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {\n        node = node.nextSibling;\n      }\n      return node;\n    },\n    getFirstHydratableChild: function (parentInstance) {\n      var next = parentInstance.firstChild;\n      // Skip non-hydratable nodes.\n      while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {\n        next = next.nextSibling;\n      }\n      return next;\n    },\n    hydrateInstance: function (instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n      precacheFiberNode(internalInstanceHandle, instance);\n      // TODO: Possibly defer this until the commit phase where all the events\n      // get attached.\n      updateFiberProps(instance, props);\n      var parentNamespace = void 0;\n      {\n        var hostContextDev = hostContext;\n        parentNamespace = hostContextDev.namespace;\n      }\n      return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);\n    },\n    hydrateTextInstance: function (textInstance, text, internalInstanceHandle) {\n      precacheFiberNode(internalInstanceHandle, textInstance);\n      return diffHydratedText(textInstance, text);\n    },\n    didNotMatchHydratedContainerTextInstance: function (parentContainer, textInstance, text) {\n      {\n        warnForUnmatchedText(textInstance, text);\n      }\n    },\n    didNotMatchHydratedTextInstance: function (parentType, parentProps, parentInstance, textInstance, text) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        warnForUnmatchedText(textInstance, text);\n      }\n    },\n    didNotHydrateContainerInstance: function (parentContainer, instance) {\n      {\n        if (instance.nodeType === 1) {\n          warnForDeletedHydratableElement(parentContainer, instance);\n        } else {\n          warnForDeletedHydratableText(parentContainer, instance);\n        }\n      }\n    },\n    didNotHydrateInstance: function (parentType, parentProps, parentInstance, instance) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        if (instance.nodeType === 1) {\n          warnForDeletedHydratableElement(parentInstance, instance);\n        } else {\n          warnForDeletedHydratableText(parentInstance, instance);\n        }\n      }\n    },\n    didNotFindHydratableContainerInstance: function (parentContainer, type, props) {\n      {\n        warnForInsertedHydratedElement(parentContainer, type, props);\n      }\n    },\n    didNotFindHydratableContainerTextInstance: function (parentContainer, text) {\n      {\n        warnForInsertedHydratedText(parentContainer, text);\n      }\n    },\n    didNotFindHydratableInstance: function (parentType, parentProps, parentInstance, type, props) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        warnForInsertedHydratedElement(parentInstance, type, props);\n      }\n    },\n    didNotFindHydratableTextInstance: function (parentType, parentProps, parentInstance, text) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        warnForInsertedHydratedText(parentInstance, text);\n      }\n    }\n  },\n\n  scheduleDeferredCallback: rIC,\n\n  useSyncScheduling: !enableAsyncSchedulingByDefaultInReactDOM\n});\n\ninjection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);\n\nvar warnedAboutHydrateAPI = false;\n\nfunction renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n\n  {\n    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n      var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);\n      if (hostInstance) {\n        warning(hostInstance.parentNode === container, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');\n      }\n    }\n\n    var isRootRenderedBySomeReact = !!container._reactRootContainer;\n    var rootEl = getReactRootElementInContainer(container);\n    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));\n\n    warning(!hasNonRootReactChild || isRootRenderedBySomeReact, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');\n\n    warning(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');\n  }\n\n  var root = container._reactRootContainer;\n  if (!root) {\n    var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n    // First clear any existing content.\n    if (!shouldHydrate) {\n      var warned = false;\n      var rootSibling = void 0;\n      while (rootSibling = container.lastChild) {\n        {\n          if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {\n            warned = true;\n            warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');\n          }\n        }\n        container.removeChild(rootSibling);\n      }\n    }\n    {\n      if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n        warnedAboutHydrateAPI = true;\n        lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');\n      }\n    }\n    var newRoot = DOMRenderer.createContainer(container, shouldHydrate);\n    root = container._reactRootContainer = newRoot;\n    // Initial mount should not be batched.\n    DOMRenderer.unbatchedUpdates(function () {\n      DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);\n    });\n  } else {\n    DOMRenderer.updateContainer(children, root, parentComponent, callback);\n  }\n  return DOMRenderer.getPublicRootInstance(root);\n}\n\nfunction createPortal(children, container) {\n  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n  // TODO: pass ReactDOM portal implementation as third argument\n  return createPortal$1(children, container, null, key);\n}\n\nfunction ReactRoot(container, hydrate) {\n  var root = DOMRenderer.createContainer(container, hydrate);\n  this._reactRootContainer = root;\n}\nReactRoot.prototype.render = function (children, callback) {\n  var root = this._reactRootContainer;\n  DOMRenderer.updateContainer(children, root, null, callback);\n};\nReactRoot.prototype.unmount = function (callback) {\n  var root = this._reactRootContainer;\n  DOMRenderer.updateContainer(null, root, null, callback);\n};\n\nvar ReactDOM = {\n  createPortal: createPortal,\n\n  findDOMNode: function (componentOrElement) {\n    {\n      var owner = ReactCurrentOwner.current;\n      if (owner !== null) {\n        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n        warning(warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner) || 'A component');\n        owner.stateNode._warnedAboutRefsInRender = true;\n      }\n    }\n    if (componentOrElement == null) {\n      return null;\n    }\n    if (componentOrElement.nodeType === ELEMENT_NODE) {\n      return componentOrElement;\n    }\n\n    var inst = get(componentOrElement);\n    if (inst) {\n      return DOMRenderer.findHostInstance(inst);\n    }\n\n    if (typeof componentOrElement.render === 'function') {\n      invariant(false, 'Unable to find node on an unmounted component.');\n    } else {\n      invariant(false, 'Element appears to be neither ReactComponent nor DOMNode. Keys: %s', Object.keys(componentOrElement));\n    }\n  },\n  hydrate: function (element, container, callback) {\n    // TODO: throw or warn if we couldn't hydrate?\n    return renderSubtreeIntoContainer(null, element, container, true, callback);\n  },\n  render: function (element, container, callback) {\n    return renderSubtreeIntoContainer(null, element, container, false, callback);\n  },\n  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {\n    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;\n    return renderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n  },\n  unmountComponentAtNode: function (container) {\n    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;\n\n    if (container._reactRootContainer) {\n      {\n        var rootEl = getReactRootElementInContainer(container);\n        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);\n        warning(!renderedByDifferentReact, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by another copy of React.');\n      }\n\n      // Unmount should not be batched.\n      DOMRenderer.unbatchedUpdates(function () {\n        renderSubtreeIntoContainer(null, null, container, false, function () {\n          container._reactRootContainer = null;\n        });\n      });\n      // If you call unmountComponentAtNode twice in quick succession, you'll\n      // get `true` twice. That's probably fine?\n      return true;\n    } else {\n      {\n        var _rootEl = getReactRootElementInContainer(container);\n        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));\n\n        // Check if the container itself is a React root node.\n        var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;\n\n        warning(!hasNonRootReactChild, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');\n      }\n\n      return false;\n    }\n  },\n\n\n  // Temporary alias since we already shipped React 16 RC with it.\n  // TODO: remove in React 17.\n  unstable_createPortal: createPortal,\n\n  unstable_batchedUpdates: batchedUpdates,\n\n  unstable_deferredUpdates: DOMRenderer.deferredUpdates,\n\n  flushSync: DOMRenderer.flushSync,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    // For TapEventPlugin which is popular in open source\n    EventPluginHub: EventPluginHub,\n    // Used by test-utils\n    EventPluginRegistry: EventPluginRegistry,\n    EventPropagators: EventPropagators,\n    ReactControlledComponent: ReactControlledComponent,\n    ReactDOMComponentTree: ReactDOMComponentTree,\n    ReactDOMEventListener: ReactDOMEventListener\n  }\n};\n\nif (enableCreateRoot) {\n  ReactDOM.createRoot = function createRoot(container, options) {\n    var hydrate = options != null && options.hydrate === true;\n    return new ReactRoot(container, hydrate);\n  };\n}\n\nvar foundDevTools = DOMRenderer.injectIntoDevTools({\n  findFiberByHostInstance: getClosestInstanceFromNode,\n  bundleType: 1,\n  version: ReactVersion,\n  rendererPackageName: 'react-dom'\n});\n\n{\n  if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {\n    // If we're in Chrome or Firefox, provide a download link if not installed.\n    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {\n      var protocol = window.location.protocol;\n      // Don't warn in exotic cases like chrome-extension://.\n      if (/^(https?|file):$/.test(protocol)) {\n        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');\n      }\n    }\n  }\n}\n\n\n\nvar ReactDOM$2 = Object.freeze({\n\tdefault: ReactDOM\n});\n\nvar ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactDom = ReactDOM$3['default'] ? ReactDOM$3['default'] : ReactDOM$3;\n\nmodule.exports = reactDom;\n  })();\n}\n"]},"metadata":{},"sourceType":"script"}